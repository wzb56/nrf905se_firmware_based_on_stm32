###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     28/May/2011  10:37:09 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Documents and Settings\253642xvvn\桌面\nrf905se\bigbo #
#                    ard\send6\library\src\stm32f10x_spi.c                    #
#    Command line =  "C:\Documents and Settings\253642xvvn\桌面\nrf905se\bigb #
#                    oard\send6\library\src\stm32f10x_spi.c" -lC              #
#                    "C:\Documents and Settings\253642xvvn\桌面\nrf905se\bigb #
#                    oard\send6\Debug\List\" -lb "C:\Documents and            #
#                    Settings\253642xvvn\桌面\nrf905se\bigboard\send6\Debug\L #
#                    ist\" -o "C:\Documents and Settings\253642xvvn\桌面\nrf9 #
#                    05se\bigboard\send6\Debug\Obj\" --no_cse --no_unroll     #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "D:\Program Files\IAR        #
#                    Systems\Embedded Workbench 5.4\arm\INC\DLib_Config_Full. #
#                    h" -I "C:\Documents and Settings\253642xvvn\桌面\nrf905s #
#                    e\bigboard\send6\library\inc\" -I "C:\Documents and      #
#                    Settings\253642xvvn\桌面\nrf905se\bigboard\send6\board\" #
#                     -I "C:\Documents and Settings\253642xvvn\桌面\nrf905se\ #
#                    bigboard\send6\app\" -I "D:\Program Files\IAR            #
#                    Systems\Embedded Workbench 5.4\arm\INC\" -Ol             #
#    List file    =  C:\Documents and Settings\253642xvvn\桌面\nrf905se\bigbo #
#                    ard\send6\Debug\List\stm32f10x_spi.lst                   #
#    Object file  =  C:\Documents and Settings\253642xvvn\桌面\nrf905se\bigbo #
#                    ard\send6\Debug\Obj\stm32f10x_spi.o                      #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\253642xvvn\桌面\nrf905se\bigboard\send6\library\src\stm32f10x_spi.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : stm32f10x_spi.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.0.1
      5          * Date               : 06/13/2008
      6          * Description        : This file provides all the SPI firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          
     16          /* Includes ------------------------------------------------------------------*/
     17          #include "stm32f10x_spi.h"
     18          #include "stm32f10x_rcc.h"
     19          
     20          /* Private typedef -----------------------------------------------------------*/
     21          /* Private define ------------------------------------------------------------*/
     22          /* SPI SPE mask */
     23          #define CR1_SPE_Set          ((u16)0x0040)
     24          #define CR1_SPE_Reset        ((u16)0xFFBF)
     25          
     26          /* I2S I2SE mask */
     27          #define I2SCFGR_I2SE_Set     ((u16)0x0400)
     28          #define I2SCFGR_I2SE_Reset   ((u16)0xFBFF)
     29          
     30          /* SPI CRCNext mask */
     31          #define CR1_CRCNext_Set      ((u16)0x1000)
     32          
     33          /* SPI CRCEN mask */
     34          #define CR1_CRCEN_Set        ((u16)0x2000)
     35          #define CR1_CRCEN_Reset      ((u16)0xDFFF)
     36          
     37          /* SPI SSOE mask */
     38          #define CR2_SSOE_Set         ((u16)0x0004)
     39          #define CR2_SSOE_Reset       ((u16)0xFFFB)
     40          
     41          /* SPI registers Masks */
     42          #define CR1_CLEAR_Mask       ((u16)0x3040)
     43          #define I2SCFGR_CLEAR_Mask   ((u16)0xF040)
     44          
     45          /* SPI or I2S mode selection masks */
     46          #define SPI_Mode_Select      ((u16)0xF7FF)
     47          #define I2S_Mode_Select      ((u16)0x0800)
     48          
     49          /* Private macro -------------------------------------------------------------*/
     50          /* Private variables ---------------------------------------------------------*/
     51          /* Private function prototypes -----------------------------------------------*/
     52          /* Private functions ---------------------------------------------------------*/
     53          
     54          /*******************************************************************************
     55          * Function Name  : SPI_I2S_DeInit
     56          * Description    : Deinitializes the SPIx peripheral registers to their default
     57          *                  reset values (Affects also the I2Ss).
     58          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
     59          * Output         : None
     60          * Return         : None
     61          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
     62          void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
     63          {
   \                     SPI_I2S_DeInit:
   \   00000000   80B5               PUSH     {R7,LR}
     64            /* Check the parameters */
     65            assert_param(IS_SPI_ALL_PERIPH(SPIx));
     66          
     67            switch (*(u32*)&SPIx)
   \   00000002   1649               LDR.N    R1,??SPI_I2S_DeInit_0  ;; 0x40003800
   \   00000004   401A               SUBS     R0,R0,R1
   \   00000006   12D0               BEQ.N    ??SPI_I2S_DeInit_1
   \   00000008   4FF48061           MOV      R1,#+1024
   \   0000000C   401A               SUBS     R0,R0,R1
   \   0000000E   19D0               BEQ.N    ??SPI_I2S_DeInit_2
   \   00000010   4FF47441           MOV      R1,#+62464
   \   00000014   401A               SUBS     R0,R0,R1
   \   00000016   20D1               BNE.N    ??SPI_I2S_DeInit_3
     68            {
     69              case SPI1_BASE:
     70                /* Enable SPI1 reset state */
     71                RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
   \                     ??SPI_I2S_DeInit_4:
   \   00000018   0121               MOVS     R1,#+1
   \   0000001A   4FF48050           MOV      R0,#+4096
   \   0000001E   ........           BL       RCC_APB2PeriphResetCmd
     72                /* Release SPI1 from reset state */
     73                RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
   \   00000022   0021               MOVS     R1,#+0
   \   00000024   4FF48050           MOV      R0,#+4096
   \   00000028   ........           BL       RCC_APB2PeriphResetCmd
   \   0000002C   15E0               B.N      ??SPI_I2S_DeInit_5
     74                break;
     75          
     76              case SPI2_BASE:
     77                /* Enable SPI2 reset state */
     78                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
   \                     ??SPI_I2S_DeInit_1:
   \   0000002E   0121               MOVS     R1,#+1
   \   00000030   4FF48040           MOV      R0,#+16384
   \   00000034   ........           BL       RCC_APB1PeriphResetCmd
     79                /* Release SPI2 from reset state */
     80                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
   \   00000038   0021               MOVS     R1,#+0
   \   0000003A   4FF48040           MOV      R0,#+16384
   \   0000003E   ........           BL       RCC_APB1PeriphResetCmd
   \   00000042   0AE0               B.N      ??SPI_I2S_DeInit_5
     81                break;
     82          
     83              case SPI3_BASE:
     84                /* Enable SPI3 reset state */
     85                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
   \                     ??SPI_I2S_DeInit_2:
   \   00000044   0121               MOVS     R1,#+1
   \   00000046   4FF40040           MOV      R0,#+32768
   \   0000004A   ........           BL       RCC_APB1PeriphResetCmd
     86                /* Release SPI3 from reset state */
     87                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
   \   0000004E   0021               MOVS     R1,#+0
   \   00000050   4FF40040           MOV      R0,#+32768
   \   00000054   ........           BL       RCC_APB1PeriphResetCmd
   \   00000058   FFE7               B.N      ??SPI_I2S_DeInit_5
     88                break;
     89          
     90              default:
     91                break;
     92            }
     93          }
   \                     ??SPI_I2S_DeInit_3:
   \                     ??SPI_I2S_DeInit_5:
   \   0000005A   01BD               POP      {R0,PC}          ;; return
   \                     ??SPI_I2S_DeInit_0:
   \   0000005C   00380040           DC32     0x40003800
     94          
     95          /*******************************************************************************
     96          * Function Name  : SPI_Init
     97          * Description    : Initializes the SPIx peripheral according to the specified
     98          *                  parameters in the SPI_InitStruct.
     99          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    100          *                  - SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
    101          *                    contains the configuration information for the specified
    102          *                    SPI peripheral.
    103          * Output         : None
    104          * Return         : None
    105          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    106          void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
    107          {
   \                     SPI_Init:
   \   00000000   18B4               PUSH     {R3,R4}
    108            u16 tmpreg = 0;
   \   00000002   0022               MOVS     R2,#+0
    109          
    110            /* check the parameters */
    111            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    112          
    113            /* Check the SPI parameters */
    114            assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
    115            assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
    116            assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
    117            assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
    118            assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
    119            assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
    120            assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
    121            assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
    122            assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
    123          
    124          /*---------------------------- SPIx CR1 Configuration ------------------------*/
    125            /* Get the SPIx CR1 value */
    126            tmpreg = SPIx->CR1;
   \   00000004   0388               LDRH     R3,[R0, #+0]
   \   00000006   1A00               MOVS     R2,R3
    127            /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
    128            tmpreg &= CR1_CLEAR_Mask;
   \   00000008   12F44152           ANDS     R2,R2,#0x3040
    129            /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
    130               master/salve mode, CPOL and CPHA */
    131            /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
    132            /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    133            /* Set LSBFirst bit according to SPI_FirstBit value */
    134            /* Set BR bits according to SPI_BaudRatePrescaler value */
    135            /* Set CPOL bit according to SPI_CPOL value */
    136            /* Set CPHA bit according to SPI_CPHA value */
    137            tmpreg |= (u16)((u32)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
    138                            SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |
    139                            SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |
    140                            SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
   \   0000000C   0B88               LDRH     R3,[R1, #+0]
   \   0000000E   4C88               LDRH     R4,[R1, #+2]
   \   00000010   2343               ORRS     R3,R4,R3
   \   00000012   8C88               LDRH     R4,[R1, #+4]
   \   00000014   2343               ORRS     R3,R4,R3
   \   00000016   CC88               LDRH     R4,[R1, #+6]
   \   00000018   2343               ORRS     R3,R4,R3
   \   0000001A   0C89               LDRH     R4,[R1, #+8]
   \   0000001C   2343               ORRS     R3,R4,R3
   \   0000001E   4C89               LDRH     R4,[R1, #+10]
   \   00000020   2343               ORRS     R3,R4,R3
   \   00000022   8C89               LDRH     R4,[R1, #+12]
   \   00000024   2343               ORRS     R3,R4,R3
   \   00000026   CC89               LDRH     R4,[R1, #+14]
   \   00000028   2343               ORRS     R3,R4,R3
   \   0000002A   1A43               ORRS     R2,R3,R2
    141            /* Write to SPIx CR1 */
    142            SPIx->CR1 = tmpreg;
   \   0000002C   0280               STRH     R2,[R0, #+0]
    143          
    144            /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
    145            SPIx->I2SCFGR &= SPI_Mode_Select;		
   \   0000002E   828B               LDRH     R2,[R0, #+28]
   \   00000030   32F40062           BICS     R2,R2,#0x800
   \   00000034   8283               STRH     R2,[R0, #+28]
    146          
    147          /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
    148            /* Write to SPIx CRCPOLY */
    149            SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
   \   00000036   098A               LDRH     R1,[R1, #+16]
   \   00000038   0182               STRH     R1,[R0, #+16]
    150          }
   \   0000003A   11BC               POP      {R0,R4}
   \   0000003C   7047               BX       LR               ;; return
    151          
    152          /*******************************************************************************
    153          * Function Name  : I2S_Init
    154          * Description    : Initializes the SPIx peripheral according to the specified
    155          *                  parameters in the I2S_InitStruct.
    156          * Input          : - SPIx: where x can be  2 or 3 to select the SPI peripheral
    157          *                     (configured in I2S mode).
    158          *                  - I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
    159          *                    contains the configuration information for the specified
    160          *                    SPI peripheral configured in I2S mode.
    161          * Output         : None
    162          * Return         : None
    163          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    164          void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
    165          {
   \                     I2S_Init:
   \   00000000   F0B5               PUSH     {R4-R7,LR}
   \   00000002   85B0               SUB      SP,SP,#+20
   \   00000004   0500               MOVS     R5,R0
   \   00000006   0C00               MOVS     R4,R1
    166            u16 tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
   \   00000008   0026               MOVS     R6,#+0
   \   0000000A   0221               MOVS     R1,#+2
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   0127               MOVS     R7,#+1
    167            u32 tmp = 0;
   \   00000010   0022               MOVS     R2,#+0
    168            RCC_ClocksTypeDef RCC_Clocks;
    169          
    170            /* Check the I2S parameters */
    171            assert_param(IS_SPI_23_PERIPH(SPIx));
    172            assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
    173            assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
    174            assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
    175            assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
    176            assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
    177            assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));
    178          
    179          /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
    180          
    181            /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    182            SPIx->I2SCFGR &= I2SCFGR_CLEAR_Mask;
   \   00000012   AB8B               LDRH     R3,[R5, #+28]
   \   00000014   4FF2400C           MOVW     R12,#+61504
   \   00000018   1CEA0303           ANDS     R3,R12,R3
   \   0000001C   AB83               STRH     R3,[R5, #+28]
    183            SPIx->I2SPR = 0x0002;
   \   0000001E   0223               MOVS     R3,#+2
   \   00000020   2B84               STRH     R3,[R5, #+32]
    184          
    185            /* Get the I2SCFGR register value */
    186            tmpreg = SPIx->I2SCFGR;
   \   00000022   AB8B               LDRH     R3,[R5, #+28]
   \   00000024   1E00               MOVS     R6,R3
    187          
    188            /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
    189            if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
   \   00000026   2389               LDRH     R3,[R4, #+8]
   \   00000028   022B               CMP      R3,#+2
   \   0000002A   02D1               BNE.N    ??I2S_Init_0
    190            {
    191              i2sodd = (u16)0;
   \   0000002C   0020               MOVS     R0,#+0
    192              i2sdiv = (u16)2;
   \   0000002E   0221               MOVS     R1,#+2
   \   00000030   30E0               B.N      ??I2S_Init_1
    193            }
    194            /* If the requested audio frequency is not the default, compute the prescaler */
    195            else
    196            {
    197              /* Check the frame length (For the Prescaler computing) */
    198              if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
   \                     ??I2S_Init_0:
   \   00000032   A088               LDRH     R0,[R4, #+4]
   \   00000034   0028               CMP      R0,#+0
   \   00000036   01D1               BNE.N    ??I2S_Init_2
    199              {
    200                /* Packet length is 16 bits */
    201                packetlength = 1;
   \   00000038   0127               MOVS     R7,#+1
   \   0000003A   00E0               B.N      ??I2S_Init_3
    202              }
    203              else
    204              {
    205                /* Packet length is 32 bits */
    206                packetlength = 2;
   \                     ??I2S_Init_2:
   \   0000003C   0227               MOVS     R7,#+2
    207              }
    208              /* Get System Clock frequency */
    209              RCC_GetClocksFreq(&RCC_Clocks);
   \                     ??I2S_Init_3:
   \   0000003E   00A8               ADD      R0,SP,#+0
   \   00000040   ........           BL       RCC_GetClocksFreq
    210          
    211              /* Compute the Real divider depending on the MCLK output state with a flaoting point */
    212              if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
   \   00000044   E088               LDRH     R0,[R4, #+6]
   \   00000046   4FF40071           MOV      R1,#+512
   \   0000004A   8842               CMP      R0,R1
   \   0000004C   0DD1               BNE.N    ??I2S_Init_4
    213              {
    214                /* MCLK output is enabled */
    215                tmp = (u16)(((10 * RCC_Clocks.SYSCLK_Frequency) / (256 * I2S_InitStruct->I2S_AudioFreq)) + 5);
   \   0000004E   0098               LDR      R0,[SP, #+0]
   \   00000050   0A21               MOVS     R1,#+10
   \   00000052   00FB01F0           MUL      R0,R0,R1
   \   00000056   2189               LDRH     R1,[R4, #+8]
   \   00000058   4FF48072           MOV      R2,#+256
   \   0000005C   01FB02F1           MUL      R1,R1,R2
   \   00000060   B0FBF1F0           UDIV     R0,R0,R1
   \   00000064   421D               ADDS     R2,R0,#+5
   \   00000066   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000068   0BE0               B.N      ??I2S_Init_5
    216              }
    217              else
    218              {
    219                /* MCLK output is disabled */
    220                tmp = (u16)(((10 * RCC_Clocks.SYSCLK_Frequency) / (32 * packetlength * I2S_InitStruct->I2S_AudioFreq)) + 5);
   \                     ??I2S_Init_4:
   \   0000006A   0098               LDR      R0,[SP, #+0]
   \   0000006C   0A21               MOVS     R1,#+10
   \   0000006E   00FB01F0           MUL      R0,R0,R1
   \   00000072   BFB2               UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000074   2189               LDRH     R1,[R4, #+8]
   \   00000076   7943               MULS     R1,R7,R1
   \   00000078   4901               LSLS     R1,R1,#+5
   \   0000007A   B0FBF1F0           UDIV     R0,R0,R1
   \   0000007E   421D               ADDS     R2,R0,#+5
   \   00000080   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
    221              }
    222          
    223              /* Remove the flaoting point */
    224              tmp = tmp/10;
   \                     ??I2S_Init_5:
   \   00000082   0A20               MOVS     R0,#+10
   \   00000084   B2FBF0F2           UDIV     R2,R2,R0
    225          
    226              /* Check the parity of the divider */
    227              i2sodd = (u16)(tmp & (u16)0x0001);
   \   00000088   12F00100           ANDS     R0,R2,#0x1
    228          
    229              /* Compute the i2sdiv prescaler */
    230              i2sdiv = (u16)((tmp - i2sodd) / 2);
   \   0000008C   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000008E   111A               SUBS     R1,R2,R0
   \   00000090   4908               LSRS     R1,R1,#+1
    231          
    232              /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    233              i2sodd = (u16) (i2sodd << 8);
   \   00000092   0002               LSLS     R0,R0,#+8
    234            }
    235          
    236            /* Test if the divider is 1 or 0 */
    237            if ((i2sdiv < 2) || (i2sdiv > 0xFF))
   \                     ??I2S_Init_1:
   \   00000094   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000096   0229               CMP      R1,#+2
   \   00000098   04D3               BCC.N    ??I2S_Init_6
   \   0000009A   4FF48072           MOV      R2,#+256
   \   0000009E   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000A0   9142               CMP      R1,R2
   \   000000A2   01D3               BCC.N    ??I2S_Init_7
    238            {
    239              /* Set the default values */
    240              i2sdiv = 2;
   \                     ??I2S_Init_6:
   \   000000A4   0221               MOVS     R1,#+2
    241              i2sodd = 0;
   \   000000A6   0020               MOVS     R0,#+0
    242            }
    243          
    244            /* Write to SPIx I2SPR register the computed value */
    245            SPIx->I2SPR = (u16)(i2sdiv | i2sodd | I2S_InitStruct->I2S_MCLKOutput);
   \                     ??I2S_Init_7:
   \   000000A8   0843               ORRS     R0,R0,R1
   \   000000AA   E188               LDRH     R1,[R4, #+6]
   \   000000AC   0843               ORRS     R0,R1,R0
   \   000000AE   2884               STRH     R0,[R5, #+32]
    246          
    247            /* Configure the I2S with the SPI_InitStruct values */
    248            tmpreg |= (u16)(I2S_Mode_Select | I2S_InitStruct->I2S_Mode | \
    249                            I2S_InitStruct->I2S_Standard | I2S_InitStruct->I2S_DataFormat | \
    250                            I2S_InitStruct->I2S_CPOL);
   \   000000B0   2088               LDRH     R0,[R4, #+0]
   \   000000B2   6188               LDRH     R1,[R4, #+2]
   \   000000B4   0843               ORRS     R0,R1,R0
   \   000000B6   A188               LDRH     R1,[R4, #+4]
   \   000000B8   0843               ORRS     R0,R1,R0
   \   000000BA   6189               LDRH     R1,[R4, #+10]
   \   000000BC   0843               ORRS     R0,R1,R0
   \   000000BE   50F40060           ORRS     R0,R0,#0x800
   \   000000C2   0643               ORRS     R6,R0,R6
    251          
    252            /* Write to SPIx I2SCFGR */
    253            SPIx->I2SCFGR = tmpreg;
   \   000000C4   AE83               STRH     R6,[R5, #+28]
    254          }
   \   000000C6   05B0               ADD      SP,SP,#+20
   \   000000C8   F0BD               POP      {R4-R7,PC}       ;; return
    255          
    256          /*******************************************************************************
    257          * Function Name  : SPI_StructInit
    258          * Description    : Fills each SPI_InitStruct member with its default value.
    259          * Input          : - SPI_InitStruct : pointer to a SPI_InitTypeDef structure
    260          *                    which will be initialized.
    261          * Output         : None
    262          * Return         : None
    263          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    264          void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
    265          {
    266          /*--------------- Reset SPI init structure parameters values -----------------*/
    267            /* Initialize the SPI_Direction member */
    268            SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
   \                     SPI_StructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   0180               STRH     R1,[R0, #+0]
    269          
    270            /* initialize the SPI_Mode member */
    271            SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   4180               STRH     R1,[R0, #+2]
    272          
    273            /* initialize the SPI_DataSize member */
    274            SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   8180               STRH     R1,[R0, #+4]
    275          
    276            /* Initialize the SPI_CPOL member */
    277            SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   C180               STRH     R1,[R0, #+6]
    278          
    279            /* Initialize the SPI_CPHA member */
    280            SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
   \   00000010   0021               MOVS     R1,#+0
   \   00000012   0181               STRH     R1,[R0, #+8]
    281          
    282            /* Initialize the SPI_NSS member */
    283            SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
   \   00000014   0021               MOVS     R1,#+0
   \   00000016   4181               STRH     R1,[R0, #+10]
    284          
    285            /* Initialize the SPI_BaudRatePrescaler member */
    286            SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
   \   00000018   0021               MOVS     R1,#+0
   \   0000001A   8181               STRH     R1,[R0, #+12]
    287          
    288            /* Initialize the SPI_FirstBit member */
    289            SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
   \   0000001C   0021               MOVS     R1,#+0
   \   0000001E   C181               STRH     R1,[R0, #+14]
    290          
    291            /* Initialize the SPI_CRCPolynomial member */
    292            SPI_InitStruct->SPI_CRCPolynomial = 7;
   \   00000020   0721               MOVS     R1,#+7
   \   00000022   0182               STRH     R1,[R0, #+16]
    293          }
   \   00000024   7047               BX       LR               ;; return
    294          
    295          /*******************************************************************************
    296          * Function Name  : I2S_StructInit
    297          * Description    : Fills each I2S_InitStruct member with its default value.
    298          * Input          : - I2S_InitStruct : pointer to a I2S_InitTypeDef structure
    299          *                    which will be initialized.
    300          * Output         : None
    301          * Return         : None
    302          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    303          void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
    304          {
    305          /*--------------- Reset I2S init structure parameters values -----------------*/
    306            /* Initialize the I2S_Mode member */
    307            I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
   \                     I2S_StructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   0180               STRH     R1,[R0, #+0]
    308          
    309            /* Initialize the I2S_Standard member */
    310            I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   4180               STRH     R1,[R0, #+2]
    311          
    312            /* Initialize the I2S_DataFormat member */
    313            I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   8180               STRH     R1,[R0, #+4]
    314          
    315            /* Initialize the I2S_MCLKOutput member */
    316            I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   C180               STRH     R1,[R0, #+6]
    317          
    318            /* Initialize the I2S_AudioFreq member */
    319            I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
   \   00000010   0221               MOVS     R1,#+2
   \   00000012   0181               STRH     R1,[R0, #+8]
    320          
    321            /* Initialize the I2S_CPOL member */
    322            I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
   \   00000014   0021               MOVS     R1,#+0
   \   00000016   4181               STRH     R1,[R0, #+10]
    323          }
   \   00000018   7047               BX       LR               ;; return
    324          
    325          /*******************************************************************************
    326          * Function Name  : SPI_Cmd
    327          * Description    : Enables or disables the specified SPI peripheral.
    328          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    329          *                  - NewState: new state of the SPIx peripheral.
    330          *                    This parameter can be: ENABLE or DISABLE.
    331          * Output         : None
    332          * Return         : None
    333          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    334          void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    335          {
    336            /* Check the parameters */
    337            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    338            assert_param(IS_FUNCTIONAL_STATE(NewState));
    339          
    340            if (NewState != DISABLE)
   \                     SPI_Cmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??SPI_Cmd_0
    341            {
    342              /* Enable the selected SPI peripheral */
    343              SPIx->CR1 |= CR1_SPE_Set;
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   51F04001           ORRS     R1,R1,#0x40
   \   0000000C   0180               STRH     R1,[R0, #+0]
   \   0000000E   03E0               B.N      ??SPI_Cmd_1
    344            }
    345            else
    346            {
    347              /* Disable the selected SPI peripheral */
    348              SPIx->CR1 &= CR1_SPE_Reset;
   \                     ??SPI_Cmd_0:
   \   00000010   0188               LDRH     R1,[R0, #+0]
   \   00000012   31F04001           BICS     R1,R1,#0x40
   \   00000016   0180               STRH     R1,[R0, #+0]
    349            }
    350          }
   \                     ??SPI_Cmd_1:
   \   00000018   7047               BX       LR               ;; return
    351          
    352          /*******************************************************************************
    353          * Function Name  : I2S_Cmd
    354          * Description    : Enables or disables the specified SPI peripheral (in I2S mode).
    355          * Input          : - SPIx: where x can be 2 or 3 to select the SPI peripheral.
    356          *                  - NewState: new state of the SPIx peripheral.
    357          *                    This parameter can be: ENABLE or DISABLE.
    358          * Output         : None
    359          * Return         : None
    360          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    361          void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    362          {
    363            /* Check the parameters */
    364            assert_param(IS_SPI_23_PERIPH(SPIx));
    365            assert_param(IS_FUNCTIONAL_STATE(NewState));
    366          
    367            if (NewState != DISABLE)
   \                     I2S_Cmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??I2S_Cmd_0
    368            {
    369              /* Enable the selected SPI peripheral (in I2S mode) */
    370              SPIx->I2SCFGR |= I2SCFGR_I2SE_Set;
   \   00000006   818B               LDRH     R1,[R0, #+28]
   \   00000008   51F48061           ORRS     R1,R1,#0x400
   \   0000000C   8183               STRH     R1,[R0, #+28]
   \   0000000E   03E0               B.N      ??I2S_Cmd_1
    371            }
    372            else
    373            {
    374              /* Disable the selected SPI peripheral (in I2S mode) */
    375              SPIx->I2SCFGR &= I2SCFGR_I2SE_Reset;
   \                     ??I2S_Cmd_0:
   \   00000010   818B               LDRH     R1,[R0, #+28]
   \   00000012   31F48061           BICS     R1,R1,#0x400
   \   00000016   8183               STRH     R1,[R0, #+28]
    376            }
    377          }
   \                     ??I2S_Cmd_1:
   \   00000018   7047               BX       LR               ;; return
    378          
    379          /*******************************************************************************
    380          * Function Name  : SPI_I2S_ITConfig
    381          * Description    : Enables or disables the specified SPI/I2S interrupts.
    382          * Input          : - SPIx: where x can be :
    383          *                         - 1, 2 or 3 in SPI mode
    384          *                         - 2 or 3 in I2S mode
    385          *                  - SPI_I2S_IT: specifies the SPI/I2S interrupt source to be
    386          *                    enabled or disabled.
    387          *                    This parameter can be one of the following values:
    388          *                       - SPI_I2S_IT_TXE: Tx buffer empty interrupt mask
    389          *                       - SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask
    390          *                       - SPI_I2S_IT_ERR: Error interrupt mask
    391          *                  - NewState: new state of the specified SPI/I2S interrupt.
    392          *                    This parameter can be: ENABLE or DISABLE.
    393          * Output         : None
    394          * Return         : None
    395          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    396          void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, u8 SPI_I2S_IT, FunctionalState NewState)
    397          {
   \                     SPI_I2S_ITConfig:
   \   00000000   18B4               PUSH     {R3,R4}
    398            u16 itpos = 0, itmask = 0 ;
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   0024               MOVS     R4,#+0
    399          
    400            /* Check the parameters */
    401            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    402            assert_param(IS_FUNCTIONAL_STATE(NewState));
    403            assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
    404          
    405            /* Get the SPI/I2S IT index */
    406            itpos = SPI_I2S_IT >> 4;
   \   00000006   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0909               LSRS     R1,R1,#+4
   \   0000000A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0B00               MOVS     R3,R1
    407            /* Set the IT mask */
    408            itmask = (u16)((u16)1 << itpos);
   \   0000000E   0121               MOVS     R1,#+1
   \   00000010   9940               LSLS     R1,R1,R3
   \   00000012   0C00               MOVS     R4,R1
    409          
    410            if (NewState != DISABLE)
   \   00000014   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000016   002A               CMP      R2,#+0
   \   00000018   03D0               BEQ.N    ??SPI_I2S_ITConfig_0
    411            {
    412              /* Enable the selected SPI/I2S interrupt */
    413              SPIx->CR2 |= itmask;
   \   0000001A   8188               LDRH     R1,[R0, #+4]
   \   0000001C   2143               ORRS     R1,R4,R1
   \   0000001E   8180               STRH     R1,[R0, #+4]
   \   00000020   03E0               B.N      ??SPI_I2S_ITConfig_1
    414            }
    415            else
    416            {
    417              /* Disable the selected SPI/I2S interrupt */
    418              SPIx->CR2 &= (u16)~itmask;
   \                     ??SPI_I2S_ITConfig_0:
   \   00000022   8188               LDRH     R1,[R0, #+4]
   \   00000024   E243               MVNS     R2,R4
   \   00000026   1140               ANDS     R1,R2,R1
   \   00000028   8180               STRH     R1,[R0, #+4]
    419            }
    420          }
   \                     ??SPI_I2S_ITConfig_1:
   \   0000002A   11BC               POP      {R0,R4}
   \   0000002C   7047               BX       LR               ;; return
    421          
    422          /*******************************************************************************
    423          * Function Name  : SPI_I2S_DMACmd
    424          * Description    : Enables or disables the SPIx/I2Sx DMA interface.
    425          * Input          : - SPIx: where x can be :
    426          *                         - 1, 2 or 3 in SPI mode
    427          *                         - 2 or 3 in I2S mode
    428          *                  - SPI_I2S_DMAReq: specifies the SPI/I2S DMA transfer request
    429          *                    to be enabled or disabled.
    430          *                    This parameter can be any combination of the following values:
    431          *                       - SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
    432          *                       - SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
    433          *                  - NewState: new state of the selected SPI/I2S DMA transfer
    434          *                    request.
    435          *                    This parameter can be: ENABLE or DISABLE.
    436          * Output         : None
    437          * Return         : None
    438          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    439          void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, u16 SPI_I2S_DMAReq, FunctionalState NewState)
    440          {
    441            /* Check the parameters */
    442            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    443            assert_param(IS_FUNCTIONAL_STATE(NewState));
    444            assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
    445          
    446            if (NewState != DISABLE)
   \                     SPI_I2S_DMACmd:
   \   00000000   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   002A               CMP      R2,#+0
   \   00000004   03D0               BEQ.N    ??SPI_I2S_DMACmd_0
    447            {
    448              /* Enable the selected SPI/I2S DMA requests */
    449              SPIx->CR2 |= SPI_I2S_DMAReq;
   \   00000006   8288               LDRH     R2,[R0, #+4]
   \   00000008   1143               ORRS     R1,R1,R2
   \   0000000A   8180               STRH     R1,[R0, #+4]
   \   0000000C   03E0               B.N      ??SPI_I2S_DMACmd_1
    450            }
    451            else
    452            {
    453              /* Disable the selected SPI/I2S DMA requests */
    454              SPIx->CR2 &= (u16)~SPI_I2S_DMAReq;
   \                     ??SPI_I2S_DMACmd_0:
   \   0000000E   8288               LDRH     R2,[R0, #+4]
   \   00000010   C943               MVNS     R1,R1
   \   00000012   1140               ANDS     R1,R1,R2
   \   00000014   8180               STRH     R1,[R0, #+4]
    455            }
    456          }
   \                     ??SPI_I2S_DMACmd_1:
   \   00000016   7047               BX       LR               ;; return
    457          
    458          /*******************************************************************************
    459          * Function Name  : SPI_I2S_SendData
    460          * Description    : Transmits a Data through the SPIx/I2Sx peripheral.
    461          * Input          : - SPIx: where x can be :
    462          *                         - 1, 2 or 3 in SPI mode
    463          *                         - 2 or 3 in I2S mode
    464          *                  - Data : Data to be transmitted..
    465          * Output         : None
    466          * Return         : None
    467          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    468          void SPI_I2S_SendData(SPI_TypeDef* SPIx, u16 Data)
    469          {
    470            /* Check the parameters */
    471            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    472          
    473            /* Write in the DR register the data to be sent */
    474            SPIx->DR = Data;
   \                     SPI_I2S_SendData:
   \   00000000   8181               STRH     R1,[R0, #+12]
    475          }
   \   00000002   7047               BX       LR               ;; return
    476          
    477          /*******************************************************************************
    478          * Function Name  : SPI_I2S_ReceiveData
    479          * Description    : Returns the most recent received data by the SPIx/I2Sx peripheral.
    480          * Input          : - SPIx: where x can be :
    481          *                         - 1, 2 or 3 in SPI mode
    482          *                         - 2 or 3 in I2S mode
    483          * Output         : None
    484          * Return         : The value of the received data.
    485          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    486          u16 SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
    487          {
    488            /* Check the parameters */
    489            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    490          
    491            /* Return the data in the DR register */
    492            return SPIx->DR;
   \                     SPI_I2S_ReceiveData:
   \   00000000   8089               LDRH     R0,[R0, #+12]
   \   00000002   7047               BX       LR               ;; return
    493          }
    494          
    495          /*******************************************************************************
    496          * Function Name  : SPI_NSSInternalSoftwareConfig
    497          * Description    : Configures internally by software the NSS pin for the selected
    498          *                  SPI.
    499          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    500          *                  - SPI_NSSInternalSoft: specifies the SPI NSS internal state.
    501          *                    This parameter can be one of the following values:
    502          *                       - SPI_NSSInternalSoft_Set: Set NSS pin internally
    503          *                       - SPI_NSSInternalSoft_Reset: Reset NSS pin internally
    504          * Output         : None
    505          * Return         : None
    506          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    507          void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, u16 SPI_NSSInternalSoft)
    508          {
    509            /* Check the parameters */
    510            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    511            assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
    512          
    513            if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
   \                     SPI_NSSInternalSoftwareConfig:
   \   00000000   4FF6FF62           MOVW     R2,#+65279
   \   00000004   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   9142               CMP      R1,R2
   \   00000008   04D0               BEQ.N    ??SPI_NSSInternalSoftwareConfig_0
    514            {
    515              /* Set NSS pin internally by software */
    516              SPIx->CR1 |= SPI_NSSInternalSoft_Set;
   \   0000000A   0188               LDRH     R1,[R0, #+0]
   \   0000000C   51F48071           ORRS     R1,R1,#0x100
   \   00000010   0180               STRH     R1,[R0, #+0]
   \   00000012   03E0               B.N      ??SPI_NSSInternalSoftwareConfig_1
    517            }
    518            else
    519            {
    520              /* Reset NSS pin internally by software */
    521              SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
   \                     ??SPI_NSSInternalSoftwareConfig_0:
   \   00000014   0188               LDRH     R1,[R0, #+0]
   \   00000016   31F48071           BICS     R1,R1,#0x100
   \   0000001A   0180               STRH     R1,[R0, #+0]
    522            }
    523          }
   \                     ??SPI_NSSInternalSoftwareConfig_1:
   \   0000001C   7047               BX       LR               ;; return
    524          
    525          /*******************************************************************************
    526          * Function Name  : SPI_SSOutputCmd
    527          * Description    : Enables or disables the SS output for the selected SPI.
    528          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    529          *                  - NewState: new state of the SPIx SS output.
    530          *                    This parameter can be: ENABLE or DISABLE.
    531          * Output         : None
    532          * Return         : None
    533          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    534          void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    535          {
    536            /* Check the parameters */
    537            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    538            assert_param(IS_FUNCTIONAL_STATE(NewState));
    539          
    540            if (NewState != DISABLE)
   \                     SPI_SSOutputCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??SPI_SSOutputCmd_0
    541            {
    542              /* Enable the selected SPI SS output */
    543              SPIx->CR2 |= CR2_SSOE_Set;
   \   00000006   8188               LDRH     R1,[R0, #+4]
   \   00000008   51F00401           ORRS     R1,R1,#0x4
   \   0000000C   8180               STRH     R1,[R0, #+4]
   \   0000000E   03E0               B.N      ??SPI_SSOutputCmd_1
    544            }
    545            else
    546            {
    547              /* Disable the selected SPI SS output */
    548              SPIx->CR2 &= CR2_SSOE_Reset;
   \                     ??SPI_SSOutputCmd_0:
   \   00000010   8188               LDRH     R1,[R0, #+4]
   \   00000012   31F00401           BICS     R1,R1,#0x4
   \   00000016   8180               STRH     R1,[R0, #+4]
    549            }
    550          }
   \                     ??SPI_SSOutputCmd_1:
   \   00000018   7047               BX       LR               ;; return
    551          
    552          /*******************************************************************************
    553          * Function Name  : SPI_DataSizeConfig
    554          * Description    : Configures the data size for the selected SPI.
    555          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    556          *                  - SPI_DataSize: specifies the SPI data size.
    557          *                    This parameter can be one of the following values:
    558          *                       - SPI_DataSize_16b: Set data frame format to 16bit
    559          *                       - SPI_DataSize_8b: Set data frame format to 8bit
    560          * Output         : None
    561          * Return         : None
    562          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    563          void SPI_DataSizeConfig(SPI_TypeDef* SPIx, u16 SPI_DataSize)
    564          {
    565            /* Check the parameters */
    566            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    567            assert_param(IS_SPI_DATASIZE(SPI_DataSize));
    568          
    569            /* Clear DFF bit */
    570            SPIx->CR1 &= (u16)~SPI_DataSize_16b;
   \                     SPI_DataSizeConfig:
   \   00000000   0288               LDRH     R2,[R0, #+0]
   \   00000002   32F40062           BICS     R2,R2,#0x800
   \   00000006   0280               STRH     R2,[R0, #+0]
    571            /* Set new DFF bit value */
    572            SPIx->CR1 |= SPI_DataSize;
   \   00000008   0288               LDRH     R2,[R0, #+0]
   \   0000000A   1143               ORRS     R1,R1,R2
   \   0000000C   0180               STRH     R1,[R0, #+0]
    573          }
   \   0000000E   7047               BX       LR               ;; return
    574          
    575          /*******************************************************************************
    576          * Function Name  : SPI_TransmitCRC
    577          * Description    : Transmit the SPIx CRC value.
    578          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    579          * Output         : None
    580          * Return         : None
    581          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    582          void SPI_TransmitCRC(SPI_TypeDef* SPIx)
    583          {
    584            /* Check the parameters */
    585            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    586          
    587            /* Enable the selected SPI CRC transmission */
    588            SPIx->CR1 |= CR1_CRCNext_Set;
   \                     SPI_TransmitCRC:
   \   00000000   0188               LDRH     R1,[R0, #+0]
   \   00000002   51F48051           ORRS     R1,R1,#0x1000
   \   00000006   0180               STRH     R1,[R0, #+0]
    589          }
   \   00000008   7047               BX       LR               ;; return
    590          
    591          /*******************************************************************************
    592          * Function Name  : SPI_CalculateCRC
    593          * Description    : Enables or disables the CRC value calculation of the
    594          *                  transfered bytes.
    595          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    596          *                  - NewState: new state of the SPIx CRC value calculation.
    597          *                    This parameter can be: ENABLE or DISABLE.
    598          * Output         : None
    599          * Return         : None
    600          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    601          void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
    602          {
    603            /* Check the parameters */
    604            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    605            assert_param(IS_FUNCTIONAL_STATE(NewState));
    606          
    607            if (NewState != DISABLE)
   \                     SPI_CalculateCRC:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??SPI_CalculateCRC_0
    608            {
    609              /* Enable the selected SPI CRC calculation */
    610              SPIx->CR1 |= CR1_CRCEN_Set;
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   51F40051           ORRS     R1,R1,#0x2000
   \   0000000C   0180               STRH     R1,[R0, #+0]
   \   0000000E   03E0               B.N      ??SPI_CalculateCRC_1
    611            }
    612            else
    613            {
    614              /* Disable the selected SPI CRC calculation */
    615              SPIx->CR1 &= CR1_CRCEN_Reset;
   \                     ??SPI_CalculateCRC_0:
   \   00000010   0188               LDRH     R1,[R0, #+0]
   \   00000012   31F40051           BICS     R1,R1,#0x2000
   \   00000016   0180               STRH     R1,[R0, #+0]
    616            }
    617          }
   \                     ??SPI_CalculateCRC_1:
   \   00000018   7047               BX       LR               ;; return
    618          
    619          /*******************************************************************************
    620          * Function Name  : SPI_GetCRC
    621          * Description    : Returns the transmit or the receive CRC register value for
    622          *                  the specified SPI.
    623          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    624          *                  - SPI_CRC: specifies the CRC register to be read.
    625          *                    This parameter can be one of the following values:
    626          *                       - SPI_CRC_Tx: Selects Tx CRC register
    627          *                       - SPI_CRC_Rx: Selects Rx CRC register
    628          * Output         : None
    629          * Return         : The selected CRC register value..
    630          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    631          u16 SPI_GetCRC(SPI_TypeDef* SPIx, u8 SPI_CRC)
    632          {
   \                     SPI_GetCRC:
   \   00000000   0200               MOVS     R2,R0
    633            u16 crcreg = 0;
   \   00000002   0020               MOVS     R0,#+0
    634          
    635            /* Check the parameters */
    636            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    637            assert_param(IS_SPI_CRC(SPI_CRC));
    638          
    639            if (SPI_CRC != SPI_CRC_Rx)
   \   00000004   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0129               CMP      R1,#+1
   \   00000008   01D0               BEQ.N    ??SPI_GetCRC_0
    640            {
    641              /* Get the Tx CRC register */
    642              crcreg = SPIx->TXCRCR;
   \   0000000A   108B               LDRH     R0,[R2, #+24]
   \   0000000C   00E0               B.N      ??SPI_GetCRC_1
    643            }
    644            else
    645            {
    646              /* Get the Rx CRC register */
    647              crcreg = SPIx->RXCRCR;
   \                     ??SPI_GetCRC_0:
   \   0000000E   908A               LDRH     R0,[R2, #+20]
    648            }
    649          
    650            /* Return the selected CRC register */
    651            return crcreg;
   \                     ??SPI_GetCRC_1:
   \   00000010   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000012   7047               BX       LR               ;; return
    652          }
    653          
    654          /*******************************************************************************
    655          * Function Name  : SPI_GetCRCPolynomial
    656          * Description    : Returns the CRC Polynomial register value for the specified SPI.
    657          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    658          * Output         : None
    659          * Return         : The CRC Polynomial register value.
    660          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    661          u16 SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
    662          {
    663            /* Check the parameters */
    664            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    665          
    666            /* Return the CRC polynomial register */
    667            return SPIx->CRCPR;
   \                     SPI_GetCRCPolynomial:
   \   00000000   008A               LDRH     R0,[R0, #+16]
   \   00000002   7047               BX       LR               ;; return
    668          }
    669          
    670          /*******************************************************************************
    671          * Function Name  : SPI_BiDirectionalLineConfig
    672          * Description    : Selects the data transfer direction in bi-directional mode
    673          *                  for the specified SPI.
    674          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    675          *                  - SPI_Direction: specifies the data transfer direction in
    676          *                    bi-directional mode.
    677          *                    This parameter can be one of the following values:
    678          *                       - SPI_Direction_Tx: Selects Tx transmission direction
    679          *                       - SPI_Direction_Rx: Selects Rx receive direction
    680          * Output         : None
    681          * Return         : None
    682          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    683          void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, u16 SPI_Direction)
    684          {
    685            /* Check the parameters */
    686            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    687            assert_param(IS_SPI_DIRECTION(SPI_Direction));
    688          
    689            if (SPI_Direction == SPI_Direction_Tx)
   \                     SPI_BiDirectionalLineConfig:
   \   00000000   4FF48042           MOV      R2,#+16384
   \   00000004   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   9142               CMP      R1,R2
   \   00000008   04D1               BNE.N    ??SPI_BiDirectionalLineConfig_0
    690            {
    691              /* Set the Tx only mode */
    692              SPIx->CR1 |= SPI_Direction_Tx;
   \   0000000A   0188               LDRH     R1,[R0, #+0]
   \   0000000C   51F48041           ORRS     R1,R1,#0x4000
   \   00000010   0180               STRH     R1,[R0, #+0]
   \   00000012   03E0               B.N      ??SPI_BiDirectionalLineConfig_1
    693            }
    694            else
    695            {
    696              /* Set the Rx only mode */
    697              SPIx->CR1 &= SPI_Direction_Rx;
   \                     ??SPI_BiDirectionalLineConfig_0:
   \   00000014   0188               LDRH     R1,[R0, #+0]
   \   00000016   31F48041           BICS     R1,R1,#0x4000
   \   0000001A   0180               STRH     R1,[R0, #+0]
    698            }
    699          }
   \                     ??SPI_BiDirectionalLineConfig_1:
   \   0000001C   7047               BX       LR               ;; return
    700          
    701          /*******************************************************************************
    702          * Function Name  : SPI_I2S_GetFlagStatus
    703          * Description    : Checks whether the specified SPI/I2S flag is set or not.
    704          * Input          : - SPIx: where x can be :
    705          *                         - 1, 2 or 3 in SPI mode
    706          *                         - 2 or 3 in I2S mode
    707          *                  - SPI_I2S_FLAG: specifies the SPI/I2S flag to check.
    708          *                    This parameter can be one of the following values:
    709          *                       - SPI_I2S_FLAG_TXE: Transmit buffer empty flag.
    710          *                       - SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.
    711          *                       - SPI_I2S_FLAG_BSY: Busy flag.
    712          *                       - SPI_I2S_FLAG_OVR: Overrun flag.
    713          *                       - SPI_FLAG_MODF: Mode Fault flag.
    714          *                       - SPI_FLAG_CRCERR: CRC Error flag.
    715          *                       - I2S_FLAG_UDR: Underrun Error flag.
    716          *                       - I2S_FLAG_CHSIDE: Channel Side flag.
    717          * Output         : None
    718          * Return         : The new state of SPI_I2S_FLAG (SET or RESET).
    719          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    720          FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG)
    721          {
   \                     SPI_I2S_GetFlagStatus:
   \   00000000   0200               MOVS     R2,R0
    722            FlagStatus bitstatus = RESET;
   \   00000002   0020               MOVS     R0,#+0
    723          
    724            /* Check the parameters */
    725            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    726            assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
    727          
    728            /* Check the status of the specified SPI/I2S flag */
    729            if ((SPIx->SR & SPI_I2S_FLAG) != (u16)RESET)
   \   00000004   1289               LDRH     R2,[R2, #+8]
   \   00000006   1140               ANDS     R1,R1,R2
   \   00000008   0A00               MOVS     R2,R1
   \   0000000A   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000C   521E               SUBS     R2,R2,#+1
   \   0000000E   9241               SBCS     R2,R2,R2
   \   00000010   D243               MVNS     R2,R2
   \   00000012   D20F               LSRS     R2,R2,#+31
   \   00000014   1000               MOVS     R0,R2
    730            {
    731              /* SPI_I2S_FLAG is set */
    732              bitstatus = SET;
    733            }
    734            else
    735            {
    736              /* SPI_I2S_FLAG is reset */
    737              bitstatus = RESET;
    738            }
    739            /* Return the SPI_I2S_FLAG status */
    740            return  bitstatus;
   \   00000016   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   7047               BX       LR               ;; return
    741          }
    742          
    743          /*******************************************************************************
    744          * Function Name  : SPI_I2S_ClearFlag
    745          * Description    : Clears the SPIx/I2Sx pending flags.
    746          * Input          : - SPIx: where x can be :
    747          *                         - 1, 2 or 3 in SPI mode
    748          *                         - 2 or 3 in I2S mode
    749          *                  - SPI_I2S_FLAG: specifies the SPI/I2S flag to clear.
    750          *                    This parameter can be one of the following values:
    751          *                       - SPI_I2S_FLAG_OVR: Overrun flag
    752          *                       - SPI_FLAG_MODF: Mode Fault flag.
    753          *                       - SPI_FLAG_CRCERR: CRC Error flag.
    754          *                       - I2S_FLAG_UDR: Underrun Error flag.
    755          *                    Note: Before clearing OVR flag, it is mandatory to read
    756          *                          SPI_I2S_DR register, so that the last data is not lost.
    757          * Output         : None
    758          * Return         : None
    759          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    760          void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG)
    761          {
    762            /* Check the parameters */
    763            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    764            assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
    765          
    766            /* SPI_FLAG_MODF flag clear */
    767            if(SPI_I2S_FLAG == SPI_FLAG_MODF)
   \                     SPI_I2S_ClearFlag:
   \   00000000   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   2029               CMP      R1,#+32
   \   00000004   05D1               BNE.N    ??SPI_I2S_ClearFlag_0
    768            {
    769              /* Read SR register */
    770              (void)SPIx->SR;
   \   00000006   0189               LDRH     R1,[R0, #+8]
    771          
    772              /* Write on CR1 register */
    773              SPIx->CR1 |= CR1_SPE_Set;
   \   00000008   0288               LDRH     R2,[R0, #+0]
   \   0000000A   52F04002           ORRS     R2,R2,#0x40
   \   0000000E   0280               STRH     R2,[R0, #+0]
   \   00000010   0AE0               B.N      ??SPI_I2S_ClearFlag_1
    774            }
    775            /* SPI_I2S_FLAG_OVR flag or I2S_FLAG_UDR flag clear */
    776            else if ((SPI_I2S_FLAG == SPI_I2S_FLAG_OVR) || (SPI_I2S_FLAG == I2S_FLAG_UDR))
   \                     ??SPI_I2S_ClearFlag_0:
   \   00000012   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000014   4029               CMP      R1,#+64
   \   00000016   02D0               BEQ.N    ??SPI_I2S_ClearFlag_2
   \   00000018   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001A   0829               CMP      R1,#+8
   \   0000001C   01D1               BNE.N    ??SPI_I2S_ClearFlag_3
    777            {
    778              /* Read SR register  (Before clearing OVR flag, it is mandatory to read
    779                 SPI_I2S_DR register)*/
    780              (void)SPIx->SR;
   \                     ??SPI_I2S_ClearFlag_2:
   \   0000001E   0089               LDRH     R0,[R0, #+8]
   \   00000020   02E0               B.N      ??SPI_I2S_ClearFlag_4
    781            }
    782            else /* SPI_FLAG_CRCERR flag clear */
    783            {
    784              /* Clear the selected SPI flag */
    785              SPIx->SR = (u16)~SPI_I2S_FLAG;
   \                     ??SPI_I2S_ClearFlag_3:
   \   00000022   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000024   C943               MVNS     R1,R1
   \   00000026   0181               STRH     R1,[R0, #+8]
    786            }
    787          }
   \                     ??SPI_I2S_ClearFlag_4:
   \                     ??SPI_I2S_ClearFlag_1:
   \   00000028   7047               BX       LR               ;; return
    788          
    789          /*******************************************************************************
    790          * Function Name  : SPI_I2S_GetITStatus
    791          * Description    : Checks whether the specified SPI/I2S interrupt has occurred or not.
    792          * Input          : - SPIx: where x can be :
    793          *                         - 1, 2 or 3 in SPI mode
    794          *                         - 2 or 3 in I2S mode
    795          *                  - SPI_I2S_IT: specifies the SPI/I2S interrupt source to check.
    796          *                    This parameter can be one of the following values:
    797          *                       - SPI_I2S_IT_TXE: Transmit buffer empty interrupt.
    798          *                       - SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.
    799          *                       - SPI_I2S_IT_OVR: Overrun interrupt.
    800          *                       - SPI_IT_MODF: Mode Fault interrupt.
    801          *                       - SPI_IT_CRCERR: CRC Error interrupt.
    802          *                       - I2S_IT_UDR: Underrun Error interrupt.
    803          * Output         : None
    804          * Return         : The new state of SPI_I2S_IT (SET or RESET).
    805          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    806          ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, u8 SPI_I2S_IT)
    807          {
   \                     SPI_I2S_GetITStatus:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0200               MOVS     R2,R0
    808            ITStatus bitstatus = RESET;
   \   00000004   0020               MOVS     R0,#+0
    809            u16 itpos = 0, itmask = 0, enablestatus = 0;
   \   00000006   0023               MOVS     R3,#+0
   \   00000008   0025               MOVS     R5,#+0
   \   0000000A   0024               MOVS     R4,#+0
    810          
    811            /* Check the parameters */
    812            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    813            assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
    814          
    815            /* Get the SPI/I2S IT index */
    816            itpos = (u16)((u16)0x01 << (SPI_I2S_IT & (u8)0x0F));
   \   0000000C   0126               MOVS     R6,#+1
   \   0000000E   11F00F07           ANDS     R7,R1,#0xF
   \   00000012   BE40               LSLS     R6,R6,R7
   \   00000014   3300               MOVS     R3,R6
    817          
    818            /* Get the SPI/I2S IT mask */
    819            itmask = SPI_I2S_IT >> 4;
   \   00000016   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0909               LSRS     R1,R1,#+4
   \   0000001A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   0D00               MOVS     R5,R1
    820            /* Set the IT mask */
    821            itmask = (u16)((u16)0x01 << itmask);
   \   0000001E   0121               MOVS     R1,#+1
   \   00000020   11FA05F5           LSLS     R5,R1,R5
    822            /* Get the SPI_I2S_IT enable bit status */
    823            enablestatus = (SPIx->CR2 & itmask) ;
   \   00000024   9188               LDRH     R1,[R2, #+4]
   \   00000026   2940               ANDS     R1,R5,R1
   \   00000028   0C00               MOVS     R4,R1
    824          
    825            /* Check the status of the specified SPI/I2S interrupt */
    826            if (((SPIx->SR & itpos) != (u16)RESET) && enablestatus)
   \   0000002A   1189               LDRH     R1,[R2, #+8]
   \   0000002C   1942               TST      R1,R3
   \   0000002E   06D0               BEQ.N    ??SPI_I2S_GetITStatus_0
   \   00000030   2000               MOVS     R0,R4
   \   00000032   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000034   401E               SUBS     R0,R0,#+1
   \   00000036   8041               SBCS     R0,R0,R0
   \   00000038   C043               MVNS     R0,R0
   \   0000003A   C00F               LSRS     R0,R0,#+31
   \   0000003C   00E0               B.N      ??SPI_I2S_GetITStatus_1
    827            {
    828              /* SPI_I2S_IT is set */
    829              bitstatus = SET;
    830            }
    831            else
    832            {
    833              /* SPI_I2S_IT is reset */
    834              bitstatus = RESET;
   \                     ??SPI_I2S_GetITStatus_0:
   \   0000003E   0020               MOVS     R0,#+0
    835            }
    836            /* Return the SPI_I2S_IT status */
    837            return bitstatus;
   \                     ??SPI_I2S_GetITStatus_1:
   \   00000040   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   F2BD               POP      {R1,R4-R7,PC}    ;; return
    838          }
    839          
    840          /*******************************************************************************
    841          * Function Name  : SPI_I2S_ClearITPendingBit
    842          * Description    : Clears the SPIx/I2Sx interrupt pending bits.
    843          * Input          : - SPIx: where x can be :
    844          *                         - 1, 2 or 3 in SPI mode
    845          *                         - 2 or 3 in I2S mode
    846          *                  - SPI_I2S_IT: specifies the SPI/I2S interrupt pending bit to clear.
    847          *                    This parameter can be one of the following values:
    848          *                       - SPI_I2S_IT_OVR: Overrun interrupt.
    849          *                       - SPI_IT_MODF: Mode Fault interrupt.
    850          *                       - SPI_IT_CRCERR: CRC Error interrupt.
    851          *                       - I2S_IT_UDR: Underrun Error interrupt.
    852          * Output         : None
    853          * Return         : None
    854          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    855          void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, u8 SPI_I2S_IT)
    856          {
    857            u16 itpos = 0;
   \                     SPI_I2S_ClearITPendingBit:
   \   00000000   0022               MOVS     R2,#+0
    858          
    859            /* Check the parameters */
    860            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    861            assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
    862          
    863            /* SPI_IT_MODF pending bit clear */
    864            if(SPI_I2S_IT == SPI_IT_MODF)
   \   00000002   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   5529               CMP      R1,#+85
   \   00000006   05D1               BNE.N    ??SPI_I2S_ClearITPendingBit_0
    865            {
    866              /* Read SR register */
    867              (void)SPIx->SR;
   \   00000008   0189               LDRH     R1,[R0, #+8]
    868              /* Write on CR1 register */
    869              SPIx->CR1 |= CR1_SPE_Set;
   \   0000000A   0288               LDRH     R2,[R0, #+0]
   \   0000000C   52F04002           ORRS     R2,R2,#0x40
   \   00000010   0280               STRH     R2,[R0, #+0]
   \   00000012   0EE0               B.N      ??SPI_I2S_ClearITPendingBit_1
    870            }
    871            /* SPI_I2S_IT_OVR or I2S_IT_UDR pending bit clear */
    872            else if((SPI_I2S_IT == SPI_I2S_IT_OVR) || (SPI_I2S_IT == I2S_IT_UDR))
   \                     ??SPI_I2S_ClearITPendingBit_0:
   \   00000014   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   5629               CMP      R1,#+86
   \   00000018   02D0               BEQ.N    ??SPI_I2S_ClearITPendingBit_2
   \   0000001A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   5329               CMP      R1,#+83
   \   0000001E   01D1               BNE.N    ??SPI_I2S_ClearITPendingBit_3
    873            {
    874              /* Read SR register */
    875              (void)(SPIx->SR);
   \                     ??SPI_I2S_ClearITPendingBit_2:
   \   00000020   0089               LDRH     R0,[R0, #+8]
   \   00000022   06E0               B.N      ??SPI_I2S_ClearITPendingBit_4
    876            }
    877            else   /* SPI_IT_CRCERR pending bit clear */
    878            {
    879              /* Get the SPI/I2S IT index */
    880              itpos = (u16)((u16)0x01 << (SPI_I2S_IT & (u8)0x0F));
   \                     ??SPI_I2S_ClearITPendingBit_3:
   \   00000024   0122               MOVS     R2,#+1
   \   00000026   11F00F01           ANDS     R1,R1,#0xF
   \   0000002A   8A40               LSLS     R2,R2,R1
    881              /* Clear the selected SPI/I2S interrupt pending bits */
    882              SPIx->SR = (u16)~itpos;
   \   0000002C   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000002E   D143               MVNS     R1,R2
   \   00000030   0181               STRH     R1,[R0, #+8]
    883            }
    884          }
   \                     ??SPI_I2S_ClearITPendingBit_4:
   \                     ??SPI_I2S_ClearITPendingBit_1:
   \   00000032   7047               BX       LR               ;; return
    885          
    886          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                      .cstack
     --------                      -------
     I2S_Cmd                            0
     I2S_Init                          40
     I2S_StructInit                     0
     SPI_BiDirectionalLineConfig        0
     SPI_CalculateCRC                   0
     SPI_Cmd                            0
     SPI_DataSizeConfig                 0
     SPI_GetCRC                         0
     SPI_GetCRCPolynomial               0
     SPI_I2S_ClearFlag                  0
     SPI_I2S_ClearITPendingBit          0
     SPI_I2S_DMACmd                     0
     SPI_I2S_DeInit                     8
     SPI_I2S_GetFlagStatus              0
     SPI_I2S_GetITStatus               24
     SPI_I2S_ITConfig                   8
     SPI_I2S_ReceiveData                0
     SPI_I2S_SendData                   0
     SPI_Init                           8
     SPI_NSSInternalSoftwareConfig      0
     SPI_SSOutputCmd                    0
     SPI_StructInit                     0
     SPI_TransmitCRC                    0


   Section sizes:

     Function/Label                Bytes
     --------------                -----
     SPI_I2S_DeInit                  96
     SPI_Init                        62
     I2S_Init                       202
     SPI_StructInit                  38
     I2S_StructInit                  26
     SPI_Cmd                         26
     I2S_Cmd                         26
     SPI_I2S_ITConfig                46
     SPI_I2S_DMACmd                  24
     SPI_I2S_SendData                 4
     SPI_I2S_ReceiveData              4
     SPI_NSSInternalSoftwareConfig   30
     SPI_SSOutputCmd                 26
     SPI_DataSizeConfig              16
     SPI_TransmitCRC                 10
     SPI_CalculateCRC                26
     SPI_GetCRC                      20
     SPI_GetCRCPolynomial             4
     SPI_BiDirectionalLineConfig     30
     SPI_I2S_GetFlagStatus           26
     SPI_I2S_ClearFlag               42
     SPI_I2S_GetITStatus             68
     SPI_I2S_ClearITPendingBit       52

 
 904 bytes in section .text
 
 904 bytes of CODE memory

Errors: none
Warnings: none
