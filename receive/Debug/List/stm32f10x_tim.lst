###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     21/May/2011  19:21:02 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Documents and Settings\253642xvvn\桌面\IAR\2.4G_send\ #
#                    FWLib\library\src\stm32f10x_tim.c                        #
#    Command line =  "C:\Documents and Settings\253642xvvn\桌面\IAR\2.4G_send #
#                    \FWLib\library\src\stm32f10x_tim.c" -lC "C:\Documents    #
#                    and Settings\253642xvvn\桌面\IAR\2.4G_send\Demo\project\ #
#                    test\Debug\List\" -lb "C:\Documents and                  #
#                    Settings\253642xvvn\桌面\IAR\2.4G_send\Demo\project\test #
#                    \Debug\List\" -o "C:\Documents and                       #
#                    Settings\253642xvvn\桌面\IAR\2.4G_send\Demo\project\test #
#                    \Debug\Obj\" --no_cse --no_unroll --no_inline            #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "D:\Program Files\IAR        #
#                    Systems\Embedded Workbench 5.4\arm\INC\DLib_Config_Full. #
#                    h" -I "C:\Documents and Settings\253642xvvn\桌面\IAR\2.4 #
#                    G_send\Demo\project\test\FWLib\library\inc\" -I          #
#                    "C:\Documents and Settings\253642xvvn\桌面\IAR\2.4G_send #
#                    \Demo\project\test\board\" -I "C:\Documents and          #
#                    Settings\253642xvvn\桌面\IAR\2.4G_send\Demo\project\test #
#                    \app\" -I "D:\Program Files\IAR Systems\Embedded         #
#                    Workbench 5.4\arm\INC\" -Ol                              #
#    List file    =  C:\Documents and Settings\253642xvvn\桌面\IAR\2.4G_send\ #
#                    Demo\project\test\Debug\List\stm32f10x_tim.lst           #
#    Object file  =  C:\Documents and Settings\253642xvvn\桌面\IAR\2.4G_send\ #
#                    Demo\project\test\Debug\Obj\stm32f10x_tim.o              #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\253642xvvn\桌面\IAR\2.4G_send\FWLib\library\src\stm32f10x_tim.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : stm32f10x_tim.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.0.1
      5          * Date               : 06/13/2008
      6          * Description        : This file provides all the TIM firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          
     16          /* Includes ------------------------------------------------------------------*/
     17          #include "stm32f10x_tim.h"
     18          #include "stm32f10x_rcc.h"
     19          
     20          /* Private typedef -----------------------------------------------------------*/
     21          /* Private define ------------------------------------------------------------*/
     22          /* ---------------------- TIM registers bit mask ------------------------ */
     23          #define CR1_CEN_Set                 ((u16)0x0001)
     24          #define CR1_CEN_Reset               ((u16)0x03FE)
     25          #define CR1_UDIS_Set                ((u16)0x0002)
     26          #define CR1_UDIS_Reset              ((u16)0x03FD)
     27          #define CR1_URS_Set                 ((u16)0x0004)
     28          #define CR1_URS_Reset               ((u16)0x03FB)
     29          #define CR1_OPM_Reset               ((u16)0x03F7)
     30          #define CR1_CounterMode_Mask        ((u16)0x038F)
     31          #define CR1_ARPE_Set                ((u16)0x0080)
     32          #define CR1_ARPE_Reset              ((u16)0x037F)
     33          #define CR1_CKD_Mask                ((u16)0x00FF)
     34          
     35          #define CR2_CCPC_Set                ((u16)0x0001)
     36          #define CR2_CCPC_Reset              ((u16)0xFFFE)
     37          #define CR2_CCUS_Set                ((u16)0x0004)
     38          #define CR2_CCUS_Reset              ((u16)0xFFFB)
     39          #define CR2_CCDS_Set                ((u16)0x0008)
     40          #define CR2_CCDS_Reset              ((u16)0xFFF7)
     41          #define CR2_MMS_Mask                ((u16)0xFF8F)
     42          #define CR2_TI1S_Set                ((u16)0x0080)
     43          #define CR2_TI1S_Reset              ((u16)0xFF7F)
     44          #define CR2_OIS1_Reset              ((u16)0x7EFF)
     45          #define CR2_OIS1N_Reset             ((u16)0x7DFF)
     46          #define CR2_OIS2_Reset              ((u16)0x7BFF)
     47          #define CR2_OIS2N_Reset             ((u16)0x77FF)
     48          #define CR2_OIS3_Reset              ((u16)0x6FFF)
     49          #define CR2_OIS3N_Reset             ((u16)0x5FFF)
     50          #define CR2_OIS4_Reset              ((u16)0x3FFF)
     51          
     52          #define SMCR_SMS_Mask               ((u16)0xFFF8)
     53          #define SMCR_ETR_Mask               ((u16)0x00FF)
     54          #define SMCR_TS_Mask                ((u16)0xFF8F)
     55          #define SMCR_MSM_Reset              ((u16)0xFF7F)
     56          #define SMCR_ECE_Set                ((u16)0x4000)
     57          
     58          #define CCMR_CC13S_Mask             ((u16)0xFFFC)
     59          #define CCMR_CC24S_Mask             ((u16)0xFCFF)
     60          #define CCMR_TI13Direct_Set         ((u16)0x0001)
     61          #define CCMR_TI24Direct_Set         ((u16)0x0100)
     62          #define CCMR_OC13FE_Reset           ((u16)0xFFFB)
     63          #define CCMR_OC24FE_Reset           ((u16)0xFBFF)
     64          #define CCMR_OC13PE_Reset           ((u16)0xFFF7)
     65          #define CCMR_OC24PE_Reset           ((u16)0xF7FF)
     66          #define CCMR_OC13M_Mask             ((u16)0xFF8F)
     67          #define CCMR_OC24M_Mask             ((u16)0x8FFF) 
     68          
     69          #define CCMR_OC13CE_Reset           ((u16)0xFF7F)
     70          #define CCMR_OC24CE_Reset           ((u16)0x7FFF)
     71          
     72          #define CCMR_IC13PSC_Mask           ((u16)0xFFF3)
     73          #define CCMR_IC24PSC_Mask           ((u16)0xF3FF)
     74          #define CCMR_IC13F_Mask             ((u16)0xFF0F)
     75          #define CCMR_IC24F_Mask             ((u16)0x0FFF)
     76          
     77          #define CCMR_Offset                 ((u16)0x0018)
     78          #define CCER_CCE_Set                ((u16)0x0001)
     79          #define	CCER_CCNE_Set               ((u16)0x0004)
     80          
     81          #define CCER_CC1P_Reset             ((u16)0xFFFD)
     82          #define CCER_CC2P_Reset             ((u16)0xFFDF)
     83          #define CCER_CC3P_Reset             ((u16)0xFDFF)
     84          #define CCER_CC4P_Reset             ((u16)0xDFFF)
     85          
     86          #define CCER_CC1NP_Reset            ((u16)0xFFF7)
     87          #define CCER_CC2NP_Reset            ((u16)0xFF7F)
     88          #define CCER_CC3NP_Reset            ((u16)0xF7FF)
     89          
     90          #define CCER_CC1E_Set               ((u16)0x0001)
     91          #define CCER_CC1E_Reset             ((u16)0xFFFE)
     92          
     93          #define CCER_CC1NE_Reset            ((u16)0xFFFB)
     94          
     95          #define CCER_CC2E_Set               ((u16)0x0010)
     96          #define CCER_CC2E_Reset             ((u16)0xFFEF)
     97          
     98          #define CCER_CC2NE_Reset            ((u16)0xFFBF)
     99          
    100          #define CCER_CC3E_Set               ((u16)0x0100)
    101          #define CCER_CC3E_Reset             ((u16)0xFEFF)
    102          
    103          #define CCER_CC3NE_Reset            ((u16)0xFBFF)
    104          
    105          #define CCER_CC4E_Set               ((u16)0x1000)
    106          #define CCER_CC4E_Reset             ((u16)0xEFFF)
    107          
    108          #define BDTR_MOE_Set                ((u16)0x8000)
    109          #define BDTR_MOE_Reset              ((u16)0x7FFF)
    110          
    111          /* Private macro -------------------------------------------------------------*/
    112          /* Private variables ---------------------------------------------------------*/
    113          /* Private function prototypes -----------------------------------------------*/
    114          static void TI1_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
    115                                 u16 TIM_ICFilter);
    116          static void TI2_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
    117                                 u16 TIM_ICFilter);
    118          static void TI3_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
    119                                 u16 TIM_ICFilter);
    120          static void TI4_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
    121                                 u16 TIM_ICFilter);
    122          /* Private macro -------------------------------------------------------------*/
    123          /* Private variables ---------------------------------------------------------*/
    124          /* Private function prototypes -----------------------------------------------*/
    125          /* Private functions ---------------------------------------------------------*/
    126          /*******************************************************************************
    127          * Function Name  : TIM_DeInit
    128          * Description    : Deinitializes the TIMx peripheral registers to their default
    129          *                  reset values.
    130          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
    131          * Output         : None
    132          * Return         : None
    133          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    134          void TIM_DeInit(TIM_TypeDef* TIMx)
    135          {
   \                     TIM_DeInit:
   \   00000000   80B5               PUSH     {R7,LR}
    136            /* Check the parameters */
    137            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    138           
    139            switch (*(u32*)&TIMx)
   \   00000002   B0F1804F           CMP      R0,#+1073741824
   \   00000006   20D0               BEQ.N    ??TIM_DeInit_0
   \   00000008   3149               LDR.N    R1,??TIM_DeInit_1  ;; 0x40000400
   \   0000000A   8842               CMP      R0,R1
   \   0000000C   26D0               BEQ.N    ??TIM_DeInit_2
   \   0000000E   3149               LDR.N    R1,??TIM_DeInit_1+0x4  ;; 0x40000800
   \   00000010   8842               CMP      R0,R1
   \   00000012   2CD0               BEQ.N    ??TIM_DeInit_3
   \   00000014   3049               LDR.N    R1,??TIM_DeInit_1+0x8  ;; 0x40000c00
   \   00000016   8842               CMP      R0,R1
   \   00000018   32D0               BEQ.N    ??TIM_DeInit_4
   \   0000001A   3049               LDR.N    R1,??TIM_DeInit_1+0xC  ;; 0x40001000
   \   0000001C   8842               CMP      R0,R1
   \   0000001E   38D0               BEQ.N    ??TIM_DeInit_5
   \   00000020   2F49               LDR.N    R1,??TIM_DeInit_1+0x10  ;; 0x40001400
   \   00000022   8842               CMP      R0,R1
   \   00000024   3ED0               BEQ.N    ??TIM_DeInit_6
   \   00000026   ....               LDR.N    R1,??DataTable10  ;; 0x40012c00
   \   00000028   8842               CMP      R0,R1
   \   0000002A   03D0               BEQ.N    ??TIM_DeInit_7
   \   0000002C   ....               LDR.N    R1,??DataTable11  ;; 0x40013400
   \   0000002E   8842               CMP      R0,R1
   \   00000030   41D0               BEQ.N    ??TIM_DeInit_8
   \   00000032   4BE0               B.N      ??TIM_DeInit_9
    140            {
    141              case TIM1_BASE:
    142                RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
   \                     ??TIM_DeInit_7:
   \   00000034   0121               MOVS     R1,#+1
   \   00000036   4FF40060           MOV      R0,#+2048
   \   0000003A   ........           BL       RCC_APB2PeriphResetCmd
    143                RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
   \   0000003E   0021               MOVS     R1,#+0
   \   00000040   4FF40060           MOV      R0,#+2048
   \   00000044   ........           BL       RCC_APB2PeriphResetCmd
   \   00000048   40E0               B.N      ??TIM_DeInit_10
    144                break; 
    145                
    146              case TIM2_BASE:
    147                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
   \                     ??TIM_DeInit_0:
   \   0000004A   0121               MOVS     R1,#+1
   \   0000004C   0120               MOVS     R0,#+1
   \   0000004E   ........           BL       RCC_APB1PeriphResetCmd
    148                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
   \   00000052   0021               MOVS     R1,#+0
   \   00000054   0120               MOVS     R0,#+1
   \   00000056   ........           BL       RCC_APB1PeriphResetCmd
   \   0000005A   37E0               B.N      ??TIM_DeInit_10
    149                break;
    150           
    151              case TIM3_BASE:
    152                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
   \                     ??TIM_DeInit_2:
   \   0000005C   0121               MOVS     R1,#+1
   \   0000005E   0220               MOVS     R0,#+2
   \   00000060   ........           BL       RCC_APB1PeriphResetCmd
    153                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
   \   00000064   0021               MOVS     R1,#+0
   \   00000066   0220               MOVS     R0,#+2
   \   00000068   ........           BL       RCC_APB1PeriphResetCmd
   \   0000006C   2EE0               B.N      ??TIM_DeInit_10
    154                break;
    155           
    156              case TIM4_BASE:
    157                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
   \                     ??TIM_DeInit_3:
   \   0000006E   0121               MOVS     R1,#+1
   \   00000070   0420               MOVS     R0,#+4
   \   00000072   ........           BL       RCC_APB1PeriphResetCmd
    158                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
   \   00000076   0021               MOVS     R1,#+0
   \   00000078   0420               MOVS     R0,#+4
   \   0000007A   ........           BL       RCC_APB1PeriphResetCmd
   \   0000007E   25E0               B.N      ??TIM_DeInit_10
    159                break;
    160                
    161              case TIM5_BASE:
    162                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
   \                     ??TIM_DeInit_4:
   \   00000080   0121               MOVS     R1,#+1
   \   00000082   0820               MOVS     R0,#+8
   \   00000084   ........           BL       RCC_APB1PeriphResetCmd
    163                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
   \   00000088   0021               MOVS     R1,#+0
   \   0000008A   0820               MOVS     R0,#+8
   \   0000008C   ........           BL       RCC_APB1PeriphResetCmd
   \   00000090   1CE0               B.N      ??TIM_DeInit_10
    164                break;
    165                
    166              case TIM6_BASE:
    167                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
   \                     ??TIM_DeInit_5:
   \   00000092   0121               MOVS     R1,#+1
   \   00000094   1020               MOVS     R0,#+16
   \   00000096   ........           BL       RCC_APB1PeriphResetCmd
    168                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
   \   0000009A   0021               MOVS     R1,#+0
   \   0000009C   1020               MOVS     R0,#+16
   \   0000009E   ........           BL       RCC_APB1PeriphResetCmd
   \   000000A2   13E0               B.N      ??TIM_DeInit_10
    169                break;
    170                
    171              case TIM7_BASE:
    172                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
   \                     ??TIM_DeInit_6:
   \   000000A4   0121               MOVS     R1,#+1
   \   000000A6   2020               MOVS     R0,#+32
   \   000000A8   ........           BL       RCC_APB1PeriphResetCmd
    173                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
   \   000000AC   0021               MOVS     R1,#+0
   \   000000AE   2020               MOVS     R0,#+32
   \   000000B0   ........           BL       RCC_APB1PeriphResetCmd
   \   000000B4   0AE0               B.N      ??TIM_DeInit_10
    174                break;
    175                
    176              case TIM8_BASE:
    177                RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
   \                     ??TIM_DeInit_8:
   \   000000B6   0121               MOVS     R1,#+1
   \   000000B8   4FF40050           MOV      R0,#+8192
   \   000000BC   ........           BL       RCC_APB2PeriphResetCmd
    178                RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
   \   000000C0   0021               MOVS     R1,#+0
   \   000000C2   4FF40050           MOV      R0,#+8192
   \   000000C6   ........           BL       RCC_APB2PeriphResetCmd
   \   000000CA   FFE7               B.N      ??TIM_DeInit_10
    179                break; 
    180                
    181              default:
    182                break;
    183            }
    184          }
   \                     ??TIM_DeInit_9:
   \                     ??TIM_DeInit_10:
   \   000000CC   01BD               POP      {R0,PC}          ;; return
   \   000000CE   00BF               Nop      
   \                     ??TIM_DeInit_1:
   \   000000D0   00040040           DC32     0x40000400
   \   000000D4   00080040           DC32     0x40000800
   \   000000D8   000C0040           DC32     0x40000c00
   \   000000DC   00100040           DC32     0x40001000
   \   000000E0   00140040           DC32     0x40001400
    185          
    186          /*******************************************************************************
    187          * Function Name  : TIM_TimeBaseInit
    188          * Description    : Initializes the TIMx Time Base Unit peripheral according to 
    189          *                  the specified parameters in the TIM_TimeBaseInitStruct.
    190          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
    191          *                    peripheral.
    192          *                  - TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
    193          *                   structure that contains the configuration information for
    194          *                   the specified TIM peripheral.
    195          * Output         : None
    196          * Return         : None
    197          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    198          void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    199          {
   \                     TIM_TimeBaseInit:
   \   00000000   18B4               PUSH     {R3,R4}
    200            /* Check the parameters */
    201            assert_param(IS_TIM_123458_PERIPH(TIMx)); 
    202            assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
    203            assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
    204          
    205            /* Select the Counter Mode and set the clock division */
    206            TIMx->CR1 &= CR1_CKD_Mask & CR1_CounterMode_Mask;
   \   00000002   0288               LDRH     R2,[R0, #+0]
   \   00000004   12F08F02           ANDS     R2,R2,#0x8F
   \   00000008   0280               STRH     R2,[R0, #+0]
    207            TIMx->CR1 |= (u32)TIM_TimeBaseInitStruct->TIM_ClockDivision |
    208                          TIM_TimeBaseInitStruct->TIM_CounterMode;
   \   0000000A   0288               LDRH     R2,[R0, #+0]
   \   0000000C   CB88               LDRH     R3,[R1, #+6]
   \   0000000E   4C88               LDRH     R4,[R1, #+2]
   \   00000010   2343               ORRS     R3,R4,R3
   \   00000012   1A43               ORRS     R2,R3,R2
   \   00000014   0280               STRH     R2,[R0, #+0]
    209            /* Set the Autoreload value */
    210            TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
   \   00000016   8A88               LDRH     R2,[R1, #+4]
   \   00000018   8285               STRH     R2,[R0, #+44]
    211          
    212            /* Set the Prescaler value */
    213            TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
   \   0000001A   0A88               LDRH     R2,[R1, #+0]
   \   0000001C   0285               STRH     R2,[R0, #+40]
    214          
    215            /* Generate an update event to reload the Prescaler value immediatly */
    216            TIMx->EGR = TIM_PSCReloadMode_Immediate;
   \   0000001E   0122               MOVS     R2,#+1
   \   00000020   8282               STRH     R2,[R0, #+20]
    217              
    218            if (((*(u32*)&TIMx) == TIM1_BASE) || ((*(u32*)&TIMx) == TIM8_BASE))  
   \   00000022   ....               LDR.N    R2,??DataTable10  ;; 0x40012c00
   \   00000024   9042               CMP      R0,R2
   \   00000026   02D0               BEQ.N    ??TIM_TimeBaseInit_0
   \   00000028   ....               LDR.N    R2,??DataTable11  ;; 0x40013400
   \   0000002A   9042               CMP      R0,R2
   \   0000002C   01D1               BNE.N    ??TIM_TimeBaseInit_1
    219            {
    220              /* Set the Repetition Counter value */
    221              TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
   \                     ??TIM_TimeBaseInit_0:
   \   0000002E   097A               LDRB     R1,[R1, #+8]
   \   00000030   0186               STRH     R1,[R0, #+48]
    222            }        
    223          }
   \                     ??TIM_TimeBaseInit_1:
   \   00000032   11BC               POP      {R0,R4}
   \   00000034   7047               BX       LR               ;; return
    224          
    225          /*******************************************************************************
    226          * Function Name  : TIM_OC1Init
    227          * Description    : Initializes the TIMx Channel1 according to the specified
    228          *                  parameters in the TIM_OCInitStruct.
    229          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
    230          *                    peripheral.
    231          *                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    232          *                    that contains the configuration information for the specified
    233          *                    TIM peripheral.
    234          * Output         : None
    235          * Return         : None
    236          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    237          void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    238          {
   \                     TIM_OC1Init:
   \   00000000   30B4               PUSH     {R4,R5}
    239            u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   0024               MOVS     R4,#+0
   \   00000006   0022               MOVS     R2,#+0
    240             
    241            /* Check the parameters */
    242            assert_param(IS_TIM_123458_PERIPH(TIMx)); 
    243            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    244            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    245            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    246          
    247            /* Disable the Channel 1: Reset the CC1E Bit */
    248            TIMx->CCER &= CCER_CC1E_Reset;
   \   00000008   058C               LDRH     R5,[R0, #+32]
   \   0000000A   35F00105           BICS     R5,R5,#0x1
   \   0000000E   0584               STRH     R5,[R0, #+32]
    249            
    250            /* Get the TIMx CCER register value */
    251            tmpccer = TIMx->CCER;
   \   00000010   058C               LDRH     R5,[R0, #+32]
   \   00000012   2C00               MOVS     R4,R5
    252          
    253            /* Get the TIMx CR2 register value */
    254            tmpcr2 =  TIMx->CR2;
   \   00000014   8588               LDRH     R5,[R0, #+4]
   \   00000016   2A00               MOVS     R2,R5
    255            
    256            /* Get the TIMx CCMR1 register value */
    257            tmpccmrx = TIMx->CCMR1;
   \   00000018   058B               LDRH     R5,[R0, #+24]
   \   0000001A   2B00               MOVS     R3,R5
    258              
    259            /* Reset the Output Compare Mode Bits */
    260            tmpccmrx &= CCMR_OC13M_Mask;
   \   0000001C   4FF68F75           MOVW     R5,#+65423
   \   00000020   2B40               ANDS     R3,R5,R3
    261            
    262            /* Select the Output Compare Mode */
    263            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
   \   00000022   0D88               LDRH     R5,[R1, #+0]
   \   00000024   2B43               ORRS     R3,R5,R3
    264            
    265            /* Reset the Output Polarity level */
    266            tmpccer &= CCER_CC1P_Reset;
   \   00000026   4FF6FD75           MOVW     R5,#+65533
   \   0000002A   2C40               ANDS     R4,R5,R4
    267          
    268            /* Set the Output Compare Polarity */
    269            tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
   \   0000002C   0D89               LDRH     R5,[R1, #+8]
   \   0000002E   2C43               ORRS     R4,R5,R4
    270            
    271            /* Set the Output State */
    272            tmpccer |= TIM_OCInitStruct->TIM_OutputState;
   \   00000030   4D88               LDRH     R5,[R1, #+2]
   \   00000032   2C43               ORRS     R4,R5,R4
    273            
    274            /* Set the Capture Compare Register value */
    275            TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
   \   00000034   CD88               LDRH     R5,[R1, #+6]
   \   00000036   8586               STRH     R5,[R0, #+52]
    276            
    277            if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
   \   00000038   ....               LDR.N    R5,??DataTable10  ;; 0x40012c00
   \   0000003A   A842               CMP      R0,R5
   \   0000003C   02D0               BEQ.N    ??TIM_OC1Init_0
   \   0000003E   ....               LDR.N    R5,??DataTable11  ;; 0x40013400
   \   00000040   A842               CMP      R0,R5
   \   00000042   13D1               BNE.N    ??TIM_OC1Init_1
    278            {
    279              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    280              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    281              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    282              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    283              
    284              /* Reset the Output N Polarity level */
    285              tmpccer &= CCER_CC1NP_Reset;
   \                     ??TIM_OC1Init_0:
   \   00000044   4FF6F775           MOVW     R5,#+65527
   \   00000048   2C40               ANDS     R4,R5,R4
    286          
    287              /* Set the Output N Polarity */
    288              tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
   \   0000004A   4D89               LDRH     R5,[R1, #+10]
   \   0000004C   2C43               ORRS     R4,R5,R4
    289          
    290              /* Reset the Output N State */
    291              tmpccer &= CCER_CC1NE_Reset;
   \   0000004E   4FF6FB75           MOVW     R5,#+65531
   \   00000052   2C40               ANDS     R4,R5,R4
    292              
    293              /* Set the Output N State */
    294              tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
   \   00000054   8D88               LDRH     R5,[R1, #+4]
   \   00000056   2C43               ORRS     R4,R5,R4
    295          
    296              /* Reset the Ouput Compare and Output Compare N IDLE State */
    297              tmpcr2 &= CR2_OIS1_Reset;
   \   00000058   47F6FF65           MOVW     R5,#+32511
   \   0000005C   2A40               ANDS     R2,R5,R2
    298              tmpcr2 &= CR2_OIS1N_Reset;
   \   0000005E   47F6FF55           MOVW     R5,#+32255
   \   00000062   2A40               ANDS     R2,R5,R2
    299          
    300              /* Set the Output Idle state */
    301              tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
   \   00000064   8D89               LDRH     R5,[R1, #+12]
   \   00000066   2A43               ORRS     R2,R5,R2
    302          
    303              /* Set the Output N Idle state */
    304              tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
   \   00000068   C989               LDRH     R1,[R1, #+14]
   \   0000006A   0A43               ORRS     R2,R1,R2
    305            }
    306            /* Write to TIMx CR2 */
    307            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC1Init_1:
   \   0000006C   8280               STRH     R2,[R0, #+4]
    308            
    309            /* Write to TIMx CCMR1 */
    310            TIMx->CCMR1 = tmpccmrx;
   \   0000006E   0383               STRH     R3,[R0, #+24]
    311            
    312            /* Write to TIMx CCER */
    313            TIMx->CCER = tmpccer;
   \   00000070   0484               STRH     R4,[R0, #+32]
    314          }
   \   00000072   30BC               POP      {R4,R5}
   \   00000074   7047               BX       LR               ;; return
    315          
    316          /*******************************************************************************
    317          * Function Name  : TIM_OC2Init
    318          * Description    : Initializes the TIMx Channel2 according to the specified
    319          *                  parameters in the TIM_OCInitStruct.
    320          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
    321          *                    peripheral.
    322          *                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    323          *                    that contains the configuration information for the specified
    324          *                    TIM peripheral.
    325          * Output         : None
    326          * Return         : None
    327          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    328          void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    329          {
   \                     TIM_OC2Init:
   \   00000000   30B4               PUSH     {R4,R5}
    330            u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   0024               MOVS     R4,#+0
   \   00000006   0022               MOVS     R2,#+0
    331             
    332            /* Check the parameters */
    333            assert_param(IS_TIM_123458_PERIPH(TIMx)); 
    334            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    335            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    336            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    337          
    338            /* Disable the Channel 2: Reset the CC2E Bit */
    339            TIMx->CCER &= CCER_CC2E_Reset;
   \   00000008   058C               LDRH     R5,[R0, #+32]
   \   0000000A   35F01005           BICS     R5,R5,#0x10
   \   0000000E   0584               STRH     R5,[R0, #+32]
    340            
    341            /* Get the TIMx CCER register value */  
    342            tmpccer = TIMx->CCER;
   \   00000010   058C               LDRH     R5,[R0, #+32]
   \   00000012   2C00               MOVS     R4,R5
    343          
    344            /* Get the TIMx CR2 register value */
    345            tmpcr2 =  TIMx->CR2;
   \   00000014   8588               LDRH     R5,[R0, #+4]
   \   00000016   2A00               MOVS     R2,R5
    346            
    347            /* Get the TIMx CCMR1 register value */
    348            tmpccmrx = TIMx->CCMR1;
   \   00000018   058B               LDRH     R5,[R0, #+24]
   \   0000001A   2B00               MOVS     R3,R5
    349              
    350            /* Reset the Output Compare Mode Bits */
    351            tmpccmrx &= CCMR_OC24M_Mask;
   \   0000001C   48F6FF75           MOVW     R5,#+36863
   \   00000020   2B40               ANDS     R3,R5,R3
    352            
    353            /* Select the Output Compare Mode */
    354            tmpccmrx |= (u16)(TIM_OCInitStruct->TIM_OCMode << 8);
   \   00000022   0D88               LDRH     R5,[R1, #+0]
   \   00000024   53EA0523           ORRS     R3,R3,R5, LSL #+8
    355            
    356            /* Reset the Output Polarity level */
    357            tmpccer &= CCER_CC2P_Reset;
   \   00000028   4FF6DF75           MOVW     R5,#+65503
   \   0000002C   2C40               ANDS     R4,R5,R4
    358          
    359            /* Set the Output Compare Polarity */
    360            tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCPolarity << 4);
   \   0000002E   0D89               LDRH     R5,[R1, #+8]
   \   00000030   54EA0514           ORRS     R4,R4,R5, LSL #+4
    361            
    362            /* Set the Output State */
    363            tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputState << 4);
   \   00000034   4D88               LDRH     R5,[R1, #+2]
   \   00000036   54EA0514           ORRS     R4,R4,R5, LSL #+4
    364            
    365            /* Set the Capture Compare Register value */
    366            TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
   \   0000003A   CD88               LDRH     R5,[R1, #+6]
   \   0000003C   0587               STRH     R5,[R0, #+56]
    367            
    368            if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
   \   0000003E   ....               LDR.N    R5,??DataTable10  ;; 0x40012c00
   \   00000040   A842               CMP      R0,R5
   \   00000042   02D0               BEQ.N    ??TIM_OC2Init_0
   \   00000044   ....               LDR.N    R5,??DataTable11  ;; 0x40013400
   \   00000046   A842               CMP      R0,R5
   \   00000048   17D1               BNE.N    ??TIM_OC2Init_1
    369            {
    370              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    371              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    372              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    373              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    374              
    375              /* Reset the Output N Polarity level */
    376              tmpccer &= CCER_CC2NP_Reset;
   \                     ??TIM_OC2Init_0:
   \   0000004A   4FF67F75           MOVW     R5,#+65407
   \   0000004E   2C40               ANDS     R4,R5,R4
    377          
    378              /* Set the Output N Polarity */
    379              tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
   \   00000050   4D89               LDRH     R5,[R1, #+10]
   \   00000052   54EA0514           ORRS     R4,R4,R5, LSL #+4
    380          
    381              /* Reset the Output N State */
    382              tmpccer &= CCER_CC2NE_Reset;
   \   00000056   4FF6BF75           MOVW     R5,#+65471
   \   0000005A   2C40               ANDS     R4,R5,R4
    383              
    384              /* Set the Output N State */
    385              tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputNState << 4);
   \   0000005C   8D88               LDRH     R5,[R1, #+4]
   \   0000005E   54EA0514           ORRS     R4,R4,R5, LSL #+4
    386          
    387              /* Reset the Ouput Compare and Output Compare N IDLE State */
    388              tmpcr2 &= CR2_OIS2_Reset;
   \   00000062   47F6FF35           MOVW     R5,#+31743
   \   00000066   2A40               ANDS     R2,R5,R2
    389              tmpcr2 &= CR2_OIS2N_Reset;
   \   00000068   47F2FF75           MOVW     R5,#+30719
   \   0000006C   2A40               ANDS     R2,R5,R2
    390          
    391              /* Set the Output Idle state */
    392              tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCIdleState << 2);
   \   0000006E   8D89               LDRH     R5,[R1, #+12]
   \   00000070   52EA8502           ORRS     R2,R2,R5, LSL #+2
    393          
    394              /* Set the Output N Idle state */
    395              tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
   \   00000074   C989               LDRH     R1,[R1, #+14]
   \   00000076   52EA8102           ORRS     R2,R2,R1, LSL #+2
    396            }
    397          
    398            /* Write to TIMx CR2 */
    399            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC2Init_1:
   \   0000007A   8280               STRH     R2,[R0, #+4]
    400            
    401            /* Write to TIMx CCMR1 */
    402            TIMx->CCMR1 = tmpccmrx;
   \   0000007C   0383               STRH     R3,[R0, #+24]
    403            
    404            /* Write to TIMx CCER */
    405            TIMx->CCER = tmpccer;
   \   0000007E   0484               STRH     R4,[R0, #+32]
    406          }
   \   00000080   30BC               POP      {R4,R5}
   \   00000082   7047               BX       LR               ;; return
    407          
    408          /*******************************************************************************
    409          * Function Name  : TIM_OC3Init
    410          * Description    : Initializes the TIMx Channel3 according to the specified
    411          *                  parameters in the TIM_OCInitStruct.
    412          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
    413          *                    peripheral.
    414          *                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    415          *                    that contains the configuration information for the specified
    416          *                    TIM peripheral.
    417          * Output         : None
    418          * Return         : None
    419          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    420          void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    421          {
   \                     TIM_OC3Init:
   \   00000000   30B4               PUSH     {R4,R5}
    422            u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   0024               MOVS     R4,#+0
   \   00000006   0022               MOVS     R2,#+0
    423             
    424            /* Check the parameters */
    425            assert_param(IS_TIM_123458_PERIPH(TIMx)); 
    426            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    427            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    428            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    429          
    430            /* Disable the Channel 2: Reset the CC2E Bit */
    431            TIMx->CCER &= CCER_CC3E_Reset;
   \   00000008   058C               LDRH     R5,[R0, #+32]
   \   0000000A   35F48075           BICS     R5,R5,#0x100
   \   0000000E   0584               STRH     R5,[R0, #+32]
    432            
    433            /* Get the TIMx CCER register value */
    434            tmpccer = TIMx->CCER;
   \   00000010   058C               LDRH     R5,[R0, #+32]
   \   00000012   2C00               MOVS     R4,R5
    435          
    436            /* Get the TIMx CR2 register value */
    437            tmpcr2 =  TIMx->CR2;
   \   00000014   8588               LDRH     R5,[R0, #+4]
   \   00000016   2A00               MOVS     R2,R5
    438            
    439            /* Get the TIMx CCMR2 register value */
    440            tmpccmrx = TIMx->CCMR2;
   \   00000018   858B               LDRH     R5,[R0, #+28]
   \   0000001A   2B00               MOVS     R3,R5
    441              
    442            /* Reset the Output Compare Mode Bits */
    443            tmpccmrx &= CCMR_OC13M_Mask;
   \   0000001C   4FF68F75           MOVW     R5,#+65423
   \   00000020   2B40               ANDS     R3,R5,R3
    444            
    445            /* Select the Output Compare Mode */
    446            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
   \   00000022   0D88               LDRH     R5,[R1, #+0]
   \   00000024   2B43               ORRS     R3,R5,R3
    447            
    448            /* Reset the Output Polarity level */
    449            tmpccer &= CCER_CC3P_Reset;
   \   00000026   4FF6FF55           MOVW     R5,#+65023
   \   0000002A   2C40               ANDS     R4,R5,R4
    450          
    451            /* Set the Output Compare Polarity */
    452            tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCPolarity << 8);
   \   0000002C   0D89               LDRH     R5,[R1, #+8]
   \   0000002E   54EA0524           ORRS     R4,R4,R5, LSL #+8
    453            
    454            /* Set the Output State */
    455            tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputState << 8);
   \   00000032   4D88               LDRH     R5,[R1, #+2]
   \   00000034   54EA0524           ORRS     R4,R4,R5, LSL #+8
    456            
    457            /* Set the Capture Compare Register value */
    458            TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
   \   00000038   CD88               LDRH     R5,[R1, #+6]
   \   0000003A   8587               STRH     R5,[R0, #+60]
    459            
    460            if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
   \   0000003C   ....               LDR.N    R5,??DataTable10  ;; 0x40012c00
   \   0000003E   A842               CMP      R0,R5
   \   00000040   02D0               BEQ.N    ??TIM_OC3Init_0
   \   00000042   ....               LDR.N    R5,??DataTable11  ;; 0x40013400
   \   00000044   A842               CMP      R0,R5
   \   00000046   17D1               BNE.N    ??TIM_OC3Init_1
    461            {
    462              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    463              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    464              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    465              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    466              
    467              /* Reset the Output N Polarity level */
    468              tmpccer &= CCER_CC3NP_Reset;
   \                     ??TIM_OC3Init_0:
   \   00000048   4FF2FF75           MOVW     R5,#+63487
   \   0000004C   2C40               ANDS     R4,R5,R4
    469          
    470              /* Set the Output N Polarity */
    471              tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
   \   0000004E   4D89               LDRH     R5,[R1, #+10]
   \   00000050   54EA0524           ORRS     R4,R4,R5, LSL #+8
    472          
    473              /* Reset the Output N State */
    474              tmpccer &= CCER_CC3NE_Reset;
   \   00000054   4FF6FF35           MOVW     R5,#+64511
   \   00000058   2C40               ANDS     R4,R5,R4
    475              
    476              /* Set the Output N State */
    477              tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputNState << 8);
   \   0000005A   8D88               LDRH     R5,[R1, #+4]
   \   0000005C   54EA0524           ORRS     R4,R4,R5, LSL #+8
    478          
    479              /* Reset the Ouput Compare and Output Compare N IDLE State */
    480              tmpcr2 &= CR2_OIS3_Reset;
   \   00000060   46F6FF75           MOVW     R5,#+28671
   \   00000064   2A40               ANDS     R2,R5,R2
    481              tmpcr2 &= CR2_OIS3N_Reset;
   \   00000066   45F6FF75           MOVW     R5,#+24575
   \   0000006A   2A40               ANDS     R2,R5,R2
    482          
    483              /* Set the Output Idle state */
    484              tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCIdleState << 4);
   \   0000006C   8D89               LDRH     R5,[R1, #+12]
   \   0000006E   52EA0512           ORRS     R2,R2,R5, LSL #+4
    485          
    486              /* Set the Output N Idle state */
    487              tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
   \   00000072   C989               LDRH     R1,[R1, #+14]
   \   00000074   52EA0112           ORRS     R2,R2,R1, LSL #+4
    488            }
    489          
    490            /* Write to TIMx CR2 */
    491            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC3Init_1:
   \   00000078   8280               STRH     R2,[R0, #+4]
    492            
    493            /* Write to TIMx CCMR2 */
    494            TIMx->CCMR2 = tmpccmrx;
   \   0000007A   8383               STRH     R3,[R0, #+28]
    495            
    496            /* Write to TIMx CCER */
    497            TIMx->CCER = tmpccer;
   \   0000007C   0484               STRH     R4,[R0, #+32]
    498          }
   \   0000007E   30BC               POP      {R4,R5}
   \   00000080   7047               BX       LR               ;; return
    499          
    500          /*******************************************************************************
    501          * Function Name  : TIM_OC4Init
    502          * Description    : Initializes the TIMx Channel4 according to the specified
    503          *                  parameters in the TIM_OCInitStruct.
    504          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
    505          *                    peripheral.
    506          *                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    507          *                    that contains the configuration information for the specified
    508          *                    TIM peripheral.
    509          * Output         : None
    510          * Return         : None
    511          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    512          void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    513          {
   \                     TIM_OC4Init:
   \   00000000   30B4               PUSH     {R4,R5}
    514            u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   0024               MOVS     R4,#+0
   \   00000006   0022               MOVS     R2,#+0
    515             
    516            /* Check the parameters */
    517            assert_param(IS_TIM_123458_PERIPH(TIMx)); 
    518            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    519            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    520            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    521          
    522            /* Disable the Channel 2: Reset the CC4E Bit */
    523            TIMx->CCER &= CCER_CC4E_Reset;
   \   00000008   058C               LDRH     R5,[R0, #+32]
   \   0000000A   35F48055           BICS     R5,R5,#0x1000
   \   0000000E   0584               STRH     R5,[R0, #+32]
    524            
    525            /* Get the TIMx CCER register value */
    526            tmpccer = TIMx->CCER;
   \   00000010   058C               LDRH     R5,[R0, #+32]
   \   00000012   2C00               MOVS     R4,R5
    527          
    528            /* Get the TIMx CR2 register value */
    529            tmpcr2 =  TIMx->CR2;
   \   00000014   8588               LDRH     R5,[R0, #+4]
   \   00000016   2A00               MOVS     R2,R5
    530            
    531            /* Get the TIMx CCMR2 register value */
    532            tmpccmrx = TIMx->CCMR2;
   \   00000018   858B               LDRH     R5,[R0, #+28]
   \   0000001A   2B00               MOVS     R3,R5
    533              
    534            /* Reset the Output Compare Mode Bits */
    535            tmpccmrx &= CCMR_OC24M_Mask;
   \   0000001C   48F6FF75           MOVW     R5,#+36863
   \   00000020   2B40               ANDS     R3,R5,R3
    536            
    537            /* Select the Output Compare Mode */
    538            tmpccmrx |= (u16)(TIM_OCInitStruct->TIM_OCMode << 8);
   \   00000022   0D88               LDRH     R5,[R1, #+0]
   \   00000024   53EA0523           ORRS     R3,R3,R5, LSL #+8
    539            
    540            /* Reset the Output Polarity level */
    541            tmpccer &= CCER_CC4P_Reset;
   \   00000028   4DF6FF75           MOVW     R5,#+57343
   \   0000002C   2C40               ANDS     R4,R5,R4
    542          
    543            /* Set the Output Compare Polarity */
    544            tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCPolarity << 12);
   \   0000002E   0D89               LDRH     R5,[R1, #+8]
   \   00000030   54EA0534           ORRS     R4,R4,R5, LSL #+12
    545            
    546            /* Set the Output State */
    547            tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputState << 12);
   \   00000034   4D88               LDRH     R5,[R1, #+2]
   \   00000036   54EA0534           ORRS     R4,R4,R5, LSL #+12
    548            
    549            /* Set the Capture Compare Register value */
    550            TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
   \   0000003A   CD88               LDRH     R5,[R1, #+6]
   \   0000003C   A0F84050           STRH     R5,[R0, #+64]
    551            
    552            if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
   \   00000040   ....               LDR.N    R5,??DataTable10  ;; 0x40012c00
   \   00000042   A842               CMP      R0,R5
   \   00000044   02D0               BEQ.N    ??TIM_OC4Init_0
   \   00000046   ....               LDR.N    R5,??DataTable11  ;; 0x40013400
   \   00000048   A842               CMP      R0,R5
   \   0000004A   04D1               BNE.N    ??TIM_OC4Init_1
    553            {
    554              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    555          
    556              /* Reset the Ouput Compare IDLE State */
    557              tmpcr2 &= CR2_OIS4_Reset;
   \                     ??TIM_OC4Init_0:
   \   0000004C   9204               LSLS     R2,R2,#+18
   \   0000004E   920C               LSRS     R2,R2,#+18
    558          
    559              /* Set the Output Idle state */
    560              tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCIdleState << 6);
   \   00000050   8989               LDRH     R1,[R1, #+12]
   \   00000052   52EA8112           ORRS     R2,R2,R1, LSL #+6
    561            }
    562          
    563            /* Write to TIMx CR2 */
    564            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC4Init_1:
   \   00000056   8280               STRH     R2,[R0, #+4]
    565            
    566            /* Write to TIMx CCMR2 */  
    567            TIMx->CCMR2 = tmpccmrx;
   \   00000058   8383               STRH     R3,[R0, #+28]
    568            
    569            /* Write to TIMx CCER */
    570            TIMx->CCER = tmpccer;
   \   0000005A   0484               STRH     R4,[R0, #+32]
    571          }
   \   0000005C   30BC               POP      {R4,R5}
   \   0000005E   7047               BX       LR               ;; return
    572          
    573          /*******************************************************************************
    574          * Function Name  : TIM_ICInit
    575          * Description    : Initializes the TIM peripheral according to the specified
    576          *                  parameters in the TIM_ICInitStruct.
    577          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
    578          *                    peripheral.
    579          *                  - TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
    580          *                    that contains the configuration information for the specified
    581          *                    TIM peripheral.
    582          * Output         : None
    583          * Return         : None
    584          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    585          void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
    586          {
   \                     TIM_ICInit:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    587            /* Check the parameters */
    588            assert_param(IS_TIM_123458_PERIPH(TIMx));
    589            assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));
    590            assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
    591            assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
    592            assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
    593            assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
    594            
    595            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   \   00000006   2888               LDRH     R0,[R5, #+0]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   0AD1               BNE.N    ??TIM_ICInit_0
    596            {
    597              /* TI1 Configuration */
    598              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    599                         TIM_ICInitStruct->TIM_ICSelection,
    600                         TIM_ICInitStruct->TIM_ICFilter);
   \   0000000C   2B89               LDRH     R3,[R5, #+8]
   \   0000000E   AA88               LDRH     R2,[R5, #+4]
   \   00000010   6988               LDRH     R1,[R5, #+2]
   \   00000012   2000               MOVS     R0,R4
   \   00000014   ........           BL       TI1_Config
    601          
    602              /* Set the Input Capture Prescaler value */
    603              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000018   E988               LDRH     R1,[R5, #+6]
   \   0000001A   2000               MOVS     R0,R4
   \   0000001C   ........           BL       TIM_SetIC1Prescaler
   \   00000020   25E0               B.N      ??TIM_ICInit_1
    604            }
    605            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
   \                     ??TIM_ICInit_0:
   \   00000022   2888               LDRH     R0,[R5, #+0]
   \   00000024   0428               CMP      R0,#+4
   \   00000026   0AD1               BNE.N    ??TIM_ICInit_2
    606            {
    607              /* TI2 Configuration */
    608              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    609                         TIM_ICInitStruct->TIM_ICSelection,
    610                         TIM_ICInitStruct->TIM_ICFilter);
   \   00000028   2B89               LDRH     R3,[R5, #+8]
   \   0000002A   AA88               LDRH     R2,[R5, #+4]
   \   0000002C   6988               LDRH     R1,[R5, #+2]
   \   0000002E   2000               MOVS     R0,R4
   \   00000030   ........           BL       TI2_Config
    611          
    612              /* Set the Input Capture Prescaler value */
    613              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000034   E988               LDRH     R1,[R5, #+6]
   \   00000036   2000               MOVS     R0,R4
   \   00000038   ........           BL       TIM_SetIC2Prescaler
   \   0000003C   17E0               B.N      ??TIM_ICInit_3
    614            }
    615            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
   \                     ??TIM_ICInit_2:
   \   0000003E   2888               LDRH     R0,[R5, #+0]
   \   00000040   0828               CMP      R0,#+8
   \   00000042   0AD1               BNE.N    ??TIM_ICInit_4
    616            {
    617              /* TI3 Configuration */
    618              TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
    619                         TIM_ICInitStruct->TIM_ICSelection,
    620                         TIM_ICInitStruct->TIM_ICFilter);
   \   00000044   2B89               LDRH     R3,[R5, #+8]
   \   00000046   AA88               LDRH     R2,[R5, #+4]
   \   00000048   6988               LDRH     R1,[R5, #+2]
   \   0000004A   2000               MOVS     R0,R4
   \   0000004C   ........           BL       TI3_Config
    621          
    622              /* Set the Input Capture Prescaler value */
    623              TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000050   E988               LDRH     R1,[R5, #+6]
   \   00000052   2000               MOVS     R0,R4
   \   00000054   ........           BL       TIM_SetIC3Prescaler
   \   00000058   09E0               B.N      ??TIM_ICInit_5
    624            }
    625            else
    626            {
    627              /* TI4 Configuration */
    628              TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    629                         TIM_ICInitStruct->TIM_ICSelection,
    630                         TIM_ICInitStruct->TIM_ICFilter);
   \                     ??TIM_ICInit_4:
   \   0000005A   2B89               LDRH     R3,[R5, #+8]
   \   0000005C   AA88               LDRH     R2,[R5, #+4]
   \   0000005E   6988               LDRH     R1,[R5, #+2]
   \   00000060   2000               MOVS     R0,R4
   \   00000062   ........           BL       TI4_Config
    631          
    632              /* Set the Input Capture Prescaler value */
    633              TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000066   E988               LDRH     R1,[R5, #+6]
   \   00000068   2000               MOVS     R0,R4
   \   0000006A   ........           BL       TIM_SetIC4Prescaler
    634            }
    635          }
   \                     ??TIM_ICInit_5:
   \                     ??TIM_ICInit_3:
   \                     ??TIM_ICInit_1:
   \   0000006E   31BD               POP      {R0,R4,R5,PC}    ;; return
    636          
    637          /*******************************************************************************
    638          * Function Name  : TIM_PWMIConfig
    639          * Description    : Configures the TIM peripheral according to the specified
    640          *                  parameters in the TIM_ICInitStruct to measure an external PWM
    641          *                  signal.
    642          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
    643          *                    peripheral.
    644          *                  - TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
    645          *                    that contains the configuration information for the specified
    646          *                    TIM peripheral.
    647          * Output         : None
    648          * Return         : None
    649          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    650          void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
    651          {
   \                     TIM_PWMIConfig:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    652            u16 icoppositepolarity = TIM_ICPolarity_Rising;
   \   00000006   0026               MOVS     R6,#+0
    653            u16 icoppositeselection = TIM_ICSelection_DirectTI;
   \   00000008   0127               MOVS     R7,#+1
    654          
    655            /* Check the parameters */
    656            assert_param(IS_TIM_123458_PERIPH(TIMx));
    657          
    658            /* Select the Opposite Input Polarity */
    659            if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
   \   0000000A   6888               LDRH     R0,[R5, #+2]
   \   0000000C   0028               CMP      R0,#+0
   \   0000000E   01D1               BNE.N    ??TIM_PWMIConfig_0
    660            {
    661              icoppositepolarity = TIM_ICPolarity_Falling;
   \   00000010   0226               MOVS     R6,#+2
   \   00000012   00E0               B.N      ??TIM_PWMIConfig_1
    662            }
    663            else
    664            {
    665              icoppositepolarity = TIM_ICPolarity_Rising;
   \                     ??TIM_PWMIConfig_0:
   \   00000014   0026               MOVS     R6,#+0
    666            }
    667          
    668            /* Select the Opposite Input */
    669            if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
   \                     ??TIM_PWMIConfig_1:
   \   00000016   A888               LDRH     R0,[R5, #+4]
   \   00000018   0128               CMP      R0,#+1
   \   0000001A   01D1               BNE.N    ??TIM_PWMIConfig_2
    670            {
    671              icoppositeselection = TIM_ICSelection_IndirectTI;
   \   0000001C   0227               MOVS     R7,#+2
   \   0000001E   00E0               B.N      ??TIM_PWMIConfig_3
    672            }
    673            else
    674            {
    675              icoppositeselection = TIM_ICSelection_DirectTI;
   \                     ??TIM_PWMIConfig_2:
   \   00000020   0127               MOVS     R7,#+1
    676            }
    677          
    678            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   \                     ??TIM_PWMIConfig_3:
   \   00000022   2888               LDRH     R0,[R5, #+0]
   \   00000024   0028               CMP      R0,#+0
   \   00000026   16D1               BNE.N    ??TIM_PWMIConfig_4
    679            {
    680              /* TI1 Configuration */
    681              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
    682                         TIM_ICInitStruct->TIM_ICFilter);
   \   00000028   2B89               LDRH     R3,[R5, #+8]
   \   0000002A   AA88               LDRH     R2,[R5, #+4]
   \   0000002C   6988               LDRH     R1,[R5, #+2]
   \   0000002E   2000               MOVS     R0,R4
   \   00000030   ........           BL       TI1_Config
    683          
    684              /* Set the Input Capture Prescaler value */
    685              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000034   E988               LDRH     R1,[R5, #+6]
   \   00000036   2000               MOVS     R0,R4
   \   00000038   ........           BL       TIM_SetIC1Prescaler
    686          
    687              /* TI2 Configuration */
    688              TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   \   0000003C   2B89               LDRH     R3,[R5, #+8]
   \   0000003E   3A00               MOVS     R2,R7
   \   00000040   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000042   3100               MOVS     R1,R6
   \   00000044   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000046   2000               MOVS     R0,R4
   \   00000048   ........           BL       TI2_Config
    689          
    690              /* Set the Input Capture Prescaler value */
    691              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   0000004C   E988               LDRH     R1,[R5, #+6]
   \   0000004E   2000               MOVS     R0,R4
   \   00000050   ........           BL       TIM_SetIC2Prescaler
   \   00000054   15E0               B.N      ??TIM_PWMIConfig_5
    692            }
    693            else
    694            { 
    695              /* TI2 Configuration */
    696              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
    697                         TIM_ICInitStruct->TIM_ICFilter);
   \                     ??TIM_PWMIConfig_4:
   \   00000056   2B89               LDRH     R3,[R5, #+8]
   \   00000058   AA88               LDRH     R2,[R5, #+4]
   \   0000005A   6988               LDRH     R1,[R5, #+2]
   \   0000005C   2000               MOVS     R0,R4
   \   0000005E   ........           BL       TI2_Config
    698          
    699              /* Set the Input Capture Prescaler value */
    700              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000062   E988               LDRH     R1,[R5, #+6]
   \   00000064   2000               MOVS     R0,R4
   \   00000066   ........           BL       TIM_SetIC2Prescaler
    701          
    702              /* TI1 Configuration */
    703              TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   \   0000006A   2B89               LDRH     R3,[R5, #+8]
   \   0000006C   3A00               MOVS     R2,R7
   \   0000006E   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000070   3100               MOVS     R1,R6
   \   00000072   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000074   2000               MOVS     R0,R4
   \   00000076   ........           BL       TI1_Config
    704          
    705              /* Set the Input Capture Prescaler value */
    706              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   0000007A   E988               LDRH     R1,[R5, #+6]
   \   0000007C   2000               MOVS     R0,R4
   \   0000007E   ........           BL       TIM_SetIC1Prescaler
    707            }
    708          }
   \                     ??TIM_PWMIConfig_5:
   \   00000082   F1BD               POP      {R0,R4-R7,PC}    ;; return
    709          
    710          /*******************************************************************************
    711          * Function Name  : TIM_BDTRConfig
    712          * Description    : Configures the: Break feature, dead time, Lock level, the OSSI,
    713          *                  the OSSR State and the AOE(automatic output enable).
    714          * Input          :- TIMx: where x can be  1 or 8 to select the TIM 
    715          *                 - TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef
    716          *                    structure that contains the BDTR Register configuration
    717          *                    information for the TIM peripheral.
    718          * Output         : None
    719          * Return         : None
    720          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    721          void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
    722          {
    723            /* Check the parameters */
    724            assert_param(IS_TIM_18_PERIPH(TIMx));
    725            assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
    726            assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
    727            assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
    728            assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
    729            assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
    730            assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
    731          
    732            /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
    733               the OSSI State, the dead time value and the Automatic Output Enable Bit */
    734          
    735            TIMx->BDTR = (u32)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
    736                       TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
    737                       TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
    738                       TIM_BDTRInitStruct->TIM_AutomaticOutput;
   \                     TIM_BDTRConfig:
   \   00000000   0A88               LDRH     R2,[R1, #+0]
   \   00000002   4B88               LDRH     R3,[R1, #+2]
   \   00000004   1A43               ORRS     R2,R3,R2
   \   00000006   8B88               LDRH     R3,[R1, #+4]
   \   00000008   1A43               ORRS     R2,R3,R2
   \   0000000A   CB88               LDRH     R3,[R1, #+6]
   \   0000000C   1A43               ORRS     R2,R3,R2
   \   0000000E   0B89               LDRH     R3,[R1, #+8]
   \   00000010   1A43               ORRS     R2,R3,R2
   \   00000012   4B89               LDRH     R3,[R1, #+10]
   \   00000014   1A43               ORRS     R2,R3,R2
   \   00000016   8989               LDRH     R1,[R1, #+12]
   \   00000018   1143               ORRS     R1,R1,R2
   \   0000001A   A0F84410           STRH     R1,[R0, #+68]
    739          
    740          }
   \   0000001E   7047               BX       LR               ;; return
    741          
    742          /*******************************************************************************
    743          * Function Name  : TIM_TimeBaseStructInit
    744          * Description    : Fills each TIM_TimeBaseInitStruct member with its default value.
    745          * Input          : - TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
    746          *                    structure which will be initialized.
    747          * Output         : None
    748          * Return         : None
    749          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    750          void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    751          {
    752            /* Set the default configuration */
    753            TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
   \                     TIM_TimeBaseStructInit:
   \   00000000   4FF6FF71           MOVW     R1,#+65535
   \   00000004   8180               STRH     R1,[R0, #+4]
    754            TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   0180               STRH     R1,[R0, #+0]
    755            TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
   \   0000000A   0021               MOVS     R1,#+0
   \   0000000C   C180               STRH     R1,[R0, #+6]
    756            TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
   \   0000000E   0021               MOVS     R1,#+0
   \   00000010   4180               STRH     R1,[R0, #+2]
    757            TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
   \   00000012   0021               MOVS     R1,#+0
   \   00000014   0172               STRB     R1,[R0, #+8]
    758          }
   \   00000016   7047               BX       LR               ;; return
    759          
    760          /*******************************************************************************
    761          * Function Name  : TIM_OCStructInit
    762          * Description    : Fills each TIM_OCInitStruct member with its default value.
    763          * Input          : - TIM_OCInitStruct : pointer to a TIM_OCInitTypeDef structure
    764          *                    which will be initialized.
    765          * Output         : None
    766          * Return         : None
    767          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    768          void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
    769          {
    770            /* Set the default configuration */
    771            TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
   \                     TIM_OCStructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   0180               STRH     R1,[R0, #+0]
    772            TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   4180               STRH     R1,[R0, #+2]
    773            TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   8180               STRH     R1,[R0, #+4]
    774            TIM_OCInitStruct->TIM_Pulse = 0x0000;
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   C180               STRH     R1,[R0, #+6]
    775            TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
   \   00000010   0021               MOVS     R1,#+0
   \   00000012   0181               STRH     R1,[R0, #+8]
    776            TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
   \   00000014   0021               MOVS     R1,#+0
   \   00000016   4181               STRH     R1,[R0, #+10]
    777            TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
   \   00000018   0021               MOVS     R1,#+0
   \   0000001A   8181               STRH     R1,[R0, #+12]
    778            TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
   \   0000001C   0021               MOVS     R1,#+0
   \   0000001E   C181               STRH     R1,[R0, #+14]
    779          }
   \   00000020   7047               BX       LR               ;; return
    780          
    781          /*******************************************************************************
    782          * Function Name  : TIM_ICStructInit
    783          * Description    : Fills each TIM_ICInitStruct member with its default value.
    784          * Input          : - TIM_ICInitStruct : pointer to a TIM_ICInitTypeDef structure
    785          *                    which will be initialized.
    786          * Output         : None
    787          * Return         : None
    788          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    789          void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
    790          {
    791            /* Set the default configuration */
    792            TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
   \                     TIM_ICStructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   0180               STRH     R1,[R0, #+0]
    793            TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   4180               STRH     R1,[R0, #+2]
    794            TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
   \   00000008   0121               MOVS     R1,#+1
   \   0000000A   8180               STRH     R1,[R0, #+4]
    795            TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   C180               STRH     R1,[R0, #+6]
    796            TIM_ICInitStruct->TIM_ICFilter = 0x00;
   \   00000010   0021               MOVS     R1,#+0
   \   00000012   0181               STRH     R1,[R0, #+8]
    797          }
   \   00000014   7047               BX       LR               ;; return
    798          
    799          /*******************************************************************************
    800          * Function Name  : TIM_BDTRStructInit
    801          * Description    : Fills each TIM_BDTRInitStruct member with its default value.
    802          * Input          : - TIM_BDTRInitStruct : pointer to a TIM_BDTRInitTypeDef
    803          *                    structure which will be initialized.
    804          * Output         : None
    805          * Return         : None
    806          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    807          void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
    808          {
    809            /* Set the default configuration */
    810            TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
   \                     TIM_BDTRStructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   0180               STRH     R1,[R0, #+0]
    811            TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   4180               STRH     R1,[R0, #+2]
    812            TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   8180               STRH     R1,[R0, #+4]
    813            TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   C180               STRH     R1,[R0, #+6]
    814            TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
   \   00000010   0021               MOVS     R1,#+0
   \   00000012   0181               STRH     R1,[R0, #+8]
    815            TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
   \   00000014   0021               MOVS     R1,#+0
   \   00000016   4181               STRH     R1,[R0, #+10]
    816            TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
   \   00000018   0021               MOVS     R1,#+0
   \   0000001A   8181               STRH     R1,[R0, #+12]
    817          }
   \   0000001C   7047               BX       LR               ;; return
    818          
    819          /*******************************************************************************
    820          * Function Name  : TIM_Cmd
    821          * Description    : Enables or disables the specified TIM peripheral.
    822          * Input          : - TIMx: where x can be 1 to 8 to select the TIMx peripheral.
    823          *                  - NewState: new state of the TIMx peripheral.
    824          *                    This parameter can be: ENABLE or DISABLE.
    825          * Output         : None
    826          * Return         : None
    827          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    828          void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
    829          {
    830            /* Check the parameters */
    831            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    832            assert_param(IS_FUNCTIONAL_STATE(NewState));
    833            
    834            if (NewState != DISABLE)
   \                     TIM_Cmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??TIM_Cmd_0
    835            {
    836              /* Enable the TIM Counter */
    837              TIMx->CR1 |= CR1_CEN_Set;
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   51F00101           ORRS     R1,R1,#0x1
   \   0000000C   0180               STRH     R1,[R0, #+0]
   \   0000000E   04E0               B.N      ??TIM_Cmd_1
    838            }
    839            else
    840            {
    841              /* Disable the TIM Counter */
    842              TIMx->CR1 &= CR1_CEN_Reset;
   \                     ??TIM_Cmd_0:
   \   00000010   0188               LDRH     R1,[R0, #+0]
   \   00000012   40F2FE32           MOVW     R2,#+1022
   \   00000016   1140               ANDS     R1,R2,R1
   \   00000018   0180               STRH     R1,[R0, #+0]
    843            }
    844          }
   \                     ??TIM_Cmd_1:
   \   0000001A   7047               BX       LR               ;; return
    845          
    846          /*******************************************************************************
    847          * Function Name  : TIM_CtrlPWMOutputs
    848          * Description    : Enables or disables the TIM peripheral Main Outputs.
    849          * Input          :- TIMx: where x can be 1 or 8 to select the TIMx peripheral.
    850          *                 - NewState: new state of the TIM peripheral Main Outputs.
    851          *                    This parameter can be: ENABLE or DISABLE.
    852          * Output         : None
    853          * Return         : None
    854          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    855          void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
    856          {
    857            /* Check the parameters */
    858            assert_param(IS_TIM_18_PERIPH(TIMx));
    859            assert_param(IS_FUNCTIONAL_STATE(NewState));
    860          
    861            if (NewState != DISABLE)
   \                     TIM_CtrlPWMOutputs:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   06D0               BEQ.N    ??TIM_CtrlPWMOutputs_0
    862            {
    863              /* Enable the TIM Main Output */
    864              TIMx->BDTR |= BDTR_MOE_Set;
   \   00000006   B0F84410           LDRH     R1,[R0, #+68]
   \   0000000A   51F40041           ORRS     R1,R1,#0x8000
   \   0000000E   A0F84410           STRH     R1,[R0, #+68]
   \   00000012   05E0               B.N      ??TIM_CtrlPWMOutputs_1
    865            }
    866            else
    867            {
    868              /* Disable the TIM Main Output */
    869              TIMx->BDTR &= BDTR_MOE_Reset;
   \                     ??TIM_CtrlPWMOutputs_0:
   \   00000014   B0F84410           LDRH     R1,[R0, #+68]
   \   00000018   4904               LSLS     R1,R1,#+17
   \   0000001A   490C               LSRS     R1,R1,#+17
   \   0000001C   A0F84410           STRH     R1,[R0, #+68]
    870            }  
    871          }
   \                     ??TIM_CtrlPWMOutputs_1:
   \   00000020   7047               BX       LR               ;; return
    872          
    873          /*******************************************************************************
    874          * Function Name  : TIM_ITConfig
    875          * Description    : Enables or disables the specified TIM interrupts.
    876          * Input          : - TIMx: where x can be 1 to 8 to select the TIMx peripheral.
    877          *                  - TIM_IT: specifies the TIM interrupts sources to be enabled
    878          *                    or disabled.
    879          *                    This parameter can be any combination of the following values:
    880          *                       - TIM_IT_Update: TIM update Interrupt source
    881          *                       - TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
    882          *                       - TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
    883          *                       - TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
    884          *                       - TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
    885          *                       - TIM_IT_COM: TIM Commutation Interrupt source
    886          *                       - TIM_IT_Trigger: TIM Trigger Interrupt source
    887          *                       - TIM_IT_Break: TIM Break Interrupt source
    888          *                  - NewState: new state of the TIM interrupts.
    889          *                    This parameter can be: ENABLE or DISABLE.
    890          * Output         : None
    891          * Return         : None
    892          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    893          void TIM_ITConfig(TIM_TypeDef* TIMx, u16 TIM_IT, FunctionalState NewState)
    894          {  
    895            /* Check the parameters */
    896            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    897            assert_param(IS_TIM_IT(TIM_IT));
    898            assert_param(IS_TIM_PERIPH_IT((TIMx), (TIM_IT)));
    899            assert_param(IS_FUNCTIONAL_STATE(NewState));
    900            
    901            if (NewState != DISABLE)
   \                     TIM_ITConfig:
   \   00000000   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   002A               CMP      R2,#+0
   \   00000004   03D0               BEQ.N    ??TIM_ITConfig_0
    902            {
    903              /* Enable the Interrupt sources */
    904              TIMx->DIER |= TIM_IT;
   \   00000006   8289               LDRH     R2,[R0, #+12]
   \   00000008   1143               ORRS     R1,R1,R2
   \   0000000A   8181               STRH     R1,[R0, #+12]
   \   0000000C   03E0               B.N      ??TIM_ITConfig_1
    905            }
    906            else
    907            {
    908              /* Disable the Interrupt sources */
    909              TIMx->DIER &= (u16)~TIM_IT;
   \                     ??TIM_ITConfig_0:
   \   0000000E   8289               LDRH     R2,[R0, #+12]
   \   00000010   C943               MVNS     R1,R1
   \   00000012   1140               ANDS     R1,R1,R2
   \   00000014   8181               STRH     R1,[R0, #+12]
    910            }
    911          }
   \                     ??TIM_ITConfig_1:
   \   00000016   7047               BX       LR               ;; return
    912          
    913          /*******************************************************************************
    914          * Function Name  : TIM_GenerateEvent
    915          * Description    : Configures the TIMx event to be generate by software.
    916          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
    917          *                  - TIM_EventSource: specifies the event source.
    918          *                    This parameter can be one or more of the following values:	   
    919          *                       - TIM_EventSource_Update: Timer update Event source
    920          *                       - TIM_EventSource_CC1: Timer Capture Compare 1 Event source
    921          *                       - TIM_EventSource_CC2: Timer Capture Compare 2 Event source
    922          *                       - TIM_EventSource_CC3: Timer Capture Compare 3 Event source
    923          *                       - TIM_EventSource_CC4: Timer Capture Compare 4 Event source
    924          *                       - TIM_EventSource_Trigger: Timer Trigger Event source
    925          * Output         : None
    926          * Return         : None
    927          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    928          void TIM_GenerateEvent(TIM_TypeDef* TIMx, u16 TIM_EventSource)
    929          { 
    930            /* Check the parameters */
    931            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    932            assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
    933            assert_param(IS_TIM_PERIPH_EVENT((TIMx), (TIM_EventSource)));
    934          
    935            /* Set the event sources */
    936            TIMx->EGR = TIM_EventSource;
   \                     TIM_GenerateEvent:
   \   00000000   8182               STRH     R1,[R0, #+20]
    937          }
   \   00000002   7047               BX       LR               ;; return
    938          
    939          /*******************************************************************************
    940          * Function Name  : TIM_DMAConfig
    941          * Description    : Configures the TIMxs DMA interface.
    942          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
    943          *                    peripheral.
    944          *                  - TIM_DMABase: DMA Base address.
    945          *                    This parameter can be one of the following values:
    946          *                       - TIM_DMABase_CR, TIM_DMABase_CR2, TIM_DMABase_SMCR,
    947          *                         TIM_DMABase_DIER, TIM1_DMABase_SR, TIM_DMABase_EGR,
    948          *                         TIM_DMABase_CCMR1, TIM_DMABase_CCMR2, TIM_DMABase_CCER,
    949          *                         TIM_DMABase_CNT, TIM_DMABase_PSC, TIM_DMABase_ARR,
    950          *                         TIM_DMABase_RCR, TIM_DMABase_CCR1, TIM_DMABase_CCR2,
    951          *                         TIM_DMABase_CCR3, TIM_DMABase_CCR4, TIM_DMABase_BDTR,
    952          *                         TIM_DMABase_DCR.
    953          *                   - TIM_DMABurstLength: DMA Burst length.
    954          *                     This parameter can be one value between:
    955          *                     TIM_DMABurstLength_1Byte and TIM_DMABurstLength_18Bytes.
    956          * Output         : None
    957          * Return         : None
    958          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    959          void TIM_DMAConfig(TIM_TypeDef* TIMx, u16 TIM_DMABase, u16 TIM_DMABurstLength)
    960          {
    961            /* Check the parameters */
    962            assert_param(IS_TIM_123458_PERIPH(TIMx));
    963            assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
    964            assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
    965          
    966            /* Set the DMA Base and the DMA Burst Length */
    967            TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
   \                     TIM_DMAConfig:
   \   00000000   1143               ORRS     R1,R2,R1
   \   00000002   A0F84810           STRH     R1,[R0, #+72]
    968          }
   \   00000006   7047               BX       LR               ;; return
    969          
    970          /*******************************************************************************
    971          * Function Name  : TIM_DMACmd
    972          * Description    : Enables or disables the TIMxs DMA Requests.
    973          * Input          : - TIMx: where x can be  1 to 8 to select the TIM peripheral. 
    974          *                  - TIM_DMASources: specifies the DMA Request sources.
    975          *                    This parameter can be any combination of the following values:
    976          *                       - TIM_DMA_Update: TIM update Interrupt source
    977          *                       - TIM_DMA_CC1: TIM Capture Compare 1 DMA source
    978          *                       - TIM_DMA_CC2: TIM Capture Compare 2 DMA source
    979          *                       - TIM_DMA_CC3: TIM Capture Compare 3 DMA source
    980          *                       - TIM_DMA_CC4: TIM Capture Compare 4 DMA source
    981          *                       - TIM_DMA_COM: TIM Commutation DMA source
    982          *                       - TIM_DMA_Trigger: TIM Trigger DMA source
    983          *                  - NewState: new state of the DMA Request sources.
    984          *                    This parameter can be: ENABLE or DISABLE.
    985          * Output         : None
    986          * Return         : None
    987          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    988          void TIM_DMACmd(TIM_TypeDef* TIMx, u16 TIM_DMASource, FunctionalState NewState)
    989          { 
    990            /* Check the parameters */
    991            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    992            assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
    993            assert_param(IS_TIM_PERIPH_DMA(TIMx, TIM_DMASource));
    994            assert_param(IS_FUNCTIONAL_STATE(NewState));
    995            
    996            if (NewState != DISABLE)
   \                     TIM_DMACmd:
   \   00000000   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   002A               CMP      R2,#+0
   \   00000004   03D0               BEQ.N    ??TIM_DMACmd_0
    997            {
    998              /* Enable the DMA sources */
    999              TIMx->DIER |= TIM_DMASource; 
   \   00000006   8289               LDRH     R2,[R0, #+12]
   \   00000008   1143               ORRS     R1,R1,R2
   \   0000000A   8181               STRH     R1,[R0, #+12]
   \   0000000C   03E0               B.N      ??TIM_DMACmd_1
   1000            }
   1001            else
   1002            {
   1003              /* Disable the DMA sources */
   1004              TIMx->DIER &= (u16)~TIM_DMASource;
   \                     ??TIM_DMACmd_0:
   \   0000000E   8289               LDRH     R2,[R0, #+12]
   \   00000010   C943               MVNS     R1,R1
   \   00000012   1140               ANDS     R1,R1,R2
   \   00000014   8181               STRH     R1,[R0, #+12]
   1005            }
   1006          }
   \                     ??TIM_DMACmd_1:
   \   00000016   7047               BX       LR               ;; return
   1007          
   1008          /*******************************************************************************
   1009          * Function Name  : TIM_InternalClockConfig
   1010          * Description    : Configures the TIMx interrnal Clock
   1011          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1012          *                    peripheral.
   1013          * Output         : None
   1014          * Return         : None
   1015          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1016          void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
   1017          {
   1018            /* Check the parameters */
   1019            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1020          
   1021            /* Disable slave mode to clock the prescaler directly with the internal clock */
   1022            TIMx->SMCR &=  SMCR_SMS_Mask;
   \                     TIM_InternalClockConfig:
   \   00000000   0189               LDRH     R1,[R0, #+8]
   \   00000002   31F00701           BICS     R1,R1,#0x7
   \   00000006   0181               STRH     R1,[R0, #+8]
   1023          }
   \   00000008   7047               BX       LR               ;; return
   1024          /*******************************************************************************
   1025          * Function Name  : TIM_ITRxExternalClockConfig
   1026          * Description    : Configures the TIMx Internal Trigger as External Clock
   1027          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1028          *                    peripheral.
   1029          *                  - TIM_ITRSource: Trigger source.
   1030          *                    This parameter can be one of the following values:
   1031          *                       - TIM_TS_ITR0: Internal Trigger 0
   1032          *                       - TIM_TS_ITR1: Internal Trigger 1
   1033          *                       - TIM_TS_ITR2: Internal Trigger 2
   1034          *                       - TIM_TS_ITR3: Internal Trigger 3
   1035          * Output         : None
   1036          * Return         : None
   1037          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1038          void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
   1039          {
   \                     TIM_ITRxExternalClockConfig:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   1040            /* Check the parameters */
   1041            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1042            assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
   1043          
   1044            /* Select the Internal Trigger */
   1045            TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
   \   00000004   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   2000               MOVS     R0,R4
   \   00000008   ........           BL       TIM_SelectInputTrigger
   1046          
   1047            /* Select the External clock mode1 */
   1048            TIMx->SMCR |= TIM_SlaveMode_External1;
   \   0000000C   2089               LDRH     R0,[R4, #+8]
   \   0000000E   50F00700           ORRS     R0,R0,#0x7
   \   00000012   2081               STRH     R0,[R4, #+8]
   1049          }
   \   00000014   10BD               POP      {R4,PC}          ;; return
   1050          /*******************************************************************************
   1051          * Function Name  : TIM_TIxExternalClockConfig
   1052          * Description    : Configures the TIMx Trigger as External Clock
   1053          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1054          *                    peripheral.
   1055          *                  - TIM_TIxExternalCLKSource: Trigger source.
   1056          *                    This parameter can be one of the following values:
   1057          *                       - TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector
   1058          *                       - TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1
   1059          *                       - TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2
   1060          *                  - TIM_ICPolarity: specifies the TIx Polarity.
   1061          *                    This parameter can be:
   1062          *                       - TIM_ICPolarity_Rising
   1063          *                       - TIM_ICPolarity_Falling
   1064          *                   - ICFilter : specifies the filter value.
   1065          *                     This parameter must be a value between 0x0 and 0xF.
   1066          * Output         : None
   1067          * Return         : None
   1068          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1069          void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_TIxExternalCLKSource,
   1070                                          u16 TIM_ICPolarity, u16 ICFilter)
   1071          {
   \                     TIM_TIxExternalClockConfig:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1100               MOVS     R1,R2
   1072            /* Check the parameters */
   1073            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1074            assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
   1075            assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
   1076            assert_param(IS_TIM_IC_FILTER(ICFilter));
   1077          
   1078            /* Configure the Timer Input Clock Source */
   1079            if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
   \   00000008   ADB2               UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000000A   602D               CMP      R5,#+96
   \   0000000C   06D1               BNE.N    ??TIM_TIxExternalClockConfig_0
   1080            {
   1081              TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   \   0000000E   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000010   0122               MOVS     R2,#+1
   \   00000012   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000014   2000               MOVS     R0,R4
   \   00000016   ........           BL       TI2_Config
   \   0000001A   05E0               B.N      ??TIM_TIxExternalClockConfig_1
   1082            }
   1083            else
   1084            {
   1085              TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   \                     ??TIM_TIxExternalClockConfig_0:
   \   0000001C   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000001E   0122               MOVS     R2,#+1
   \   00000020   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000022   2000               MOVS     R0,R4
   \   00000024   ........           BL       TI1_Config
   1086            }
   1087          
   1088            /* Select the Trigger source */
   1089            TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
   \                     ??TIM_TIxExternalClockConfig_1:
   \   00000028   2900               MOVS     R1,R5
   \   0000002A   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000002C   2000               MOVS     R0,R4
   \   0000002E   ........           BL       TIM_SelectInputTrigger
   1090          
   1091            /* Select the External clock mode1 */
   1092            TIMx->SMCR |= TIM_SlaveMode_External1;
   \   00000032   2089               LDRH     R0,[R4, #+8]
   \   00000034   50F00700           ORRS     R0,R0,#0x7
   \   00000038   2081               STRH     R0,[R4, #+8]
   1093          }
   \   0000003A   31BD               POP      {R0,R4,R5,PC}    ;; return
   1094          
   1095          /*******************************************************************************
   1096          * Function Name  : TIM_ETRClockMode1Config
   1097          * Description    : Configures the External clock Mode1
   1098          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1099          *                    peripheral.
   1100          *                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   1101          *                    It can be one of the following values:
   1102          *                       - TIM_ExtTRGPSC_OFF
   1103          *                       - TIM_ExtTRGPSC_DIV2
   1104          *                       - TIM_ExtTRGPSC_DIV4
   1105          *                       - TIM_ExtTRGPSC_DIV8.
   1106          *                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
   1107          *                    It can be one of the following values:
   1108          *                       - TIM_ExtTRGPolarity_Inverted
   1109          *                       - TIM_ExtTRGPolarity_NonInverted
   1110          *                  - ExtTRGFilter: External Trigger Filter.
   1111          *                    This parameter must be a value between 0x00 and 0x0F
   1112          * Output         : None
   1113          * Return         : None
   1114          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1115          void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
   1116                                       u16 ExtTRGFilter)
   1117          {
   \                     TIM_ETRClockMode1Config:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
   1118            u16 tmpsmcr = 0;
   \   00000004   0025               MOVS     R5,#+0
   1119          
   1120            /* Check the parameters */
   1121            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1122            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   1123            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   1124            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   1125          
   1126            /* Configure the ETR Clock source */
   1127            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   \   00000006   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000008   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000A   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   ........           BL       TIM_ETRConfig
   1128            
   1129            /* Get the TIMx SMCR register value */
   1130            tmpsmcr = TIMx->SMCR;
   \   00000012   2089               LDRH     R0,[R4, #+8]
   \   00000014   0500               MOVS     R5,R0
   1131          
   1132            /* Reset the SMS Bits */
   1133            tmpsmcr &= SMCR_SMS_Mask;
   \   00000016   4FF6F870           MOVW     R0,#+65528
   \   0000001A   0540               ANDS     R5,R0,R5
   1134            /* Select the External clock mode1 */
   1135            tmpsmcr |= TIM_SlaveMode_External1;
   \   0000001C   55F00705           ORRS     R5,R5,#0x7
   1136          
   1137            /* Select the Trigger selection : ETRF */
   1138            tmpsmcr &= SMCR_TS_Mask;
   \   00000020   4FF68F70           MOVW     R0,#+65423
   \   00000024   0540               ANDS     R5,R0,R5
   1139            tmpsmcr |= TIM_TS_ETRF;
   \   00000026   55F07005           ORRS     R5,R5,#0x70
   1140          
   1141            /* Write to TIMx SMCR */
   1142            TIMx->SMCR = tmpsmcr;
   \   0000002A   2581               STRH     R5,[R4, #+8]
   1143          }
   \   0000002C   31BD               POP      {R0,R4,R5,PC}    ;; return
   1144          
   1145          /*******************************************************************************
   1146          * Function Name  : TIM_ETRClockMode2Config
   1147          * Description    : Configures the External clock Mode2
   1148          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1149          *                    peripheral.
   1150          *                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   1151          *                    It can be one of the following values:
   1152          *                       - TIM_ExtTRGPSC_OFF
   1153          *                       - TIM_ExtTRGPSC_DIV2
   1154          *                       - TIM_ExtTRGPSC_DIV4
   1155          *                       - TIM_ExtTRGPSC_DIV8
   1156          *                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
   1157          *                    It can be one of the following values:
   1158          *                       - TIM_ExtTRGPolarity_Inverted
   1159          *                       - TIM_ExtTRGPolarity_NonInverted
   1160          *                  - ExtTRGFilter: External Trigger Filter.
   1161          *                    This parameter must be a value between 0x00 and 0x0F
   1162          * Output         : None
   1163          * Return         : None
   1164          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1165          void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, 
   1166                                       u16 TIM_ExtTRGPolarity, u16 ExtTRGFilter)
   1167          {
   \                     TIM_ETRClockMode2Config:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   1168            /* Check the parameters */
   1169            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1170            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   1171            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   1172            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   1173          
   1174            /* Configure the ETR Clock source */
   1175            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   \   00000004   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000006   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000008   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   ........           BL       TIM_ETRConfig
   1176          
   1177            /* Enable the External clock mode2 */
   1178            TIMx->SMCR |= SMCR_ECE_Set;
   \   00000010   2089               LDRH     R0,[R4, #+8]
   \   00000012   50F48040           ORRS     R0,R0,#0x4000
   \   00000016   2081               STRH     R0,[R4, #+8]
   1179          }
   \   00000018   10BD               POP      {R4,PC}          ;; return
   1180          
   1181          /*******************************************************************************
   1182          * Function Name  : TIM_ETRConfig
   1183          * Description    : Configures the TIMx External Trigger (ETR).
   1184          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1185          *                    peripheral.
   1186          *                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   1187          *                    This parameter can be one of the following values:
   1188          *                       - TIM_ExtTRGPSC_OFF
   1189          *                       - TIM_ExtTRGPSC_DIV2
   1190          *                       - TIM_ExtTRGPSC_DIV4
   1191          *                       - TIM_ExtTRGPSC_DIV8
   1192          *                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
   1193          *                    This parameter can be one of the following values:
   1194          *                       - TIM_ExtTRGPolarity_Inverted
   1195          *                       - TIM_ExtTRGPolarity_NonInverted
   1196          *                  - ExtTRGFilter: External Trigger Filter.
   1197          *                    This parameter must be a value between 0x00 and 0x0F.
   1198          * Output         : None
   1199          * Return         : None
   1200          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1201          void TIM_ETRConfig(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
   1202                             u16 ExtTRGFilter)
   1203          {
   \                     TIM_ETRConfig:
   \   00000000   30B4               PUSH     {R4,R5}
   1204            u16 tmpsmcr = 0;
   \   00000002   0024               MOVS     R4,#+0
   1205          
   1206            /* Check the parameters */
   1207            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1208            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   1209            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   1210            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   1211          
   1212            tmpsmcr = TIMx->SMCR;
   \   00000004   0589               LDRH     R5,[R0, #+8]
   \   00000006   2C00               MOVS     R4,R5
   1213          
   1214            /* Reset the ETR Bits */
   1215            tmpsmcr &= SMCR_ETR_Mask;
   \   00000008   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   1216          
   1217            /* Set the Prescaler, the Filter value and the Polarity */
   1218            tmpsmcr |= TIM_ExtTRGPrescaler | TIM_ExtTRGPolarity | (u16)(ExtTRGFilter << 8);
   \   0000000A   1143               ORRS     R1,R2,R1
   \   0000000C   51EA0321           ORRS     R1,R1,R3, LSL #+8
   \   00000010   0C43               ORRS     R4,R1,R4
   1219          
   1220            /* Write to TIMx SMCR */
   1221            TIMx->SMCR = tmpsmcr;
   \   00000012   0481               STRH     R4,[R0, #+8]
   1222          }
   \   00000014   30BC               POP      {R4,R5}
   \   00000016   7047               BX       LR               ;; return
   1223          
   1224          /*******************************************************************************
   1225          * Function Name  : TIM_PrescalerConfig
   1226          * Description    : Configures the TIMx Prescaler.
   1227          * Input          : - TIMx: where x can be  1 to 8 to select the TIM peripheral.
   1228          *                  - Prescaler: specifies the Prescaler Register value
   1229          *                  - TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
   1230          *                    This parameter can be one of the following values:
   1231          *                       - TIM_PSCReloadMode_Update: The Prescaler is loaded at
   1232          *                         the update event.
   1233          *                       - TIM_PSCReloadMode_Immediate: The Prescaler is loaded
   1234          *                         immediatly.
   1235          * Output         : None
   1236          * Return         : None
   1237          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1238          void TIM_PrescalerConfig(TIM_TypeDef* TIMx, u16 Prescaler, u16 TIM_PSCReloadMode)
   1239          {
   1240            /* Check the parameters */
   1241            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1242            assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
   1243          
   1244            /* Set the Prescaler value */
   1245            TIMx->PSC = Prescaler;
   \                     TIM_PrescalerConfig:
   \   00000000   0185               STRH     R1,[R0, #+40]
   1246          
   1247            /* Set or reset the UG Bit */
   1248            TIMx->EGR = TIM_PSCReloadMode;
   \   00000002   8282               STRH     R2,[R0, #+20]
   1249          }
   \   00000004   7047               BX       LR               ;; return
   1250          
   1251          /*******************************************************************************
   1252          * Function Name  : TIM_CounterModeConfig
   1253          * Description    : Specifies the TIMx Counter Mode to be used.
   1254          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1255          *                    peripheral.
   1256          *                  - TIM_CounterMode: specifies the Counter Mode to be used
   1257          *                    This parameter can be one of the following values:
   1258          *                       - TIM_CounterMode_Up: TIM Up Counting Mode
   1259          *                       - TIM_CounterMode_Down: TIM Down Counting Mode
   1260          *                       - TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
   1261          *                       - TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
   1262          *                       - TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
   1263          * Output         : None
   1264          * Return         : None
   1265          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1266          void TIM_CounterModeConfig(TIM_TypeDef* TIMx, u16 TIM_CounterMode)
   1267          {
   1268            u16 tmpcr1 = 0;
   \                     TIM_CounterModeConfig:
   \   00000000   0022               MOVS     R2,#+0
   1269          
   1270            /* Check the parameters */
   1271            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1272            assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
   1273          
   1274            tmpcr1 = TIMx->CR1;
   \   00000002   0388               LDRH     R3,[R0, #+0]
   \   00000004   1A00               MOVS     R2,R3
   1275          
   1276            /* Reset the CMS and DIR Bits */
   1277            tmpcr1 &= CR1_CounterMode_Mask;
   \   00000006   40F28F33           MOVW     R3,#+911
   \   0000000A   1A40               ANDS     R2,R3,R2
   1278          
   1279            /* Set the Counter Mode */
   1280            tmpcr1 |= TIM_CounterMode;
   \   0000000C   0A43               ORRS     R2,R1,R2
   1281          
   1282            /* Write to TIMx CR1 register */
   1283            TIMx->CR1 = tmpcr1;
   \   0000000E   0280               STRH     R2,[R0, #+0]
   1284          }
   \   00000010   7047               BX       LR               ;; return
   1285          
   1286          /*******************************************************************************
   1287          * Function Name  : TIM_SelectInputTrigger
   1288          * Description    : Selects the Input Trigger source
   1289          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1290          *                    peripheral.
   1291          *                  - TIM_InputTriggerSource: The Input Trigger source.
   1292          *                    This parameter can be one of the following values:
   1293          *                       - TIM_TS_ITR0: Internal Trigger 0
   1294          *                       - TIM_TS_ITR1: Internal Trigger 1
   1295          *                       - TIM_TS_ITR2: Internal Trigger 2
   1296          *                       - TIM_TS_ITR3: Internal Trigger 3
   1297          *                       - TIM_TS_TI1F_ED: TI1 Edge Detector
   1298          *                       - TIM_TS_TI1FP1: Filtered Timer Input 1
   1299          *                       - TIM_TS_TI2FP2: Filtered Timer Input 2
   1300          *                       - TIM_TS_ETRF: External Trigger input
   1301          * Output         : None
   1302          * Return         : None
   1303          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1304          void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
   1305          {
   1306            u16 tmpsmcr = 0;
   \                     TIM_SelectInputTrigger:
   \   00000000   0022               MOVS     R2,#+0
   1307          
   1308            /* Check the parameters */
   1309            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1310            assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
   1311          
   1312            /* Get the TIMx SMCR register value */
   1313            tmpsmcr = TIMx->SMCR;
   \   00000002   0389               LDRH     R3,[R0, #+8]
   \   00000004   1A00               MOVS     R2,R3
   1314          
   1315            /* Reset the TS Bits */
   1316            tmpsmcr &= SMCR_TS_Mask;
   \   00000006   4FF68F73           MOVW     R3,#+65423
   \   0000000A   1A40               ANDS     R2,R3,R2
   1317          
   1318            /* Set the Input Trigger source */
   1319            tmpsmcr |= TIM_InputTriggerSource;
   \   0000000C   0A43               ORRS     R2,R1,R2
   1320          
   1321            /* Write to TIMx SMCR */
   1322            TIMx->SMCR = tmpsmcr;
   \   0000000E   0281               STRH     R2,[R0, #+8]
   1323          }
   \   00000010   7047               BX       LR               ;; return
   1324          
   1325          /*******************************************************************************
   1326          * Function Name  : TIM_EncoderInterfaceConfig
   1327          * Description    : Configures the TIMx Encoder Interface.
   1328          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1329          *                    peripheral.
   1330          *                  - TIM_EncoderMode: specifies the TIMx Encoder Mode.
   1331          *                    This parameter can be one of the following values:
   1332          *                       - TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge
   1333          *                         depending on TI2FP2 level.
   1334          *                       - TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge
   1335          *                         depending on TI1FP1 level.
   1336          *                       - TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and
   1337          *                         TI2FP2 edges depending on the level of the other input.
   1338          *                  - TIM_IC1Polarity: specifies the IC1 Polarity
   1339          *                    This parmeter can be one of the following values:
   1340          *                        - TIM_ICPolarity_Falling: IC Falling edge.
   1341          *                        - TIM_ICPolarity_Rising: IC Rising edge.
   1342          *                  - TIM_IC2Polarity: specifies the IC2 Polarity
   1343          *                    This parmeter can be one of the following values:
   1344          *                        - TIM_ICPolarity_Falling: IC Falling edge.
   1345          *                        - TIM_ICPolarity_Rising: IC Rising edge.
   1346          * Output         : None
   1347          * Return         : None
   1348          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1349          void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, u16 TIM_EncoderMode,
   1350                                          u16 TIM_IC1Polarity, u16 TIM_IC2Polarity)
   1351          {
   \                     TIM_EncoderInterfaceConfig:
   \   00000000   F0B4               PUSH     {R4-R7}
   1352            u16 tmpsmcr = 0;
   \   00000002   0024               MOVS     R4,#+0
   1353            u16 tmpccmr1 = 0;
   \   00000004   0025               MOVS     R5,#+0
   1354            u16 tmpccer = 0;
   \   00000006   0026               MOVS     R6,#+0
   1355              
   1356            /* Check the parameters */
   1357            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1358            assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
   1359            assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
   1360            assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
   1361          
   1362            /* Get the TIMx SMCR register value */
   1363            tmpsmcr = TIMx->SMCR;
   \   00000008   0789               LDRH     R7,[R0, #+8]
   \   0000000A   3C00               MOVS     R4,R7
   1364          
   1365            /* Get the TIMx CCMR1 register value */
   1366            tmpccmr1 = TIMx->CCMR1;
   \   0000000C   078B               LDRH     R7,[R0, #+24]
   \   0000000E   3D00               MOVS     R5,R7
   1367          
   1368            /* Get the TIMx CCER register value */
   1369            tmpccer = TIMx->CCER;
   \   00000010   078C               LDRH     R7,[R0, #+32]
   \   00000012   3E00               MOVS     R6,R7
   1370          
   1371            /* Set the encoder Mode */
   1372            tmpsmcr &= SMCR_SMS_Mask;
   \   00000014   4FF6F877           MOVW     R7,#+65528
   \   00000018   3C40               ANDS     R4,R7,R4
   1373            tmpsmcr |= TIM_EncoderMode;
   \   0000001A   0C43               ORRS     R4,R1,R4
   1374          
   1375            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   1376            tmpccmr1 &= CCMR_CC13S_Mask & CCMR_CC24S_Mask;
   \   0000001C   4FF6FC41           MOVW     R1,#+64764
   \   00000020   0D40               ANDS     R5,R1,R5
   1377            tmpccmr1 |= CCMR_TI13Direct_Set | CCMR_TI24Direct_Set;
   \   00000022   40F20111           MOVW     R1,#+257
   \   00000026   0D43               ORRS     R5,R1,R5
   1378          
   1379            /* Set the TI1 and the TI2 Polarities */
   1380            tmpccer &= CCER_CC1P_Reset & CCER_CC2P_Reset;
   \   00000028   4FF6DD71           MOVW     R1,#+65501
   \   0000002C   0E40               ANDS     R6,R1,R6
   1381            tmpccer |= (TIM_IC1Polarity | (u16)(TIM_IC2Polarity << 4));
   \   0000002E   52EA0311           ORRS     R1,R2,R3, LSL #+4
   \   00000032   0E43               ORRS     R6,R1,R6
   1382          
   1383            /* Write to TIMx SMCR */
   1384            TIMx->SMCR = tmpsmcr;
   \   00000034   0481               STRH     R4,[R0, #+8]
   1385          
   1386            /* Write to TIMx CCMR1 */
   1387            TIMx->CCMR1 = tmpccmr1;
   \   00000036   0583               STRH     R5,[R0, #+24]
   1388          
   1389            /* Write to TIMx CCER */
   1390            TIMx->CCER = tmpccer;
   \   00000038   0684               STRH     R6,[R0, #+32]
   1391          }
   \   0000003A   F0BC               POP      {R4-R7}
   \   0000003C   7047               BX       LR               ;; return
   1392          
   1393          /*******************************************************************************
   1394          * Function Name  : TIM_ForcedOC1Config
   1395          * Description    : Forces the TIMx output 1 waveform to active or inactive level.
   1396          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1397          *                    peripheral.
   1398          *                  - TIM_ForcedAction: specifies the forced Action to be set to
   1399          *                    the output waveform.
   1400          *                    This parameter can be one of the following values:
   1401          *                       - TIM_ForcedAction_Active: Force active level on OC1REF
   1402          *                       - TIM_ForcedAction_InActive: Force inactive level on
   1403          *                         OC1REF.
   1404          * Output         : None
   1405          * Return         : None
   1406          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1407          void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
   1408          {
   1409            u16 tmpccmr1 = 0;
   \                     TIM_ForcedOC1Config:
   \   00000000   0022               MOVS     R2,#+0
   1410          
   1411            /* Check the parameters */
   1412            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1413            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1414          
   1415            tmpccmr1 = TIMx->CCMR1;
   \   00000002   038B               LDRH     R3,[R0, #+24]
   \   00000004   1A00               MOVS     R2,R3
   1416          
   1417            /* Reset the OC1M Bits */
   1418            tmpccmr1 &= CCMR_OC13M_Mask;
   \   00000006   4FF68F73           MOVW     R3,#+65423
   \   0000000A   1A40               ANDS     R2,R3,R2
   1419          
   1420            /* Configure The Forced output Mode */
   1421            tmpccmr1 |= TIM_ForcedAction;
   \   0000000C   0A43               ORRS     R2,R1,R2
   1422          
   1423            /* Write to TIMx CCMR1 register */
   1424            TIMx->CCMR1 = tmpccmr1;
   \   0000000E   0283               STRH     R2,[R0, #+24]
   1425          }
   \   00000010   7047               BX       LR               ;; return
   1426          
   1427          /*******************************************************************************
   1428          * Function Name  : TIM_ForcedOC2Config
   1429          * Description    : Forces the TIMx output 2 waveform to active or inactive level.
   1430          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1431          *                    peripheral.
   1432          *                  - TIM_ForcedAction: specifies the forced Action to be set to
   1433          *                    the output waveform.
   1434          *                    This parameter can be one of the following values:
   1435          *                       - TIM_ForcedAction_Active: Force active level on OC2REF
   1436          *                       - TIM_ForcedAction_InActive: Force inactive level on
   1437          *                         OC2REF.
   1438          * Output         : None
   1439          * Return         : None
   1440          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1441          void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
   1442          {
   1443            u16 tmpccmr1 = 0;
   \                     TIM_ForcedOC2Config:
   \   00000000   0022               MOVS     R2,#+0
   1444          
   1445            /* Check the parameters */
   1446            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1447            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1448          
   1449            tmpccmr1 = TIMx->CCMR1;
   \   00000002   038B               LDRH     R3,[R0, #+24]
   \   00000004   1A00               MOVS     R2,R3
   1450          
   1451            /* Reset the OC2M Bits */
   1452            tmpccmr1 &= CCMR_OC24M_Mask;
   \   00000006   48F6FF73           MOVW     R3,#+36863
   \   0000000A   1A40               ANDS     R2,R3,R2
   1453          
   1454            /* Configure The Forced output Mode */
   1455            tmpccmr1 |= (u16)(TIM_ForcedAction << 8);
   \   0000000C   52EA0122           ORRS     R2,R2,R1, LSL #+8
   1456          
   1457            /* Write to TIMx CCMR1 register */
   1458            TIMx->CCMR1 = tmpccmr1;
   \   00000010   0283               STRH     R2,[R0, #+24]
   1459          }
   \   00000012   7047               BX       LR               ;; return
   1460          
   1461          /*******************************************************************************
   1462          * Function Name  : TIM_ForcedOC3Config
   1463          * Description    : Forces the TIMx output 3 waveform to active or inactive level.
   1464          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1465          *                    peripheral.
   1466          *                  - TIM_ForcedAction: specifies the forced Action to be set to
   1467          *                    the output waveform.
   1468          *                    This parameter can be one of the following values:
   1469          *                       - TIM_ForcedAction_Active: Force active level on OC3REF
   1470          *                       - TIM_ForcedAction_InActive: Force inactive level on
   1471          *                         OC3REF.
   1472          * Output         : None
   1473          * Return         : None
   1474          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1475          void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
   1476          {
   1477            u16 tmpccmr2 = 0;
   \                     TIM_ForcedOC3Config:
   \   00000000   0022               MOVS     R2,#+0
   1478          
   1479            /* Check the parameters */
   1480            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1481            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1482          
   1483            tmpccmr2 = TIMx->CCMR2;
   \   00000002   838B               LDRH     R3,[R0, #+28]
   \   00000004   1A00               MOVS     R2,R3
   1484          
   1485            /* Reset the OC1M Bits */
   1486            tmpccmr2 &= CCMR_OC13M_Mask;
   \   00000006   4FF68F73           MOVW     R3,#+65423
   \   0000000A   1A40               ANDS     R2,R3,R2
   1487          
   1488            /* Configure The Forced output Mode */
   1489            tmpccmr2 |= TIM_ForcedAction;
   \   0000000C   0A43               ORRS     R2,R1,R2
   1490          
   1491            /* Write to TIMx CCMR2 register */
   1492            TIMx->CCMR2 = tmpccmr2;
   \   0000000E   8283               STRH     R2,[R0, #+28]
   1493          }
   \   00000010   7047               BX       LR               ;; return
   1494          
   1495          /*******************************************************************************
   1496          * Function Name  : TIM_ForcedOC4Config
   1497          * Description    : Forces the TIMx output 4 waveform to active or inactive level.
   1498          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1499          *                    peripheral.
   1500          *                  - TIM_ForcedAction: specifies the forced Action to be set to
   1501          *                    the output waveform.
   1502          *                    This parameter can be one of the following values:
   1503          *                       - TIM_ForcedAction_Active: Force active level on OC4REF
   1504          *                       - TIM_ForcedAction_InActive: Force inactive level on
   1505          *                         OC4REF.
   1506          * Output         : None
   1507          * Return         : None
   1508          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1509          void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
   1510          {
   1511            u16 tmpccmr2 = 0;
   \                     TIM_ForcedOC4Config:
   \   00000000   0022               MOVS     R2,#+0
   1512          
   1513            /* Check the parameters */
   1514            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1515            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1516            tmpccmr2 = TIMx->CCMR2;
   \   00000002   838B               LDRH     R3,[R0, #+28]
   \   00000004   1A00               MOVS     R2,R3
   1517          
   1518            /* Reset the OC2M Bits */
   1519            tmpccmr2 &= CCMR_OC24M_Mask;
   \   00000006   48F6FF73           MOVW     R3,#+36863
   \   0000000A   1A40               ANDS     R2,R3,R2
   1520          
   1521            /* Configure The Forced output Mode */
   1522            tmpccmr2 |= (u16)(TIM_ForcedAction << 8);
   \   0000000C   52EA0122           ORRS     R2,R2,R1, LSL #+8
   1523          
   1524            /* Write to TIMx CCMR2 register */
   1525            TIMx->CCMR2 = tmpccmr2;
   \   00000010   8283               STRH     R2,[R0, #+28]
   1526          }
   \   00000012   7047               BX       LR               ;; return
   1527          
   1528          /*******************************************************************************
   1529          * Function Name  : TIM_ARRPreloadConfig
   1530          * Description    : Enables or disables TIMx peripheral Preload register on ARR.
   1531          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1532          *                    peripheral.
   1533          *                  - NewState: new state of the TIMx peripheral Preload register
   1534          *                    This parameter can be: ENABLE or DISABLE.
   1535          * Output         : None
   1536          * Return         : None
   1537          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1538          void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
   1539          {
   1540            /* Check the parameters */
   1541            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1542            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1543          
   1544            if (NewState != DISABLE)
   \                     TIM_ARRPreloadConfig:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??TIM_ARRPreloadConfig_0
   1545            {
   1546              /* Set the ARR Preload Bit */
   1547              TIMx->CR1 |= CR1_ARPE_Set;
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   51F08001           ORRS     R1,R1,#0x80
   \   0000000C   0180               STRH     R1,[R0, #+0]
   \   0000000E   04E0               B.N      ??TIM_ARRPreloadConfig_1
   1548            }
   1549            else
   1550            {
   1551              /* Reset the ARR Preload Bit */
   1552              TIMx->CR1 &= CR1_ARPE_Reset;
   \                     ??TIM_ARRPreloadConfig_0:
   \   00000010   0188               LDRH     R1,[R0, #+0]
   \   00000012   40F27F32           MOVW     R2,#+895
   \   00000016   1140               ANDS     R1,R2,R1
   \   00000018   0180               STRH     R1,[R0, #+0]
   1553            }
   1554          }
   \                     ??TIM_ARRPreloadConfig_1:
   \   0000001A   7047               BX       LR               ;; return
   1555          
   1556          /*******************************************************************************
   1557          * Function Name  : TIM_SelectCOM
   1558          * Description    : Selects the TIM peripheral Commutation event.
   1559          * Input          :- TIMx: where x can be  1 or 8 to select the TIMx peripheral
   1560          *                 - NewState: new state of the Commutation event.
   1561          *                    This parameter can be: ENABLE or DISABLE.
   1562          * Output         : None
   1563          * Return         : None
   1564          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1565          void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
   1566          {
   1567            /* Check the parameters */
   1568            assert_param(IS_TIM_18_PERIPH(TIMx));
   1569            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1570          
   1571            if (NewState != DISABLE)
   \                     TIM_SelectCOM:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??TIM_SelectCOM_0
   1572            {
   1573              /* Set the COM Bit */
   1574              TIMx->CR2 |= CR2_CCUS_Set;
   \   00000006   8188               LDRH     R1,[R0, #+4]
   \   00000008   51F00401           ORRS     R1,R1,#0x4
   \   0000000C   8180               STRH     R1,[R0, #+4]
   \   0000000E   03E0               B.N      ??TIM_SelectCOM_1
   1575            }
   1576            else
   1577            {
   1578              /* Reset the COM Bit */
   1579              TIMx->CR2 &= CR2_CCUS_Reset;
   \                     ??TIM_SelectCOM_0:
   \   00000010   8188               LDRH     R1,[R0, #+4]
   \   00000012   31F00401           BICS     R1,R1,#0x4
   \   00000016   8180               STRH     R1,[R0, #+4]
   1580            }
   1581          }
   \                     ??TIM_SelectCOM_1:
   \   00000018   7047               BX       LR               ;; return
   1582          
   1583          /*******************************************************************************
   1584          * Function Name  : TIM_SelectCCDMA
   1585          * Description    : Selects the TIMx peripheral Capture Compare DMA source.
   1586          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1587          *                    peripheral.
   1588          *                  - NewState: new state of the Capture Compare DMA source
   1589          *                    This parameter can be: ENABLE or DISABLE.
   1590          * Output         : None
   1591          * Return         : None
   1592          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1593          void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
   1594          {
   1595            /* Check the parameters */
   1596            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1597            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1598          
   1599            if (NewState != DISABLE)
   \                     TIM_SelectCCDMA:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??TIM_SelectCCDMA_0
   1600            {
   1601              /* Set the CCDS Bit */
   1602              TIMx->CR2 |= CR2_CCDS_Set;
   \   00000006   8188               LDRH     R1,[R0, #+4]
   \   00000008   51F00801           ORRS     R1,R1,#0x8
   \   0000000C   8180               STRH     R1,[R0, #+4]
   \   0000000E   03E0               B.N      ??TIM_SelectCCDMA_1
   1603            }
   1604            else
   1605            {
   1606              /* Reset the CCDS Bit */
   1607              TIMx->CR2 &= CR2_CCDS_Reset;
   \                     ??TIM_SelectCCDMA_0:
   \   00000010   8188               LDRH     R1,[R0, #+4]
   \   00000012   31F00801           BICS     R1,R1,#0x8
   \   00000016   8180               STRH     R1,[R0, #+4]
   1608            }
   1609          }
   \                     ??TIM_SelectCCDMA_1:
   \   00000018   7047               BX       LR               ;; return
   1610          
   1611          /*******************************************************************************
   1612          * Function Name  : TIM_CCPreloadControl
   1613          * Description    : Sets or Resets the TIM peripheral Capture Compare Preload 
   1614          *                  Control bit.
   1615          * Input          :- TIMx: where x can be  1 or 8 to select the TIMx peripheral
   1616          *                 - NewState: new state of the Capture Compare Preload Control bit
   1617          *                    This parameter can be: ENABLE or DISABLE.
   1618          * Output         : None
   1619          * Return         : None
   1620          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1621          void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
   1622          { 
   1623            /* Check the parameters */
   1624            assert_param(IS_TIM_18_PERIPH(TIMx));
   1625            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1626          
   1627            if (NewState != DISABLE)
   \                     TIM_CCPreloadControl:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??TIM_CCPreloadControl_0
   1628            {
   1629              /* Set the CCPC Bit */
   1630              TIMx->CR2 |= CR2_CCPC_Set;
   \   00000006   8188               LDRH     R1,[R0, #+4]
   \   00000008   51F00101           ORRS     R1,R1,#0x1
   \   0000000C   8180               STRH     R1,[R0, #+4]
   \   0000000E   03E0               B.N      ??TIM_CCPreloadControl_1
   1631            }
   1632            else
   1633            {
   1634              /* Reset the CCPC Bit */
   1635              TIMx->CR2 &= CR2_CCPC_Reset;
   \                     ??TIM_CCPreloadControl_0:
   \   00000010   8188               LDRH     R1,[R0, #+4]
   \   00000012   31F00101           BICS     R1,R1,#0x1
   \   00000016   8180               STRH     R1,[R0, #+4]
   1636            }
   1637          }
   \                     ??TIM_CCPreloadControl_1:
   \   00000018   7047               BX       LR               ;; return
   1638          
   1639          /*******************************************************************************
   1640          * Function Name  : TIM_OC1PreloadConfig
   1641          * Description    : Enables or disables the TIMx peripheral Preload register on CCR1.
   1642          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1643          *                    peripheral.
   1644          *                  - TIM_OCPreload: new state of the TIMx peripheral Preload
   1645          *                    register
   1646          *                    This parameter can be one of the following values:
   1647          *                       - TIM_OCPreload_Enable
   1648          *                       - TIM_OCPreload_Disable
   1649          * Output         : None
   1650          * Return         : None
   1651          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1652          void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
   1653          {
   1654            u16 tmpccmr1 = 0;
   \                     TIM_OC1PreloadConfig:
   \   00000000   0022               MOVS     R2,#+0
   1655          
   1656            /* Check the parameters */
   1657            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1658            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1659          
   1660            tmpccmr1 = TIMx->CCMR1;
   \   00000002   038B               LDRH     R3,[R0, #+24]
   \   00000004   1A00               MOVS     R2,R3
   1661          
   1662            /* Reset the OC1PE Bit */
   1663            tmpccmr1 &= CCMR_OC13PE_Reset;
   \   00000006   4FF6F773           MOVW     R3,#+65527
   \   0000000A   1A40               ANDS     R2,R3,R2
   1664          
   1665            /* Enable or Disable the Output Compare Preload feature */
   1666            tmpccmr1 |= TIM_OCPreload;
   \   0000000C   0A43               ORRS     R2,R1,R2
   1667          
   1668            /* Write to TIMx CCMR1 register */
   1669            TIMx->CCMR1 = tmpccmr1;
   \   0000000E   0283               STRH     R2,[R0, #+24]
   1670          }
   \   00000010   7047               BX       LR               ;; return
   1671          
   1672          /*******************************************************************************
   1673          * Function Name  : TIM_OC2PreloadConfig
   1674          * Description    : Enables or disables the TIMx peripheral Preload register on CCR2.
   1675          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1676          *                    peripheral.
   1677          *                  - TIM_OCPreload: new state of the TIMx peripheral Preload
   1678          *                    register
   1679          *                    This parameter can be one of the following values:
   1680          *                       - TIM_OCPreload_Enable
   1681          *                       - TIM_OCPreload_Disable
   1682          * Output         : None
   1683          * Return         : None
   1684          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1685          void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
   1686          {
   1687            u16 tmpccmr1 = 0;
   \                     TIM_OC2PreloadConfig:
   \   00000000   0022               MOVS     R2,#+0
   1688          
   1689            /* Check the parameters */
   1690            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1691            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1692          
   1693            tmpccmr1 = TIMx->CCMR1;
   \   00000002   038B               LDRH     R3,[R0, #+24]
   \   00000004   1A00               MOVS     R2,R3
   1694          
   1695            /* Reset the OC2PE Bit */
   1696            tmpccmr1 &= CCMR_OC24PE_Reset;
   \   00000006   4FF2FF73           MOVW     R3,#+63487
   \   0000000A   1A40               ANDS     R2,R3,R2
   1697          
   1698            /* Enable or Disable the Output Compare Preload feature */
   1699            tmpccmr1 |= (u16)(TIM_OCPreload << 8);
   \   0000000C   52EA0122           ORRS     R2,R2,R1, LSL #+8
   1700          
   1701            /* Write to TIMx CCMR1 register */
   1702            TIMx->CCMR1 = tmpccmr1;
   \   00000010   0283               STRH     R2,[R0, #+24]
   1703          }
   \   00000012   7047               BX       LR               ;; return
   1704          
   1705          /*******************************************************************************
   1706          * Function Name  : TIM_OC3PreloadConfig
   1707          * Description    : Enables or disables the TIMx peripheral Preload register on CCR3.
   1708          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1709          *                    peripheral.
   1710          *                  - TIM_OCPreload: new state of the TIMx peripheral Preload
   1711          *                    register
   1712          *                    This parameter can be one of the following values:
   1713          *                       - TIM_OCPreload_Enable
   1714          *                       - TIM_OCPreload_Disable
   1715          * Output         : None
   1716          * Return         : None
   1717          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1718          void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
   1719          {
   1720            u16 tmpccmr2 = 0;
   \                     TIM_OC3PreloadConfig:
   \   00000000   0022               MOVS     R2,#+0
   1721          
   1722            /* Check the parameters */
   1723            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1724            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1725          
   1726            tmpccmr2 = TIMx->CCMR2;
   \   00000002   838B               LDRH     R3,[R0, #+28]
   \   00000004   1A00               MOVS     R2,R3
   1727          
   1728            /* Reset the OC3PE Bit */
   1729            tmpccmr2 &= CCMR_OC13PE_Reset;
   \   00000006   4FF6F773           MOVW     R3,#+65527
   \   0000000A   1A40               ANDS     R2,R3,R2
   1730          
   1731            /* Enable or Disable the Output Compare Preload feature */
   1732            tmpccmr2 |= TIM_OCPreload;
   \   0000000C   0A43               ORRS     R2,R1,R2
   1733          
   1734            /* Write to TIMx CCMR2 register */
   1735            TIMx->CCMR2 = tmpccmr2;
   \   0000000E   8283               STRH     R2,[R0, #+28]
   1736          }
   \   00000010   7047               BX       LR               ;; return
   1737          
   1738          /*******************************************************************************
   1739          * Function Name  : TIM_OC4PreloadConfig
   1740          * Description    : Enables or disables the TIMx peripheral Preload register on CCR4.
   1741          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1742          *                    peripheral.
   1743          *                  - TIM_OCPreload: new state of the TIMx peripheral Preload
   1744          *                    register
   1745          *                    This parameter can be one of the following values:
   1746          *                       - TIM_OCPreload_Enable
   1747          *                       - TIM_OCPreload_Disable
   1748          * Output         : None
   1749          * Return         : None
   1750          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1751          void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
   1752          {
   1753            u16 tmpccmr2 = 0;
   \                     TIM_OC4PreloadConfig:
   \   00000000   0022               MOVS     R2,#+0
   1754          
   1755            /* Check the parameters */
   1756            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1757            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1758          
   1759            tmpccmr2 = TIMx->CCMR2;
   \   00000002   838B               LDRH     R3,[R0, #+28]
   \   00000004   1A00               MOVS     R2,R3
   1760          
   1761            /* Reset the OC4PE Bit */
   1762            tmpccmr2 &= CCMR_OC24PE_Reset;
   \   00000006   4FF2FF73           MOVW     R3,#+63487
   \   0000000A   1A40               ANDS     R2,R3,R2
   1763          
   1764            /* Enable or Disable the Output Compare Preload feature */
   1765            tmpccmr2 |= (u16)(TIM_OCPreload << 8);
   \   0000000C   52EA0122           ORRS     R2,R2,R1, LSL #+8
   1766          
   1767            /* Write to TIMx CCMR2 register */
   1768            TIMx->CCMR2 = tmpccmr2;
   \   00000010   8283               STRH     R2,[R0, #+28]
   1769          }
   \   00000012   7047               BX       LR               ;; return
   1770          
   1771          /*******************************************************************************
   1772          * Function Name  : TIM_OC1FastConfig
   1773          * Description    : Configures the TIMx Output Compare 1 Fast feature.
   1774          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1775          *                    peripheral.
   1776          *                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1777          *                    This parameter can be one of the following values:
   1778          *                       - TIM_OCFast_Enable: TIM output compare fast enable
   1779          *                       - TIM_OCFast_Disable: TIM output compare fast disable
   1780          * Output         : None
   1781          * Return         : None
   1782          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1783          void TIM_OC1FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
   1784          {
   1785            u16 tmpccmr1 = 0;
   \                     TIM_OC1FastConfig:
   \   00000000   0022               MOVS     R2,#+0
   1786          
   1787            /* Check the parameters */
   1788            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1789            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1790          
   1791            /* Get the TIMx CCMR1 register value */
   1792            tmpccmr1 = TIMx->CCMR1;
   \   00000002   038B               LDRH     R3,[R0, #+24]
   \   00000004   1A00               MOVS     R2,R3
   1793          
   1794            /* Reset the OC1FE Bit */
   1795            tmpccmr1 &= CCMR_OC13FE_Reset;
   \   00000006   4FF6FB73           MOVW     R3,#+65531
   \   0000000A   1A40               ANDS     R2,R3,R2
   1796          
   1797            /* Enable or Disable the Output Compare Fast Bit */
   1798            tmpccmr1 |= TIM_OCFast;
   \   0000000C   0A43               ORRS     R2,R1,R2
   1799          
   1800            /* Write to TIMx CCMR1 */
   1801            TIMx->CCMR1 = tmpccmr1;
   \   0000000E   0283               STRH     R2,[R0, #+24]
   1802          }
   \   00000010   7047               BX       LR               ;; return
   1803          
   1804          /*******************************************************************************
   1805          * Function Name  : TIM_OC2FastConfig
   1806          * Description    : Configures the TIMx Output Compare 2 Fast feature.
   1807          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1808          *                    peripheral.
   1809          *                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1810          *                    This parameter can be one of the following values:
   1811          *                       - TIM_OCFast_Enable: TIM output compare fast enable
   1812          *                       - TIM_OCFast_Disable: TIM output compare fast disable
   1813          * Output         : None
   1814          * Return         : None
   1815          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1816          void TIM_OC2FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
   1817          {
   1818            u16 tmpccmr1 = 0;
   \                     TIM_OC2FastConfig:
   \   00000000   0022               MOVS     R2,#+0
   1819          
   1820            /* Check the parameters */
   1821            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1822            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1823          
   1824            /* Get the TIMx CCMR1 register value */
   1825            tmpccmr1 = TIMx->CCMR1;
   \   00000002   038B               LDRH     R3,[R0, #+24]
   \   00000004   1A00               MOVS     R2,R3
   1826          
   1827            /* Reset the OC2FE Bit */
   1828            tmpccmr1 &= CCMR_OC24FE_Reset;
   \   00000006   4FF6FF33           MOVW     R3,#+64511
   \   0000000A   1A40               ANDS     R2,R3,R2
   1829          
   1830            /* Enable or Disable the Output Compare Fast Bit */
   1831            tmpccmr1 |= (u16)(TIM_OCFast << 8);
   \   0000000C   52EA0122           ORRS     R2,R2,R1, LSL #+8
   1832          
   1833            /* Write to TIMx CCMR1 */
   1834            TIMx->CCMR1 = tmpccmr1;
   \   00000010   0283               STRH     R2,[R0, #+24]
   1835          }
   \   00000012   7047               BX       LR               ;; return
   1836          
   1837          /*******************************************************************************
   1838          * Function Name  : TIM_OC3FastConfig
   1839          * Description    : Configures the TIMx Output Compare 3 Fast feature.
   1840          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1841          *                    peripheral.
   1842          *                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1843          *                    This parameter can be one of the following values:
   1844          *                       - TIM_OCFast_Enable: TIM output compare fast enable
   1845          *                       - TIM_OCFast_Disable: TIM output compare fast disable
   1846          * Output         : None
   1847          * Return         : None
   1848          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1849          void TIM_OC3FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
   1850          {
   1851            u16 tmpccmr2 = 0;
   \                     TIM_OC3FastConfig:
   \   00000000   0022               MOVS     R2,#+0
   1852          
   1853            /* Check the parameters */
   1854            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1855            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1856          
   1857            /* Get the TIMx CCMR2 register value */
   1858            tmpccmr2 = TIMx->CCMR2;
   \   00000002   838B               LDRH     R3,[R0, #+28]
   \   00000004   1A00               MOVS     R2,R3
   1859          
   1860            /* Reset the OC3FE Bit */
   1861            tmpccmr2 &= CCMR_OC13FE_Reset;
   \   00000006   4FF6FB73           MOVW     R3,#+65531
   \   0000000A   1A40               ANDS     R2,R3,R2
   1862          
   1863            /* Enable or Disable the Output Compare Fast Bit */
   1864            tmpccmr2 |= TIM_OCFast;
   \   0000000C   0A43               ORRS     R2,R1,R2
   1865          
   1866            /* Write to TIMx CCMR2 */
   1867            TIMx->CCMR2 = tmpccmr2;
   \   0000000E   8283               STRH     R2,[R0, #+28]
   1868          }
   \   00000010   7047               BX       LR               ;; return
   1869          
   1870          /*******************************************************************************
   1871          * Function Name  : TIM_OC4FastConfig
   1872          * Description    : Configures the TIMx Output Compare 4 Fast feature.
   1873          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1874          *                    peripheral.
   1875          *                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1876          *                    This parameter can be one of the following values:
   1877          *                       - TIM_OCFast_Enable: TIM output compare fast enable
   1878          *                       - TIM_OCFast_Disable: TIM output compare fast disable
   1879          * Output         : None
   1880          * Return         : None
   1881          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1882          void TIM_OC4FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
   1883          {
   1884            u16 tmpccmr2 = 0;
   \                     TIM_OC4FastConfig:
   \   00000000   0022               MOVS     R2,#+0
   1885          
   1886            /* Check the parameters */
   1887            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1888            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1889          
   1890            /* Get the TIMx CCMR2 register value */
   1891            tmpccmr2 = TIMx->CCMR2;
   \   00000002   838B               LDRH     R3,[R0, #+28]
   \   00000004   1A00               MOVS     R2,R3
   1892          
   1893            /* Reset the OC4FE Bit */
   1894            tmpccmr2 &= CCMR_OC24FE_Reset;
   \   00000006   4FF6FF33           MOVW     R3,#+64511
   \   0000000A   1A40               ANDS     R2,R3,R2
   1895          
   1896            /* Enable or Disable the Output Compare Fast Bit */
   1897            tmpccmr2 |= (u16)(TIM_OCFast << 8);
   \   0000000C   52EA0122           ORRS     R2,R2,R1, LSL #+8
   1898          
   1899            /* Write to TIMx CCMR2 */
   1900            TIMx->CCMR2 = tmpccmr2;
   \   00000010   8283               STRH     R2,[R0, #+28]
   1901          }
   \   00000012   7047               BX       LR               ;; return
   1902          
   1903          /*******************************************************************************
   1904          * Function Name  : TIM_ClearOC1Ref
   1905          * Description    : Clears or safeguards the OCREF1 signal on an external event
   1906          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1907          *                    peripheral.
   1908          *                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1909          *                    This parameter can be one of the following values:
   1910          *                       - TIM_OCClear_Enable: TIM Output clear enable
   1911          *                       - TIM_OCClear_Disable: TIM Output clear disable
   1912          * Output         : None
   1913          * Return         : None
   1914          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1915          void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
   1916          {
   1917            u16 tmpccmr1 = 0;
   \                     TIM_ClearOC1Ref:
   \   00000000   0022               MOVS     R2,#+0
   1918          
   1919            /* Check the parameters */
   1920            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1921            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1922          
   1923            tmpccmr1 = TIMx->CCMR1;
   \   00000002   038B               LDRH     R3,[R0, #+24]
   \   00000004   1A00               MOVS     R2,R3
   1924          
   1925            /* Reset the OC1CE Bit */
   1926            tmpccmr1 &= CCMR_OC13CE_Reset;
   \   00000006   4FF67F73           MOVW     R3,#+65407
   \   0000000A   1A40               ANDS     R2,R3,R2
   1927          
   1928            /* Enable or Disable the Output Compare Clear Bit */
   1929            tmpccmr1 |= TIM_OCClear;
   \   0000000C   0A43               ORRS     R2,R1,R2
   1930          
   1931            /* Write to TIMx CCMR1 register */
   1932            TIMx->CCMR1 = tmpccmr1;
   \   0000000E   0283               STRH     R2,[R0, #+24]
   1933          }
   \   00000010   7047               BX       LR               ;; return
   1934          
   1935          /*******************************************************************************
   1936          * Function Name  : TIM_ClearOC2Ref
   1937          * Description    : Clears or safeguards the OCREF2 signal on an external event
   1938          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1939          *                    peripheral.
   1940          *                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1941          *                    This parameter can be one of the following values:
   1942          *                       - TIM_OCClear_Enable: TIM Output clear enable
   1943          *                       - TIM_OCClear_Disable: TIM Output clear disable
   1944          * Output         : None
   1945          * Return         : None
   1946          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1947          void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
   1948          {
   1949            u16 tmpccmr1 = 0;
   \                     TIM_ClearOC2Ref:
   \   00000000   0022               MOVS     R2,#+0
   1950          
   1951            /* Check the parameters */
   1952            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1953            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1954          
   1955            tmpccmr1 = TIMx->CCMR1;
   \   00000002   038B               LDRH     R3,[R0, #+24]
   \   00000004   1A00               MOVS     R2,R3
   1956          
   1957            /* Reset the OC2CE Bit */
   1958            tmpccmr1 &= CCMR_OC24CE_Reset;
   \   00000006   5204               LSLS     R2,R2,#+17
   \   00000008   520C               LSRS     R2,R2,#+17
   1959          
   1960            /* Enable or Disable the Output Compare Clear Bit */
   1961            tmpccmr1 |= (u16)(TIM_OCClear << 8);
   \   0000000A   52EA0122           ORRS     R2,R2,R1, LSL #+8
   1962          
   1963            /* Write to TIMx CCMR1 register */
   1964            TIMx->CCMR1 = tmpccmr1;
   \   0000000E   0283               STRH     R2,[R0, #+24]
   1965          }
   \   00000010   7047               BX       LR               ;; return
   1966          
   1967          /*******************************************************************************
   1968          * Function Name  : TIM_ClearOC3Ref
   1969          * Description    : Clears or safeguards the OCREF3 signal on an external event
   1970          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1971          *                    peripheral.
   1972          *                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1973          *                    This parameter can be one of the following values:
   1974          *                       - TIM_OCClear_Enable: TIM Output clear enable
   1975          *                       - TIM_OCClear_Disable: TIM Output clear disable
   1976          * Output         : None
   1977          * Return         : None
   1978          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1979          void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
   1980          {
   1981            u16 tmpccmr2 = 0;
   \                     TIM_ClearOC3Ref:
   \   00000000   0022               MOVS     R2,#+0
   1982          
   1983            /* Check the parameters */
   1984            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1985            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1986          
   1987            tmpccmr2 = TIMx->CCMR2;
   \   00000002   838B               LDRH     R3,[R0, #+28]
   \   00000004   1A00               MOVS     R2,R3
   1988          
   1989            /* Reset the OC3CE Bit */
   1990            tmpccmr2 &= CCMR_OC13CE_Reset;
   \   00000006   4FF67F73           MOVW     R3,#+65407
   \   0000000A   1A40               ANDS     R2,R3,R2
   1991          
   1992            /* Enable or Disable the Output Compare Clear Bit */
   1993            tmpccmr2 |= TIM_OCClear;
   \   0000000C   0A43               ORRS     R2,R1,R2
   1994          
   1995            /* Write to TIMx CCMR2 register */
   1996            TIMx->CCMR2 = tmpccmr2;
   \   0000000E   8283               STRH     R2,[R0, #+28]
   1997          }
   \   00000010   7047               BX       LR               ;; return
   1998          
   1999          /*******************************************************************************
   2000          * Function Name  : TIM_ClearOC4Ref
   2001          * Description    : Clears or safeguards the OCREF4 signal on an external event
   2002          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   2003          *                    peripheral.
   2004          *                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   2005          *                    This parameter can be one of the following values:
   2006          *                       - TIM_OCClear_Enable: TIM Output clear enable
   2007          *                       - TIM_OCClear_Disable: TIM Output clear disable
   2008          * Output         : None
   2009          * Return         : None
   2010          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2011          void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
   2012          {
   2013            u16 tmpccmr2 = 0;
   \                     TIM_ClearOC4Ref:
   \   00000000   0022               MOVS     R2,#+0
   2014          
   2015            /* Check the parameters */
   2016            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2017            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   2018          
   2019            tmpccmr2 = TIMx->CCMR2;
   \   00000002   838B               LDRH     R3,[R0, #+28]
   \   00000004   1A00               MOVS     R2,R3
   2020          
   2021            /* Reset the OC4CE Bit */
   2022            tmpccmr2 &= CCMR_OC24CE_Reset;
   \   00000006   5204               LSLS     R2,R2,#+17
   \   00000008   520C               LSRS     R2,R2,#+17
   2023          
   2024            /* Enable or Disable the Output Compare Clear Bit */
   2025            tmpccmr2 |= (u16)(TIM_OCClear << 8);
   \   0000000A   52EA0122           ORRS     R2,R2,R1, LSL #+8
   2026          
   2027            /* Write to TIMx CCMR2 register */
   2028            TIMx->CCMR2 = tmpccmr2;
   \   0000000E   8283               STRH     R2,[R0, #+28]
   2029          }
   \   00000010   7047               BX       LR               ;; return
   2030          
   2031          /*******************************************************************************
   2032          * Function Name  : TIM_OC1PolarityConfig
   2033          * Description    : Configures the TIMx channel 1 polarity.
   2034          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2035          *                    peripheral.
   2036          *                  - TIM_OCPolarity: specifies the OC1 Polarity
   2037          *                    This parmeter can be one of the following values:
   2038          *                       - TIM_OCPolarity_High: Output Compare active high
   2039          *                       - TIM_OCPolarity_Low: Output Compare active low
   2040          * Output         : None
   2041          * Return         : None
   2042          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2043          void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
   2044          {
   2045            u16 tmpccer = 0;
   \                     TIM_OC1PolarityConfig:
   \   00000000   0022               MOVS     R2,#+0
   2046          
   2047            /* Check the parameters */
   2048            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2049            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   2050          
   2051            tmpccer = TIMx->CCER;
   \   00000002   038C               LDRH     R3,[R0, #+32]
   \   00000004   1A00               MOVS     R2,R3
   2052          
   2053            /* Set or Reset the CC1P Bit */
   2054            tmpccer &= CCER_CC1P_Reset;
   \   00000006   4FF6FD73           MOVW     R3,#+65533
   \   0000000A   1A40               ANDS     R2,R3,R2
   2055            tmpccer |= TIM_OCPolarity;
   \   0000000C   0A43               ORRS     R2,R1,R2
   2056          
   2057            /* Write to TIMx CCER register */
   2058            TIMx->CCER = tmpccer;
   \   0000000E   0284               STRH     R2,[R0, #+32]
   2059          }
   \   00000010   7047               BX       LR               ;; return
   2060          
   2061          /*******************************************************************************
   2062          * Function Name  : TIM_OC1NPolarityConfig
   2063          * Description    : Configures the TIMx Channel 1N polarity.
   2064          * Input          : - TIMx: where x can be 1 or 8 to select the TIM peripheral.
   2065          *                  - TIM_OCNPolarity: specifies the OC1N Polarity
   2066          *                    This parmeter can be one of the following values:
   2067          *                       - TIM_OCNPolarity_High: Output Compare active high
   2068          *                       - TIM_OCNPolarity_Low: Output Compare active low
   2069          * Output         : None
   2070          * Return         : None
   2071          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2072          void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
   2073          {
   2074            u16 tmpccer = 0;
   \                     TIM_OC1NPolarityConfig:
   \   00000000   0022               MOVS     R2,#+0
   2075          
   2076            /* Check the parameters */
   2077            assert_param(IS_TIM_18_PERIPH(TIMx));
   2078            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   2079             
   2080            tmpccer = TIMx->CCER;
   \   00000002   038C               LDRH     R3,[R0, #+32]
   \   00000004   1A00               MOVS     R2,R3
   2081          
   2082            /* Set or Reset the CC1NP Bit */
   2083            tmpccer &= CCER_CC1NP_Reset;
   \   00000006   4FF6F773           MOVW     R3,#+65527
   \   0000000A   1A40               ANDS     R2,R3,R2
   2084            tmpccer |= TIM_OCNPolarity;
   \   0000000C   0A43               ORRS     R2,R1,R2
   2085          
   2086            /* Write to TIMx CCER register */
   2087            TIMx->CCER = tmpccer;
   \   0000000E   0284               STRH     R2,[R0, #+32]
   2088          }
   \   00000010   7047               BX       LR               ;; return
   2089          
   2090          /*******************************************************************************
   2091          * Function Name  : TIM_OC2PolarityConfig
   2092          * Description    : Configures the TIMx channel 2 polarity.
   2093          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2094          *                    peripheral.
   2095          *                  - TIM_OCPolarity: specifies the OC2 Polarity
   2096          *                    This parmeter can be one of the following values:
   2097          *                       - TIM_OCPolarity_High: Output Compare active high
   2098          *                       - TIM_OCPolarity_Low: Output Compare active low
   2099          * Output         : None
   2100          * Return         : None
   2101          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2102          void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
   2103          {
   2104            u16 tmpccer = 0;
   \                     TIM_OC2PolarityConfig:
   \   00000000   0022               MOVS     R2,#+0
   2105          
   2106            /* Check the parameters */
   2107            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2108            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   2109          
   2110            tmpccer = TIMx->CCER;
   \   00000002   038C               LDRH     R3,[R0, #+32]
   \   00000004   1A00               MOVS     R2,R3
   2111          
   2112            /* Set or Reset the CC2P Bit */
   2113            tmpccer &= CCER_CC2P_Reset;
   \   00000006   4FF6DF73           MOVW     R3,#+65503
   \   0000000A   1A40               ANDS     R2,R3,R2
   2114            tmpccer |= (u16)(TIM_OCPolarity << 4);
   \   0000000C   52EA0112           ORRS     R2,R2,R1, LSL #+4
   2115          
   2116            /* Write to TIMx CCER register */
   2117            TIMx->CCER = tmpccer;
   \   00000010   0284               STRH     R2,[R0, #+32]
   2118          }
   \   00000012   7047               BX       LR               ;; return
   2119          
   2120          /*******************************************************************************
   2121          * Function Name  : TIM_OC2NPolarityConfig
   2122          * Description    : Configures the TIMx Channel 2N polarity.
   2123          * Input          : - TIMx: where x can be 1 or 8 to select the TIM peripheral.
   2124          *                  - TIM_OCNPolarity: specifies the OC2N Polarity
   2125          *                    This parmeter can be one of the following values:
   2126          *                       - TIM_OCNPolarity_High: Output Compare active high
   2127          *                       - TIM_OCNPolarity_Low: Output Compare active low
   2128          * Output         : None
   2129          * Return         : None
   2130          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2131          void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
   2132          {
   2133            u16 tmpccer = 0;
   \                     TIM_OC2NPolarityConfig:
   \   00000000   0022               MOVS     R2,#+0
   2134          
   2135            /* Check the parameters */
   2136            assert_param(IS_TIM_18_PERIPH(TIMx));
   2137            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   2138            
   2139            tmpccer = TIMx->CCER;
   \   00000002   038C               LDRH     R3,[R0, #+32]
   \   00000004   1A00               MOVS     R2,R3
   2140          
   2141            /* Set or Reset the CC2NP Bit */
   2142            tmpccer &= CCER_CC2NP_Reset;
   \   00000006   4FF67F73           MOVW     R3,#+65407
   \   0000000A   1A40               ANDS     R2,R3,R2
   2143            tmpccer |= (u16)(TIM_OCNPolarity << 4);
   \   0000000C   52EA0112           ORRS     R2,R2,R1, LSL #+4
   2144          
   2145            /* Write to TIMx CCER register */
   2146            TIMx->CCER = tmpccer;
   \   00000010   0284               STRH     R2,[R0, #+32]
   2147          }
   \   00000012   7047               BX       LR               ;; return
   2148          
   2149          /*******************************************************************************
   2150          * Function Name  : TIM_OC3PolarityConfig
   2151          * Description    : Configures the TIMx channel 3 polarity.
   2152          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2153          *                    peripheral.
   2154          *                  - TIM_OCPolarity: specifies the OC3 Polarity
   2155          *                    This parmeter can be one of the following values:
   2156          *                       - TIM_OCPolarity_High: Output Compare active high
   2157          *                       - TIM_OCPolarity_Low: Output Compare active low
   2158          * Output         : None
   2159          * Return         : None
   2160          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2161          void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
   2162          {
   2163            u16 tmpccer = 0;
   \                     TIM_OC3PolarityConfig:
   \   00000000   0022               MOVS     R2,#+0
   2164          
   2165            /* Check the parameters */
   2166            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2167            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   2168          
   2169            tmpccer = TIMx->CCER;
   \   00000002   038C               LDRH     R3,[R0, #+32]
   \   00000004   1A00               MOVS     R2,R3
   2170          
   2171            /* Set or Reset the CC3P Bit */
   2172            tmpccer &= CCER_CC3P_Reset;
   \   00000006   4FF6FF53           MOVW     R3,#+65023
   \   0000000A   1A40               ANDS     R2,R3,R2
   2173            tmpccer |= (u16)(TIM_OCPolarity << 8);
   \   0000000C   52EA0122           ORRS     R2,R2,R1, LSL #+8
   2174          
   2175            /* Write to TIMx CCER register */
   2176            TIMx->CCER = tmpccer;
   \   00000010   0284               STRH     R2,[R0, #+32]
   2177          }
   \   00000012   7047               BX       LR               ;; return
   2178          
   2179          /*******************************************************************************
   2180          * Function Name  : TIM_OC3NPolarityConfig
   2181          * Description    : Configures the TIMx Channel 3N polarity.
   2182          * Input          : - TIMx: where x can be 1 or 8 to select the TIM peripheral.
   2183          *                  - TIM_OCNPolarity: specifies the OC3N Polarity
   2184          *                    This parmeter can be one of the following values:
   2185          *                       - TIM_OCNPolarity_High: Output Compare active high
   2186          *                       - TIM_OCNPolarity_Low: Output Compare active low
   2187          * Output         : None
   2188          * Return         : None
   2189          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2190          void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
   2191          {
   2192            u16 tmpccer = 0;
   \                     TIM_OC3NPolarityConfig:
   \   00000000   0022               MOVS     R2,#+0
   2193           
   2194            /* Check the parameters */
   2195            assert_param(IS_TIM_18_PERIPH(TIMx));
   2196            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   2197              
   2198            tmpccer = TIMx->CCER;
   \   00000002   038C               LDRH     R3,[R0, #+32]
   \   00000004   1A00               MOVS     R2,R3
   2199          
   2200            /* Set or Reset the CC3NP Bit */
   2201            tmpccer &= CCER_CC3NP_Reset;
   \   00000006   4FF2FF73           MOVW     R3,#+63487
   \   0000000A   1A40               ANDS     R2,R3,R2
   2202            tmpccer |= (u16)(TIM_OCNPolarity << 8);
   \   0000000C   52EA0122           ORRS     R2,R2,R1, LSL #+8
   2203          
   2204            /* Write to TIMx CCER register */
   2205            TIMx->CCER = tmpccer;
   \   00000010   0284               STRH     R2,[R0, #+32]
   2206          }
   \   00000012   7047               BX       LR               ;; return
   2207          
   2208          /*******************************************************************************
   2209          * Function Name  : TIM_OC4PolarityConfig
   2210          * Description    : Configures the TIMx channel 4 polarity.
   2211          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2212          *                    peripheral.
   2213          *                  - TIM_OCPolarity: specifies the OC4 Polarity
   2214          *                    This parmeter can be one of the following values:
   2215          *                       - TIM_OCPolarity_High: Output Compare active high
   2216          *                       - TIM_OCPolarity_Low: Output Compare active low
   2217          * Output         : None
   2218          * Return         : None
   2219          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2220          void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
   2221          {
   2222            u16 tmpccer = 0;
   \                     TIM_OC4PolarityConfig:
   \   00000000   0022               MOVS     R2,#+0
   2223          
   2224            /* Check the parameters */
   2225            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2226            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   2227          
   2228            tmpccer = TIMx->CCER;
   \   00000002   038C               LDRH     R3,[R0, #+32]
   \   00000004   1A00               MOVS     R2,R3
   2229          
   2230            /* Set or Reset the CC4P Bit */
   2231            tmpccer &= CCER_CC4P_Reset;
   \   00000006   4DF6FF73           MOVW     R3,#+57343
   \   0000000A   1A40               ANDS     R2,R3,R2
   2232            tmpccer |= (u16)(TIM_OCPolarity << 12);
   \   0000000C   52EA0132           ORRS     R2,R2,R1, LSL #+12
   2233          
   2234            /* Write to TIMx CCER register */
   2235            TIMx->CCER = tmpccer;
   \   00000010   0284               STRH     R2,[R0, #+32]
   2236          }
   \   00000012   7047               BX       LR               ;; return
   2237          
   2238          /*******************************************************************************
   2239          * Function Name  : TIM_CCxCmd
   2240          * Description    : Enables or disables the TIM Capture Compare Channel x.
   2241          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM
   2242          *                    peripheral.
   2243          *                  - TIM_Channel: specifies the TIM Channel
   2244          *                    This parmeter can be one of the following values:
   2245          *                       - TIM_Channel_1: TIM Channel 1
   2246          *                       - TIM_Channel_2: TIM Channel 2
   2247          *                       - TIM_Channel_3: TIM Channel 3
   2248          *                       - TIM_Channel_4: TIM Channel 4
   2249          *                 - TIM_CCx: specifies the TIM Channel CCxE bit new state.
   2250          *                   This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
   2251          * Output         : None
   2252          * Return         : None
   2253          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2254          void TIM_CCxCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCx)
   2255          {
   \                     TIM_CCxCmd:
   \   00000000   30B4               PUSH     {R4,R5}
   2256            /* Check the parameters */
   2257            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2258            assert_param(IS_TIM_CHANNEL(TIM_Channel));
   2259            assert_param(IS_TIM_CCX(TIM_CCx));
   2260          
   2261            /* Reset the CCxE Bit */
   2262            TIMx->CCER &= (u16)(~((u16)(CCER_CCE_Set << TIM_Channel)));
   \   00000002   038C               LDRH     R3,[R0, #+32]
   \   00000004   0124               MOVS     R4,#+1
   \   00000006   0D00               MOVS     R5,R1
   \   00000008   AC40               LSLS     R4,R4,R5
   \   0000000A   E443               MVNS     R4,R4
   \   0000000C   2340               ANDS     R3,R4,R3
   \   0000000E   0384               STRH     R3,[R0, #+32]
   2263          
   2264            /* Set or reset the CCxE Bit */ 
   2265            TIMx->CCER |=  (u16)(TIM_CCx << TIM_Channel);
   \   00000010   038C               LDRH     R3,[R0, #+32]
   \   00000012   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000014   12FA01F1           LSLS     R1,R2,R1
   \   00000018   1943               ORRS     R1,R1,R3
   \   0000001A   0184               STRH     R1,[R0, #+32]
   2266          }
   \   0000001C   30BC               POP      {R4,R5}
   \   0000001E   7047               BX       LR               ;; return
   2267          
   2268          /*******************************************************************************
   2269          * Function Name  : TIM_CCxNCmd
   2270          * Description    : Enables or disables the TIM Capture Compare Channel xN.
   2271          * Input          :- TIMx: where x can be 1 or 8 to select the TIM peripheral.
   2272          *                 - TIM_Channel: specifies the TIM Channel
   2273          *                    This parmeter can be one of the following values:
   2274          *                       - TIM_Channel_1: TIM Channel 1
   2275          *                       - TIM_Channel_2: TIM Channel 2
   2276          *                       - TIM_Channel_3: TIM Channel 3
   2277          *                 - TIM_CCx: specifies the TIM Channel CCxNE bit new state.
   2278          *                   This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
   2279          * Output         : None
   2280          * Return         : None
   2281          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2282          void TIM_CCxNCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCxN)
   2283          {
   \                     TIM_CCxNCmd:
   \   00000000   30B4               PUSH     {R4,R5}
   2284            /* Check the parameters */
   2285            assert_param(IS_TIM_18_PERIPH(TIMx));
   2286            assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
   2287            assert_param(IS_TIM_CCXN(TIM_CCxN));
   2288          
   2289            /* Reset the CCxNE Bit */
   2290            TIMx->CCER &= (u16)(~((u16)(CCER_CCNE_Set << TIM_Channel)));
   \   00000002   038C               LDRH     R3,[R0, #+32]
   \   00000004   0424               MOVS     R4,#+4
   \   00000006   0D00               MOVS     R5,R1
   \   00000008   AC40               LSLS     R4,R4,R5
   \   0000000A   E443               MVNS     R4,R4
   \   0000000C   2340               ANDS     R3,R4,R3
   \   0000000E   0384               STRH     R3,[R0, #+32]
   2291          
   2292            /* Set or reset the CCxNE Bit */ 
   2293            TIMx->CCER |=  (u16)(TIM_CCxN << TIM_Channel);
   \   00000010   038C               LDRH     R3,[R0, #+32]
   \   00000012   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000014   12FA01F1           LSLS     R1,R2,R1
   \   00000018   1943               ORRS     R1,R1,R3
   \   0000001A   0184               STRH     R1,[R0, #+32]
   2294          }
   \   0000001C   30BC               POP      {R4,R5}
   \   0000001E   7047               BX       LR               ;; return
   2295          
   2296          /*******************************************************************************
   2297          * Function Name  : TIM_SelectOCxM
   2298          * Description    : Selects the TIM Ouput Compare Mode.
   2299          *                  This function disables the selected channel before changing 
   2300          *                  the Ouput Compare Mode. User has to enable this channel using
   2301          *                  TIM_CCxCmd and TIM_CCxNCmd functions.
   2302          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM
   2303          *                    peripheral.
   2304          *                  - TIM_Channel: specifies the TIM Channel
   2305          *                    This parmeter can be one of the following values:
   2306          *                       - TIM_Channel_1: TIM Channel 1
   2307          *                       - TIM_Channel_2: TIM Channel 2
   2308          *                       - TIM_Channel_3: TIM Channel 3
   2309          *                       - TIM_Channel_4: TIM Channel 4
   2310          *                  - TIM_OCMode: specifies the TIM Output Compare Mode.
   2311          *                    This paramter can be one of the following values:
   2312          *                       - TIM_OCMode_Timing
   2313          *                       - TIM_OCMode_Active
   2314          *                       - TIM_OCMode_Toggle
   2315          *                       - TIM_OCMode_PWM1
   2316          *                       - TIM_OCMode_PWM2
   2317          *                       - TIM_ForcedAction_Active
   2318          *                       - TIM_ForcedAction_InActive
   2319          * Output         : None
   2320          * Return         : None
   2321          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2322          void TIM_SelectOCxM(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_OCMode)
   2323          {
   \                     TIM_SelectOCxM:
   \   00000000   30B4               PUSH     {R4,R5}
   2324            /* Check the parameters */
   2325            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2326            assert_param(IS_TIM_CHANNEL(TIM_Channel));
   2327            assert_param(IS_TIM_OCM(TIM_OCMode));
   2328            
   2329            /* Disable the Channel: Reset the CCxE Bit */
   2330            TIMx->CCER &= (u16)(~((u16)(CCER_CCE_Set << TIM_Channel)));
   \   00000002   038C               LDRH     R3,[R0, #+32]
   \   00000004   0124               MOVS     R4,#+1
   \   00000006   0D00               MOVS     R5,R1
   \   00000008   AC40               LSLS     R4,R4,R5
   \   0000000A   E443               MVNS     R4,R4
   \   0000000C   2340               ANDS     R3,R4,R3
   \   0000000E   0384               STRH     R3,[R0, #+32]
   2331          
   2332            if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
   \   00000010   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000012   0029               CMP      R1,#+0
   \   00000014   02D0               BEQ.N    ??TIM_SelectOCxM_0
   \   00000016   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000018   0829               CMP      R1,#+8
   \   0000001A   10D1               BNE.N    ??TIM_SelectOCxM_1
   2333            {
   2334              /* Reset the OCxM bits in the CCMRx register */
   2335              *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + (TIM_Channel>>1))) &= CCMR_OC13M_Mask;
   \                     ??TIM_SelectOCxM_0:
   \   0000001C   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001E   10EB6103           ADDS     R3,R0,R1, ASR #+1
   \   00000022   9B69               LDR      R3,[R3, #+24]
   \   00000024   4FF68F74           MOVW     R4,#+65423
   \   00000028   2340               ANDS     R3,R4,R3
   \   0000002A   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000002C   10EB6104           ADDS     R4,R0,R1, ASR #+1
   \   00000030   A361               STR      R3,[R4, #+24]
   2336             
   2337              /* Configure the OCxM bits in the CCMRx register */
   2338              *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + (TIM_Channel>>1))) = TIM_OCMode;
   \   00000032   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000034   10EB6100           ADDS     R0,R0,R1, ASR #+1
   \   00000038   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000003A   8261               STR      R2,[R0, #+24]
   \   0000003C   13E0               B.N      ??TIM_SelectOCxM_2
   2339          
   2340            }
   2341            else
   2342            {
   2343              /* Reset the OCxM bits in the CCMRx register */
   2344              *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + ((u16)(TIM_Channel - 4)>> 1))) &= CCMR_OC24M_Mask;
   \                     ??TIM_SelectOCxM_1:
   \   0000003E   0B1F               SUBS     R3,R1,#+4
   \   00000040   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000042   10EB6303           ADDS     R3,R0,R3, ASR #+1
   \   00000046   0C1F               SUBS     R4,R1,#+4
   \   00000048   A4B2               UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000004A   10EB6404           ADDS     R4,R0,R4, ASR #+1
   \   0000004E   A469               LDR      R4,[R4, #+24]
   \   00000050   48F6FF75           MOVW     R5,#+36863
   \   00000054   2C40               ANDS     R4,R5,R4
   \   00000056   9C61               STR      R4,[R3, #+24]
   2345              
   2346              /* Configure the OCxM bits in the CCMRx register */
   2347              *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + ((u16)(TIM_Channel - 4)>> 1))) = (u16)(TIM_OCMode << 8);
   \   00000058   091F               SUBS     R1,R1,#+4
   \   0000005A   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000005C   10EB6100           ADDS     R0,R0,R1, ASR #+1
   \   00000060   1102               LSLS     R1,R2,#+8
   \   00000062   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000064   8161               STR      R1,[R0, #+24]
   2348            }
   2349          }
   \                     ??TIM_SelectOCxM_2:
   \   00000066   30BC               POP      {R4,R5}
   \   00000068   7047               BX       LR               ;; return
   2350          
   2351          /*******************************************************************************
   2352          * Function Name  : TIM_UpdateDisableConfig
   2353          * Description    : Enables or Disables the TIMx Update event.
   2354          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2355          *                  - NewState: new state of the TIMx UDIS bit
   2356          *                    This parameter can be: ENABLE or DISABLE.
   2357          * Output         : None
   2358          * Return         : None
   2359          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2360          void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
   2361          {
   2362            /* Check the parameters */
   2363            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2364            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2365          
   2366            if (NewState != DISABLE)
   \                     TIM_UpdateDisableConfig:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??TIM_UpdateDisableConfig_0
   2367            {
   2368              /* Set the Update Disable Bit */
   2369              TIMx->CR1 |= CR1_UDIS_Set;
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   51F00201           ORRS     R1,R1,#0x2
   \   0000000C   0180               STRH     R1,[R0, #+0]
   \   0000000E   04E0               B.N      ??TIM_UpdateDisableConfig_1
   2370            }
   2371            else
   2372            {
   2373              /* Reset the Update Disable Bit */
   2374              TIMx->CR1 &= CR1_UDIS_Reset;
   \                     ??TIM_UpdateDisableConfig_0:
   \   00000010   0188               LDRH     R1,[R0, #+0]
   \   00000012   40F2FD32           MOVW     R2,#+1021
   \   00000016   1140               ANDS     R1,R2,R1
   \   00000018   0180               STRH     R1,[R0, #+0]
   2375            }
   2376          }
   \                     ??TIM_UpdateDisableConfig_1:
   \   0000001A   7047               BX       LR               ;; return
   2377          
   2378          /*******************************************************************************
   2379          * Function Name  : TIM_UpdateRequestConfig
   2380          * Description    : Configures the TIMx Update Request Interrupt source.
   2381          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2382          *                  - TIM_UpdateSource: specifies the Update source.
   2383          *                    This parameter can be one of the following values:
   2384          *                       - TIM_UpdateSource_Regular
   2385          *                       - TIM_UpdateSource_Global
   2386          * Output         : None
   2387          * Return         : None
   2388          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2389          void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, u16 TIM_UpdateSource)
   2390          {
   2391            /* Check the parameters */
   2392            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2393            assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
   2394          
   2395            if (TIM_UpdateSource != TIM_UpdateSource_Global)
   \                     TIM_UpdateRequestConfig:
   \   00000000   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??TIM_UpdateRequestConfig_0
   2396            {
   2397              /* Set the URS Bit */
   2398              TIMx->CR1 |= CR1_URS_Set;
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   51F00401           ORRS     R1,R1,#0x4
   \   0000000C   0180               STRH     R1,[R0, #+0]
   \   0000000E   04E0               B.N      ??TIM_UpdateRequestConfig_1
   2399            }
   2400            else
   2401            {
   2402              /* Reset the URS Bit */
   2403              TIMx->CR1 &= CR1_URS_Reset;
   \                     ??TIM_UpdateRequestConfig_0:
   \   00000010   0188               LDRH     R1,[R0, #+0]
   \   00000012   40F2FB32           MOVW     R2,#+1019
   \   00000016   1140               ANDS     R1,R2,R1
   \   00000018   0180               STRH     R1,[R0, #+0]
   2404            }
   2405          }
   \                     ??TIM_UpdateRequestConfig_1:
   \   0000001A   7047               BX       LR               ;; return
   2406          
   2407          /*******************************************************************************
   2408          * Function Name  : TIM_SelectHallSensor
   2409          * Description    : Enables or disables the TIMxs Hall sensor interface.
   2410          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2411          *                  - NewState: new state of the TIMx Hall sensor interface.
   2412          *                    This parameter can be: ENABLE or DISABLE.
   2413          * Output         : None
   2414          * Return         : None
   2415          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2416          void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
   2417          {
   2418            /* Check the parameters */
   2419            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2420            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2421          
   2422            if (NewState != DISABLE)
   \                     TIM_SelectHallSensor:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??TIM_SelectHallSensor_0
   2423            {
   2424              /* Set the TI1S Bit */
   2425              TIMx->CR2 |= CR2_TI1S_Set;
   \   00000006   8188               LDRH     R1,[R0, #+4]
   \   00000008   51F08001           ORRS     R1,R1,#0x80
   \   0000000C   8180               STRH     R1,[R0, #+4]
   \   0000000E   03E0               B.N      ??TIM_SelectHallSensor_1
   2426            }
   2427            else
   2428            {
   2429              /* Reset the TI1S Bit */
   2430              TIMx->CR2 &= CR2_TI1S_Reset;
   \                     ??TIM_SelectHallSensor_0:
   \   00000010   8188               LDRH     R1,[R0, #+4]
   \   00000012   31F08001           BICS     R1,R1,#0x80
   \   00000016   8180               STRH     R1,[R0, #+4]
   2431            }
   2432          }
   \                     ??TIM_SelectHallSensor_1:
   \   00000018   7047               BX       LR               ;; return
   2433          
   2434          /*******************************************************************************
   2435          * Function Name  : TIM_SelectOnePulseMode
   2436          * Description    : Selects the TIMxs One Pulse Mode.
   2437          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2438          *                  - TIM_OPMode: specifies the OPM Mode to be used.
   2439          *                    This parameter can be one of the following values:
   2440          *                       - TIM_OPMode_Single
   2441          *                       - TIM_OPMode_Repetitive
   2442          * Output         : None
   2443          * Return         : None
   2444          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2445          void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, u16 TIM_OPMode)
   2446          {
   2447            /* Check the parameters */
   2448            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2449            assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
   2450          
   2451            /* Reset the OPM Bit */
   2452            TIMx->CR1 &= CR1_OPM_Reset;
   \                     TIM_SelectOnePulseMode:
   \   00000000   0288               LDRH     R2,[R0, #+0]
   \   00000002   40F2F733           MOVW     R3,#+1015
   \   00000006   1A40               ANDS     R2,R3,R2
   \   00000008   0280               STRH     R2,[R0, #+0]
   2453          
   2454            /* Configure the OPM Mode */
   2455            TIMx->CR1 |= TIM_OPMode;
   \   0000000A   0288               LDRH     R2,[R0, #+0]
   \   0000000C   1143               ORRS     R1,R1,R2
   \   0000000E   0180               STRH     R1,[R0, #+0]
   2456          }
   \   00000010   7047               BX       LR               ;; return
   2457          
   2458          /*******************************************************************************
   2459          * Function Name  : TIM_SelectOutputTrigger
   2460          * Description    : Selects the TIMx Trigger Output Mode.
   2461          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2462          *                  - TIM_TRGOSource: specifies the Trigger Output source.
   2463          *                    This paramter can be as follow:
   2464          *                      1/ For TIM1 to TIM8:
   2465          *                       - TIM_TRGOSource_Reset 
   2466          *                       - TIM_TRGOSource_Enable
   2467          *                       - TIM_TRGOSource_Update
   2468          *                      2/ These parameters are available for all TIMx except 
   2469          *                         TIM6 and TIM7:
   2470          *                       - TIM_TRGOSource_OC1
   2471          *                       - TIM_TRGOSource_OC1Ref
   2472          *                       - TIM_TRGOSource_OC2Ref
   2473          *                       - TIM_TRGOSource_OC3Ref
   2474          *                       - TIM_TRGOSource_OC4Ref
   2475          * Output         : None
   2476          * Return         : None
   2477          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2478          void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, u16 TIM_TRGOSource)
   2479          {
   2480            /* Check the parameters */
   2481            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2482            assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
   2483            assert_param(IS_TIM_PERIPH_TRGO(TIMx, TIM_TRGOSource));
   2484          
   2485            /* Reset the MMS Bits */
   2486            TIMx->CR2 &= CR2_MMS_Mask;
   \                     TIM_SelectOutputTrigger:
   \   00000000   8288               LDRH     R2,[R0, #+4]
   \   00000002   32F07002           BICS     R2,R2,#0x70
   \   00000006   8280               STRH     R2,[R0, #+4]
   2487          
   2488            /* Select the TRGO source */
   2489            TIMx->CR2 |=  TIM_TRGOSource;
   \   00000008   8288               LDRH     R2,[R0, #+4]
   \   0000000A   1143               ORRS     R1,R1,R2
   \   0000000C   8180               STRH     R1,[R0, #+4]
   2490          }
   \   0000000E   7047               BX       LR               ;; return
   2491          
   2492          /*******************************************************************************
   2493          * Function Name  : TIM_SelectSlaveMode
   2494          * Description    : Selects the TIMx Slave Mode.
   2495          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2496          *                    peripheral.
   2497          *                  - TIM_SlaveMode: specifies the Timer Slave Mode.
   2498          *                    This paramter can be one of the following values:
   2499          *                       - TIM_SlaveMode_Reset
   2500          *                       - TIM_SlaveMode_Gated
   2501          *                       - TIM_SlaveMode_Trigger
   2502          *                       - TIM_SlaveMode_External1
   2503          * Output         : None
   2504          * Return         : None
   2505          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2506          void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, u16 TIM_SlaveMode)
   2507          {
   2508            /* Check the parameters */
   2509            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2510            assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
   2511          
   2512            /* Reset the SMS Bits */
   2513            TIMx->SMCR &= SMCR_SMS_Mask;
   \                     TIM_SelectSlaveMode:
   \   00000000   0289               LDRH     R2,[R0, #+8]
   \   00000002   32F00702           BICS     R2,R2,#0x7
   \   00000006   0281               STRH     R2,[R0, #+8]
   2514          
   2515            /* Select the Slave Mode */
   2516            TIMx->SMCR |= TIM_SlaveMode;
   \   00000008   0289               LDRH     R2,[R0, #+8]
   \   0000000A   1143               ORRS     R1,R1,R2
   \   0000000C   0181               STRH     R1,[R0, #+8]
   2517          }
   \   0000000E   7047               BX       LR               ;; return
   2518          
   2519          /*******************************************************************************
   2520          * Function Name  : TIM_SelectMasterSlaveMode
   2521          * Description    : Sets or Resets the TIMx Master/Slave Mode.
   2522          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2523          *                    peripheral.
   2524          *                  - TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
   2525          *                    This paramter can be one of the following values:
   2526          *                       - TIM_MasterSlaveMode_Enable: synchronization between the
   2527          *                         current timer and its slaves (through TRGO).
   2528          *                       - TIM_MasterSlaveMode_Disable: No action
   2529          * Output         : None
   2530          * Return         : None
   2531          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2532          void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, u16 TIM_MasterSlaveMode)
   2533          {
   2534            /* Check the parameters */
   2535            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2536            assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
   2537          
   2538            /* Reset the MSM Bit */
   2539            TIMx->SMCR &= SMCR_MSM_Reset;
   \                     TIM_SelectMasterSlaveMode:
   \   00000000   0289               LDRH     R2,[R0, #+8]
   \   00000002   32F08002           BICS     R2,R2,#0x80
   \   00000006   0281               STRH     R2,[R0, #+8]
   2540            
   2541            /* Set or Reset the MSM Bit */
   2542            TIMx->SMCR |= TIM_MasterSlaveMode;
   \   00000008   0289               LDRH     R2,[R0, #+8]
   \   0000000A   1143               ORRS     R1,R1,R2
   \   0000000C   0181               STRH     R1,[R0, #+8]
   2543          }
   \   0000000E   7047               BX       LR               ;; return
   2544          
   2545          /*******************************************************************************
   2546          * Function Name  : TIM_SetCounter
   2547          * Description    : Sets the TIMx Counter Register value
   2548          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2549          *                  - Counter: specifies the Counter register new value.
   2550          * Output         : None
   2551          * Return         : None
   2552          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2553          void TIM_SetCounter(TIM_TypeDef* TIMx, u16 Counter)
   2554          {
   2555            /* Check the parameters */
   2556            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2557          
   2558            /* Set the Counter Register value */
   2559            TIMx->CNT = Counter;
   \                     TIM_SetCounter:
   \   00000000   8184               STRH     R1,[R0, #+36]
   2560          }
   \   00000002   7047               BX       LR               ;; return
   2561          
   2562          /*******************************************************************************
   2563          * Function Name  : TIM_SetAutoreload
   2564          * Description    : Sets the TIMx Autoreload Register value
   2565          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2566          *                  - Autoreload: specifies the Autoreload register new value.
   2567          * Output         : None
   2568          * Return         : None
   2569          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2570          void TIM_SetAutoreload(TIM_TypeDef* TIMx, u16 Autoreload)
   2571          {
   2572            /* Check the parameters */
   2573            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2574          
   2575            /* Set the Autoreload Register value */
   2576            TIMx->ARR = Autoreload;
   \                     TIM_SetAutoreload:
   \   00000000   8185               STRH     R1,[R0, #+44]
   2577          }
   \   00000002   7047               BX       LR               ;; return
   2578          
   2579          /*******************************************************************************
   2580          * Function Name  : TIM_SetCompare1
   2581          * Description    : Sets the TIMx Capture Compare1 Register value
   2582          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2583          *                    peripheral.
   2584          *                  - Compare1: specifies the Capture Compare1 register new value.
   2585          * Output         : None
   2586          * Return         : None
   2587          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2588          void TIM_SetCompare1(TIM_TypeDef* TIMx, u16 Compare1)
   2589          {
   2590            /* Check the parameters */
   2591            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2592          
   2593            /* Set the Capture Compare1 Register value */
   2594            TIMx->CCR1 = Compare1;
   \                     TIM_SetCompare1:
   \   00000000   8186               STRH     R1,[R0, #+52]
   2595          }
   \   00000002   7047               BX       LR               ;; return
   2596          
   2597          /*******************************************************************************
   2598          * Function Name  : TIM_SetCompare2
   2599          * Description    : Sets the TIMx Capture Compare2 Register value
   2600          * Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2601          *                   peripheral.
   2602          *                  - Compare2: specifies the Capture Compare2 register new value.
   2603          * Output         : None
   2604          * Return         : None
   2605          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2606          void TIM_SetCompare2(TIM_TypeDef* TIMx, u16 Compare2)
   2607          {
   2608            /* Check the parameters */
   2609            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2610          
   2611            /* Set the Capture Compare2 Register value */
   2612            TIMx->CCR2 = Compare2;
   \                     TIM_SetCompare2:
   \   00000000   0187               STRH     R1,[R0, #+56]
   2613          }
   \   00000002   7047               BX       LR               ;; return
   2614          
   2615          /*******************************************************************************
   2616          * Function Name  : TIM_SetCompare3
   2617          * Description    : Sets the TIMx Capture Compare3 Register value
   2618          * Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2619          *                   peripheral.
   2620          *                  - Compare3: specifies the Capture Compare3 register new value.
   2621          * Output         : None
   2622          * Return         : None
   2623          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2624          void TIM_SetCompare3(TIM_TypeDef* TIMx, u16 Compare3)
   2625          {
   2626            /* Check the parameters */
   2627            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2628          
   2629            /* Set the Capture Compare3 Register value */
   2630            TIMx->CCR3 = Compare3;
   \                     TIM_SetCompare3:
   \   00000000   8187               STRH     R1,[R0, #+60]
   2631          }
   \   00000002   7047               BX       LR               ;; return
   2632          
   2633          /*******************************************************************************
   2634          * Function Name  : TIM_SetCompare4
   2635          * Description    : Sets the TIMx Capture Compare4 Register value
   2636          * Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2637          *                   peripheral.
   2638          *                  - Compare4: specifies the Capture Compare4 register new value.
   2639          * Output         : None
   2640          * Return         : None
   2641          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2642          void TIM_SetCompare4(TIM_TypeDef* TIMx, u16 Compare4)
   2643          {
   2644            /* Check the parameters */
   2645            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2646          
   2647            /* Set the Capture Compare4 Register value */
   2648            TIMx->CCR4 = Compare4;
   \                     TIM_SetCompare4:
   \   00000000   A0F84010           STRH     R1,[R0, #+64]
   2649          }
   \   00000004   7047               BX       LR               ;; return
   2650          
   2651          /*******************************************************************************
   2652          * Function Name  : TIM_SetIC1Prescaler
   2653          * Description    : Sets the TIMx Input Capture 1 prescaler.
   2654          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2655          *                    peripheral.
   2656          *                  - TIM_ICPSC: specifies the Input Capture1 prescaler
   2657          *                    new value.
   2658          *                    This parameter can be one of the following values:
   2659          *                       - TIM_ICPSC_DIV1: no prescaler
   2660          *                       - TIM_ICPSC_DIV2: capture is done once every 2 events
   2661          *                       - TIM_ICPSC_DIV4: capture is done once every 4 events
   2662          *                       - TIM_ICPSC_DIV8: capture is done once every 8 events
   2663          * Output         : None
   2664          * Return         : None
   2665          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2666          void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
   2667          {
   2668            /* Check the parameters */
   2669            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2670            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2671          
   2672            /* Reset the IC1PSC Bits */
   2673            TIMx->CCMR1 &= CCMR_IC13PSC_Mask;
   \                     TIM_SetIC1Prescaler:
   \   00000000   028B               LDRH     R2,[R0, #+24]
   \   00000002   32F00C02           BICS     R2,R2,#0xC
   \   00000006   0283               STRH     R2,[R0, #+24]
   2674          
   2675            /* Set the IC1PSC value */
   2676            TIMx->CCMR1 |= TIM_ICPSC;
   \   00000008   028B               LDRH     R2,[R0, #+24]
   \   0000000A   1143               ORRS     R1,R1,R2
   \   0000000C   0183               STRH     R1,[R0, #+24]
   2677          }
   \   0000000E   7047               BX       LR               ;; return
   2678          
   2679          /*******************************************************************************
   2680          * Function Name  : TIM_SetIC2Prescaler
   2681          * Description    : Sets the TIMx Input Capture 2 prescaler.
   2682          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2683          *                    peripheral.
   2684          *                  - TIM_ICPSC: specifies the Input Capture2 prescaler
   2685          *                    new value.
   2686          *                    This parameter can be one of the following values:
   2687          *                       - TIM_ICPSC_DIV1: no prescaler
   2688          *                       - TIM_ICPSC_DIV2: capture is done once every 2 events
   2689          *                       - TIM_ICPSC_DIV4: capture is done once every 4 events
   2690          *                       - TIM_ICPSC_DIV8: capture is done once every 8 events
   2691          * Output         : None
   2692          * Return         : None
   2693          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2694          void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
   2695          {
   2696            /* Check the parameters */
   2697            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2698            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2699          
   2700            /* Reset the IC2PSC Bits */
   2701            TIMx->CCMR1 &= CCMR_IC24PSC_Mask;
   \                     TIM_SetIC2Prescaler:
   \   00000000   028B               LDRH     R2,[R0, #+24]
   \   00000002   32F44062           BICS     R2,R2,#0xC00
   \   00000006   0283               STRH     R2,[R0, #+24]
   2702          
   2703            /* Set the IC2PSC value */
   2704            TIMx->CCMR1 |= (u16)(TIM_ICPSC << 8);
   \   00000008   028B               LDRH     R2,[R0, #+24]
   \   0000000A   52EA0121           ORRS     R1,R2,R1, LSL #+8
   \   0000000E   0183               STRH     R1,[R0, #+24]
   2705          }
   \   00000010   7047               BX       LR               ;; return
   2706          
   2707          /*******************************************************************************
   2708          * Function Name  : TIM_SetIC3Prescaler
   2709          * Description    : Sets the TIMx Input Capture 3 prescaler.
   2710          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2711          *                    peripheral.
   2712          *                  - TIM_ICPSC: specifies the Input Capture3 prescaler
   2713          *                    new value.
   2714          *                    This parameter can be one of the following values:
   2715          *                       - TIM_ICPSC_DIV1: no prescaler
   2716          *                       - TIM_ICPSC_DIV2: capture is done once every 2 events
   2717          *                       - TIM_ICPSC_DIV4: capture is done once every 4 events
   2718          *                       - TIM_ICPSC_DIV8: capture is done once every 8 events
   2719          * Output         : None
   2720          * Return         : None
   2721          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2722          void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
   2723          {
   2724            /* Check the parameters */
   2725            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2726            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2727          
   2728            /* Reset the IC3PSC Bits */
   2729            TIMx->CCMR2 &= CCMR_IC13PSC_Mask;
   \                     TIM_SetIC3Prescaler:
   \   00000000   828B               LDRH     R2,[R0, #+28]
   \   00000002   32F00C02           BICS     R2,R2,#0xC
   \   00000006   8283               STRH     R2,[R0, #+28]
   2730          
   2731            /* Set the IC3PSC value */
   2732            TIMx->CCMR2 |= TIM_ICPSC;
   \   00000008   828B               LDRH     R2,[R0, #+28]
   \   0000000A   1143               ORRS     R1,R1,R2
   \   0000000C   8183               STRH     R1,[R0, #+28]
   2733          }
   \   0000000E   7047               BX       LR               ;; return
   2734          
   2735          /*******************************************************************************
   2736          * Function Name  : TIM_SetIC4Prescaler
   2737          * Description    : Sets the TIMx Input Capture 4 prescaler.
   2738          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2739          *                    peripheral.
   2740          *                  - TIM_ICPSC: specifies the Input Capture4 prescaler
   2741          *                    new value.
   2742          *                    This parameter can be one of the following values:
   2743          *                      - TIM_ICPSC_DIV1: no prescaler
   2744          *                      - TIM_ICPSC_DIV2: capture is done once every 2 events
   2745          *                      - TIM_ICPSC_DIV4: capture is done once every 4 events
   2746          *                      - TIM_ICPSC_DIV8: capture is done once every 8 events
   2747          * Output         : None
   2748          * Return         : None
   2749          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2750          void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
   2751          {  
   2752            /* Check the parameters */
   2753            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2754            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2755          
   2756            /* Reset the IC4PSC Bits */
   2757            TIMx->CCMR2 &= CCMR_IC24PSC_Mask;
   \                     TIM_SetIC4Prescaler:
   \   00000000   828B               LDRH     R2,[R0, #+28]
   \   00000002   32F44062           BICS     R2,R2,#0xC00
   \   00000006   8283               STRH     R2,[R0, #+28]
   2758          
   2759            /* Set the IC4PSC value */
   2760            TIMx->CCMR2 |= (u16)(TIM_ICPSC << 8);
   \   00000008   828B               LDRH     R2,[R0, #+28]
   \   0000000A   52EA0121           ORRS     R1,R2,R1, LSL #+8
   \   0000000E   8183               STRH     R1,[R0, #+28]
   2761          }
   \   00000010   7047               BX       LR               ;; return
   2762          
   2763          /*******************************************************************************
   2764          * Function Name  : TIM_SetClockDivision
   2765          * Description    : Sets the TIMx Clock Division value.
   2766          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2767          *                    peripheral.
   2768          *                  - TIM_CKD: specifies the clock division value.
   2769          *                    This parameter can be one of the following value:
   2770          *                       - TIM_CKD_DIV1: TDTS = Tck_tim
   2771          *                       - TIM_CKD_DIV2: TDTS = 2*Tck_tim
   2772          *                       - TIM_CKD_DIV4: TDTS = 4*Tck_tim
   2773          * Output         : None
   2774          * Return         : None
   2775          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2776          void TIM_SetClockDivision(TIM_TypeDef* TIMx, u16 TIM_CKD)
   2777          {
   2778            /* Check the parameters */
   2779            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2780            assert_param(IS_TIM_CKD_DIV(TIM_CKD));
   2781          
   2782            /* Reset the CKD Bits */
   2783            TIMx->CR1 &= CR1_CKD_Mask;
   \                     TIM_SetClockDivision:
   \   00000000   0288               LDRH     R2,[R0, #+0]
   \   00000002   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000004   0280               STRH     R2,[R0, #+0]
   2784          
   2785            /* Set the CKD value */
   2786            TIMx->CR1 |= TIM_CKD;
   \   00000006   0288               LDRH     R2,[R0, #+0]
   \   00000008   1143               ORRS     R1,R1,R2
   \   0000000A   0180               STRH     R1,[R0, #+0]
   2787          }
   \   0000000C   7047               BX       LR               ;; return
   2788          /*******************************************************************************
   2789          * Function Name  : TIM_GetCapture1
   2790          * Description    : Gets the TIMx Input Capture 1 value.
   2791          * Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2792          *                   peripheral.
   2793          * Output         : None
   2794          * Return         : Capture Compare 1 Register value.
   2795          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2796          u16 TIM_GetCapture1(TIM_TypeDef* TIMx)
   2797          {
   2798            /* Check the parameters */
   2799            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2800          
   2801            /* Get the Capture 1 Register value */
   2802            return TIMx->CCR1;
   \                     TIM_GetCapture1:
   \   00000000   808E               LDRH     R0,[R0, #+52]
   \   00000002   7047               BX       LR               ;; return
   2803          }
   2804          
   2805          /*******************************************************************************
   2806          * Function Name  : TIM_GetCapture2
   2807          * Description    : Gets the TIMx Input Capture 2 value.
   2808          * Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2809          *                   peripheral.
   2810          * Output         : None
   2811          * Return         : Capture Compare 2 Register value.
   2812          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2813          u16 TIM_GetCapture2(TIM_TypeDef* TIMx)
   2814          {
   2815            /* Check the parameters */
   2816            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2817          
   2818            /* Get the Capture 2 Register value */
   2819            return TIMx->CCR2;
   \                     TIM_GetCapture2:
   \   00000000   008F               LDRH     R0,[R0, #+56]
   \   00000002   7047               BX       LR               ;; return
   2820          }
   2821          
   2822          /*******************************************************************************
   2823          * Function Name  : TIM_GetCapture3
   2824          * Description    : Gets the TIMx Input Capture 3 value.
   2825          * Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2826          *                   peripheral.
   2827          * Output         : None
   2828          * Return         : Capture Compare 3 Register value.
   2829          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2830          u16 TIM_GetCapture3(TIM_TypeDef* TIMx)
   2831          {
   2832            /* Check the parameters */
   2833            assert_param(IS_TIM_123458_PERIPH(TIMx)); 
   2834          
   2835            /* Get the Capture 3 Register value */
   2836            return TIMx->CCR3;
   \                     TIM_GetCapture3:
   \   00000000   808F               LDRH     R0,[R0, #+60]
   \   00000002   7047               BX       LR               ;; return
   2837          }
   2838          
   2839          /*******************************************************************************
   2840          * Function Name  : TIM_GetCapture4
   2841          * Description    : Gets the TIMx Input Capture 4 value.
   2842          * Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2843          *                   peripheral.
   2844          * Output         : None
   2845          * Return         : Capture Compare 4 Register value.
   2846          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2847          u16 TIM_GetCapture4(TIM_TypeDef* TIMx)
   2848          {
   2849            /* Check the parameters */
   2850            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2851          
   2852            /* Get the Capture 4 Register value */
   2853            return TIMx->CCR4;
   \                     TIM_GetCapture4:
   \   00000000   B0F84000           LDRH     R0,[R0, #+64]
   \   00000004   7047               BX       LR               ;; return
   2854          }
   2855          
   2856          /*******************************************************************************
   2857          * Function Name  : TIM_GetCounter
   2858          * Description    : Gets the TIMx Counter value.
   2859          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2860          * Output         : None
   2861          * Return         : Counter Register value.
   2862          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2863          u16 TIM_GetCounter(TIM_TypeDef* TIMx)
   2864          {
   2865            /* Check the parameters */
   2866            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2867          
   2868            /* Get the Counter Register value */
   2869            return TIMx->CNT;
   \                     TIM_GetCounter:
   \   00000000   808C               LDRH     R0,[R0, #+36]
   \   00000002   7047               BX       LR               ;; return
   2870          }
   2871          
   2872          /*******************************************************************************
   2873          * Function Name  : TIM_GetPrescaler
   2874          * Description    : Gets the TIMx Prescaler value.
   2875          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2876          * Output         : None
   2877          * Return         : Prescaler Register value.
   2878          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2879          u16 TIM_GetPrescaler(TIM_TypeDef* TIMx)
   2880          {
   2881            /* Check the parameters */
   2882            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2883          
   2884            /* Get the Prescaler Register value */
   2885            return TIMx->PSC;
   \                     TIM_GetPrescaler:
   \   00000000   008D               LDRH     R0,[R0, #+40]
   \   00000002   7047               BX       LR               ;; return
   2886          }
   2887          
   2888          /*******************************************************************************
   2889          * Function Name  : TIM_GetFlagStatus
   2890          * Description    : Checks whether the specified TIM flag is set or not.
   2891          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2892          *                  - TIM_FLAG: specifies the flag to check.
   2893          *                    This parameter can be one of the following values:
   2894          *                       - TIM_FLAG_Update: TIM update Flag
   2895          *                       - TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   2896          *                       - TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   2897          *                       - TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   2898          *                       - TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   2899          *                       - TIM_FLAG_COM: TIM Commutation Flag
   2900          *                       - TIM_FLAG_Trigger: TIM Trigger Flag
   2901          *                       - TIM_FLAG_Break: TIM Break Flag
   2902          *                       - TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
   2903          *                       - TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
   2904          *                       - TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
   2905          *                       - TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
   2906          * Output         : None
   2907          * Return         : The new state of TIM_FLAG (SET or RESET).
   2908          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2909          FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, u16 TIM_FLAG)
   2910          { 
   \                     TIM_GetFlagStatus:
   \   00000000   0200               MOVS     R2,R0
   2911            ITStatus bitstatus = RESET;  
   \   00000002   0020               MOVS     R0,#+0
   2912          
   2913            /* Check the parameters */
   2914            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2915            assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
   2916            assert_param(IS_TIM_PERIPH_FLAG(TIMx, TIM_FLAG));
   2917            
   2918            if ((TIMx->SR & TIM_FLAG) != (u16)RESET)
   \   00000004   128A               LDRH     R2,[R2, #+16]
   \   00000006   1140               ANDS     R1,R1,R2
   \   00000008   0A00               MOVS     R2,R1
   \   0000000A   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000C   521E               SUBS     R2,R2,#+1
   \   0000000E   9241               SBCS     R2,R2,R2
   \   00000010   D243               MVNS     R2,R2
   \   00000012   D20F               LSRS     R2,R2,#+31
   \   00000014   1000               MOVS     R0,R2
   2919            {
   2920              bitstatus = SET;
   2921            }
   2922            else
   2923            {
   2924              bitstatus = RESET;
   2925            }
   2926            return bitstatus;
   \   00000016   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   7047               BX       LR               ;; return
   2927          }
   2928          
   2929          /*******************************************************************************
   2930          * Function Name  : TIM_ClearFlag
   2931          * Description    : Clears the TIMx's pending flags.
   2932          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2933          *                  - TIM_FLAG: specifies the flag bit to clear.
   2934          *                    This parameter can be any combination of the following values:
   2935          *                       - TIM_FLAG_Update: TIM update Flag
   2936          *                       - TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   2937          *                       - TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   2938          *                       - TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   2939          *                       - TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   2940          *                       - TIM_FLAG_COM: TIM Commutation Flag
   2941          *                       - TIM_FLAG_Trigger: TIM Trigger Flag
   2942          *                       - TIM_FLAG_Break: TIM Break Flag
   2943          *                       - TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
   2944          *                       - TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
   2945          *                       - TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
   2946          *                       - TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
   2947          * Output         : None
   2948          * Return         : None
   2949          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2950          void TIM_ClearFlag(TIM_TypeDef* TIMx, u16 TIM_FLAG)
   2951          {  
   2952            /* Check the parameters */
   2953            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2954            assert_param(IS_TIM_CLEAR_FLAG(TIMx, TIM_FLAG));
   2955            assert_param(IS_TIM_PERIPH_FLAG(TIMx, TIM_FLAG));
   2956             
   2957            /* Clear the flags */
   2958            TIMx->SR = (u16)~TIM_FLAG;
   \                     TIM_ClearFlag:
   \   00000000   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   C943               MVNS     R1,R1
   \   00000004   0182               STRH     R1,[R0, #+16]
   2959          }
   \   00000006   7047               BX       LR               ;; return
   2960          
   2961          /*******************************************************************************
   2962          * Function Name  : TIM_GetITStatus
   2963          * Description    : Checks whether the TIM interrupt has occurred or not.
   2964          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2965          *                  - TIM_IT: specifies the TIM interrupt source to check.
   2966          *                    This parameter can be one of the following values:
   2967          *                       - TIM_IT_Update: TIM update Interrupt source
   2968          *                       - TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2969          *                       - TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2970          *                       - TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2971          *                       - TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2972          *                       - TIM_IT_COM: TIM Commutation Interrupt
   2973          *                         source
   2974          *                       - TIM_IT_Trigger: TIM Trigger Interrupt source
   2975          *                       - TIM_IT_Break: TIM Break Interrupt source
   2976          * Output         : None
   2977          * Return         : The new state of the TIM_IT(SET or RESET).
   2978          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2979          ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, u16 TIM_IT)
   2980          {
   \                     TIM_GetITStatus:
   \   00000000   30B4               PUSH     {R4,R5}
   \   00000002   0200               MOVS     R2,R0
   2981            ITStatus bitstatus = RESET;  
   \   00000004   0020               MOVS     R0,#+0
   2982            u16 itstatus = 0x0, itenable = 0x0;
   \   00000006   0023               MOVS     R3,#+0
   \   00000008   0024               MOVS     R4,#+0
   2983          
   2984            /* Check the parameters */
   2985            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2986            assert_param(IS_TIM_GET_IT(TIM_IT));
   2987            assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
   2988             
   2989            itstatus = TIMx->SR & TIM_IT;
   \   0000000A   158A               LDRH     R5,[R2, #+16]
   \   0000000C   0D40               ANDS     R5,R1,R5
   \   0000000E   2B00               MOVS     R3,R5
   2990            
   2991            itenable = TIMx->DIER & TIM_IT;
   \   00000010   9289               LDRH     R2,[R2, #+12]
   \   00000012   1140               ANDS     R1,R1,R2
   \   00000014   0C00               MOVS     R4,R1
   2992          
   2993            if ((itstatus != (u16)RESET) && (itenable != (u16)RESET))
   \   00000016   9BB2               UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000018   002B               CMP      R3,#+0
   \   0000001A   06D0               BEQ.N    ??TIM_GetITStatus_0
   \   0000001C   2000               MOVS     R0,R4
   \   0000001E   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000020   401E               SUBS     R0,R0,#+1
   \   00000022   8041               SBCS     R0,R0,R0
   \   00000024   C043               MVNS     R0,R0
   \   00000026   C00F               LSRS     R0,R0,#+31
   \   00000028   00E0               B.N      ??TIM_GetITStatus_1
   2994            {
   2995              bitstatus = SET;
   2996            }
   2997            else
   2998            {
   2999              bitstatus = RESET;
   \                     ??TIM_GetITStatus_0:
   \   0000002A   0020               MOVS     R0,#+0
   3000            }
   3001            return bitstatus;
   \                     ??TIM_GetITStatus_1:
   \   0000002C   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   30BC               POP      {R4,R5}
   \   00000030   7047               BX       LR               ;; return
   3002          }
   3003          
   3004          /*******************************************************************************
   3005          * Function Name  : TIM_ClearITPendingBit
   3006          * Description    : Clears the TIMx's interrupt pending bits.
   3007          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   3008          *                  - TIM_IT: specifies the pending bit to clear.
   3009          *                    This parameter can be any combination of the following values:
   3010          *                       - TIM_IT_Update: TIM1 update Interrupt source
   3011          *                       - TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   3012          *                       - TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   3013          *                       - TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   3014          *                       - TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   3015          *                       - TIM_IT_COM: TIM Commutation Interrupt
   3016          *                         source
   3017          *                       - TIM_IT_Trigger: TIM Trigger Interrupt source
   3018          *                       - TIM_IT_Break: TIM Break Interrupt source
   3019          * Output         : None
   3020          * Return         : None
   3021          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3022          void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, u16 TIM_IT)
   3023          {
   3024            /* Check the parameters */
   3025            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   3026            assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
   3027          
   3028            /* Clear the IT pending Bit */
   3029            TIMx->SR = (u16)~TIM_IT;
   \                     TIM_ClearITPendingBit:
   \   00000000   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   C943               MVNS     R1,R1
   \   00000004   0182               STRH     R1,[R0, #+16]
   3030          }
   \   00000006   7047               BX       LR               ;; return
   3031          
   3032          /*******************************************************************************
   3033          * Function Name  : TI1_Config
   3034          * Description    : Configure the TI1 as Input.
   3035          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   3036          *                    peripheral.
   3037          *                  - TIM_ICPolarity : The Input Polarity.
   3038          *                    This parameter can be one of the following values:
   3039          *                       - TIM_ICPolarity_Rising
   3040          *                       - TIM_ICPolarity_Falling
   3041          *                  - TIM_ICSelection: specifies the input to be used.
   3042          *                    This parameter can be one of the following values:
   3043          *                       - TIM_ICSelection_DirectTI: TIM Input 1 is selected to
   3044          *                         be connected to IC1.
   3045          *                       - TIM_ICSelection_IndirectTI: TIM Input 1 is selected to
   3046          *                         be connected to IC2.
   3047          *                       - TIM_ICSelection_TRC: TIM Input 1 is selected to be
   3048          *                         connected to TRC.
   3049          *                  - TIM_ICFilter: Specifies the Input Capture Filter.
   3050          *                    This parameter must be a value between 0x00 and 0x0F.
   3051          * Output         : None
   3052          * Return         : None
   3053          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3054          static void TI1_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
   3055                                 u16 TIM_ICFilter)
   3056          {
   \                     TI1_Config:
   \   00000000   78B4               PUSH     {R3-R6}
   3057            u16 tmpccmr1 = 0, tmpccer = 0;
   \   00000002   0024               MOVS     R4,#+0
   \   00000004   0025               MOVS     R5,#+0
   3058          
   3059            /* Disable the Channel 1: Reset the CC1E Bit */
   3060            TIMx->CCER &= CCER_CC1E_Reset;
   \   00000006   068C               LDRH     R6,[R0, #+32]
   \   00000008   36F00106           BICS     R6,R6,#0x1
   \   0000000C   0684               STRH     R6,[R0, #+32]
   3061          
   3062            tmpccmr1 = TIMx->CCMR1;
   \   0000000E   068B               LDRH     R6,[R0, #+24]
   \   00000010   3400               MOVS     R4,R6
   3063            tmpccer = TIMx->CCER;
   \   00000012   068C               LDRH     R6,[R0, #+32]
   \   00000014   3500               MOVS     R5,R6
   3064          
   3065            /* Select the Input and set the filter */
   3066            tmpccmr1 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
   \   00000016   4FF60C76           MOVW     R6,#+65292
   \   0000001A   3440               ANDS     R4,R6,R4
   3067            tmpccmr1 |= TIM_ICSelection | (u16)(TIM_ICFilter << 4);
   \   0000001C   52EA0312           ORRS     R2,R2,R3, LSL #+4
   \   00000020   1443               ORRS     R4,R2,R4
   3068          
   3069            /* Select the Polarity and set the CC1E Bit */
   3070            tmpccer &= CCER_CC1P_Reset;
   \   00000022   4FF6FD72           MOVW     R2,#+65533
   \   00000026   1540               ANDS     R5,R2,R5
   3071            tmpccer |= TIM_ICPolarity | CCER_CC1E_Set;
   \   00000028   51F00101           ORRS     R1,R1,#0x1
   \   0000002C   0D43               ORRS     R5,R1,R5
   3072          
   3073            /* Write to TIMx CCMR1 and CCER registers */
   3074            TIMx->CCMR1 = tmpccmr1;
   \   0000002E   0483               STRH     R4,[R0, #+24]
   3075            TIMx->CCER = tmpccer;
   \   00000030   0584               STRH     R5,[R0, #+32]
   3076          }
   \   00000032   71BC               POP      {R0,R4-R6}
   \   00000034   7047               BX       LR               ;; return
   3077          
   3078          /*******************************************************************************
   3079          * Function Name  : TI2_Config
   3080          * Description    : Configure the TI2 as Input.
   3081          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   3082          *                    peripheral.
   3083          *                  - TIM_ICPolarity : The Input Polarity.
   3084          *                    This parameter can be one of the following values:
   3085          *                       - TIM_ICPolarity_Rising
   3086          *                       - TIM_ICPolarity_Falling
   3087          *                  - TIM_ICSelection: specifies the input to be used.
   3088          *                    This parameter can be one of the following values:
   3089          *                       - TIM_ICSelection_DirectTI: TIM Input 2 is selected to
   3090          *                         be connected to IC2.
   3091          *                       - TIM_ICSelection_IndirectTI: TIM Input 2 is selected to
   3092          *                         be connected to IC1.
   3093          *                       - TIM_ICSelection_TRC: TIM Input 2 is selected to be
   3094          *                         connected to TRC.
   3095          *                  - TIM_ICFilter: Specifies the Input Capture Filter.
   3096          *                    This parameter must be a value between 0x00 and 0x0F.
   3097          * Output         : None
   3098          * Return         : None
   3099          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3100          static void TI2_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
   3101                                 u16 TIM_ICFilter)
   3102          {
   \                     TI2_Config:
   \   00000000   F0B4               PUSH     {R4-R7}
   3103            u16 tmpccmr1 = 0, tmpccer = 0, tmp = 0;
   \   00000002   0024               MOVS     R4,#+0
   \   00000004   0025               MOVS     R5,#+0
   \   00000006   0026               MOVS     R6,#+0
   3104          
   3105            /* Disable the Channel 2: Reset the CC2E Bit */
   3106            TIMx->CCER &= CCER_CC2E_Reset;
   \   00000008   078C               LDRH     R7,[R0, #+32]
   \   0000000A   37F01007           BICS     R7,R7,#0x10
   \   0000000E   0784               STRH     R7,[R0, #+32]
   3107          
   3108            tmpccmr1 = TIMx->CCMR1;
   \   00000010   078B               LDRH     R7,[R0, #+24]
   \   00000012   3C00               MOVS     R4,R7
   3109            tmpccer = TIMx->CCER;
   \   00000014   078C               LDRH     R7,[R0, #+32]
   \   00000016   3D00               MOVS     R5,R7
   3110            tmp = (u16)(TIM_ICPolarity << 4);
   \   00000018   0901               LSLS     R1,R1,#+4
   \   0000001A   0E00               MOVS     R6,R1
   3111          
   3112            /* Select the Input and set the filter */
   3113            tmpccmr1 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
   \   0000001C   40F6FF41           MOVW     R1,#+3327
   \   00000020   0C40               ANDS     R4,R1,R4
   3114            tmpccmr1 |= (u16)(TIM_ICFilter << 12);
   \   00000022   54EA0334           ORRS     R4,R4,R3, LSL #+12
   3115            tmpccmr1 |= (u16)(TIM_ICSelection << 8);
   \   00000026   54EA0224           ORRS     R4,R4,R2, LSL #+8
   3116          
   3117            /* Select the Polarity and set the CC2E Bit */
   3118            tmpccer &= CCER_CC2P_Reset;
   \   0000002A   4FF6DF71           MOVW     R1,#+65503
   \   0000002E   0D40               ANDS     R5,R1,R5
   3119            tmpccer |=  tmp | CCER_CC2E_Set;
   \   00000030   56F01001           ORRS     R1,R6,#0x10
   \   00000034   0D43               ORRS     R5,R1,R5
   3120          
   3121            /* Write to TIMx CCMR1 and CCER registers */
   3122            TIMx->CCMR1 = tmpccmr1 ;
   \   00000036   0483               STRH     R4,[R0, #+24]
   3123            TIMx->CCER = tmpccer;
   \   00000038   0584               STRH     R5,[R0, #+32]
   3124          }
   \   0000003A   F0BC               POP      {R4-R7}
   \   0000003C   7047               BX       LR               ;; return
   3125          
   3126          /*******************************************************************************
   3127          * Function Name  : TI3_Config
   3128          * Description    : Configure the TI3 as Input.
   3129          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   3130          *                    peripheral.
   3131          *                  - TIM_ICPolarity : The Input Polarity.
   3132          *                    This parameter can be one of the following values:
   3133          *                       - TIM_ICPolarity_Rising
   3134          *                       - TIM_ICPolarity_Falling
   3135          *                  - TIM_ICSelection: specifies the input to be used.
   3136          *                    This parameter can be one of the following values:
   3137          *                       - TIM_ICSelection_DirectTI: TIM Input 3 is selected to
   3138          *                         be connected to IC3.
   3139          *                       - TIM_ICSelection_IndirectTI: TIM Input 3 is selected to
   3140          *                         be connected to IC4.
   3141          *                       - TIM_ICSelection_TRC: TIM Input 3 is selected to be
   3142          *                         connected to TRC.
   3143          *                  - TIM_ICFilter: Specifies the Input Capture Filter.
   3144          *                    This parameter must be a value between 0x00 and 0x0F.
   3145          * Output         : None
   3146          * Return         : None
   3147          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3148          static void TI3_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
   3149                                 u16 TIM_ICFilter)
   3150          {
   \                     TI3_Config:
   \   00000000   F0B4               PUSH     {R4-R7}
   3151            u16 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   \   00000002   0025               MOVS     R5,#+0
   \   00000004   0026               MOVS     R6,#+0
   \   00000006   0024               MOVS     R4,#+0
   3152          
   3153            /* Disable the Channel 3: Reset the CC3E Bit */
   3154            TIMx->CCER &= CCER_CC3E_Reset;
   \   00000008   078C               LDRH     R7,[R0, #+32]
   \   0000000A   37F48077           BICS     R7,R7,#0x100
   \   0000000E   0784               STRH     R7,[R0, #+32]
   3155          
   3156            tmpccmr2 = TIMx->CCMR2;
   \   00000010   878B               LDRH     R7,[R0, #+28]
   \   00000012   3D00               MOVS     R5,R7
   3157            tmpccer = TIMx->CCER;
   \   00000014   078C               LDRH     R7,[R0, #+32]
   \   00000016   3E00               MOVS     R6,R7
   3158            tmp = (u16)(TIM_ICPolarity << 8);
   \   00000018   0902               LSLS     R1,R1,#+8
   \   0000001A   0C00               MOVS     R4,R1
   3159          
   3160            /* Select the Input and set the filter */
   3161            tmpccmr2 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
   \   0000001C   4FF60C71           MOVW     R1,#+65292
   \   00000020   0D40               ANDS     R5,R1,R5
   3162            tmpccmr2 |= TIM_ICSelection | (u16)(TIM_ICFilter << 4);
   \   00000022   52EA0311           ORRS     R1,R2,R3, LSL #+4
   \   00000026   0D43               ORRS     R5,R1,R5
   3163          
   3164            /* Select the Polarity and set the CC3E Bit */
   3165            tmpccer &= CCER_CC3P_Reset;
   \   00000028   4FF6FF51           MOVW     R1,#+65023
   \   0000002C   0E40               ANDS     R6,R1,R6
   3166            tmpccer |= tmp | CCER_CC3E_Set;
   \   0000002E   54F48071           ORRS     R1,R4,#0x100
   \   00000032   0E43               ORRS     R6,R1,R6
   3167          
   3168            /* Write to TIMx CCMR2 and CCER registers */
   3169            TIMx->CCMR2 = tmpccmr2;
   \   00000034   8583               STRH     R5,[R0, #+28]
   3170            TIMx->CCER = tmpccer;
   \   00000036   0684               STRH     R6,[R0, #+32]
   3171          }
   \   00000038   F0BC               POP      {R4-R7}
   \   0000003A   7047               BX       LR               ;; return
   3172          
   3173          /*******************************************************************************
   3174          * Function Name  : TI4_Config
   3175          * Description    : Configure the TI1 as Input.
   3176          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   3177          *                    peripheral.
   3178          *                  - TIM_ICPolarity : The Input Polarity.
   3179          *                    This parameter can be one of the following values:
   3180          *                       - TIM_ICPolarity_Rising
   3181          *                       - TIM_ICPolarity_Falling
   3182          *                  - TIM_ICSelection: specifies the input to be used.
   3183          *                    This parameter can be one of the following values:
   3184          *                       - TIM_ICSelection_DirectTI: TIM Input 4 is selected to
   3185          *                         be connected to IC4.
   3186          *                       - TIM_ICSelection_IndirectTI: TIM Input 4 is selected to
   3187          *                         be connected to IC3.
   3188          *                       - TIM_ICSelection_TRC: TIM Input 4 is selected to be
   3189          *                         connected to TRC.
   3190          *                  - TIM_ICFilter: Specifies the Input Capture Filter.
   3191          *                    This parameter must be a value between 0x00 and 0x0F.
   3192          * Output         : None
   3193          * Return         : None
   3194          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3195          static void TI4_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
   3196                                 u16 TIM_ICFilter)
   3197          {
   \                     TI4_Config:
   \   00000000   F0B4               PUSH     {R4-R7}
   3198            u16 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   \   00000002   0026               MOVS     R6,#+0
   \   00000004   0024               MOVS     R4,#+0
   \   00000006   0025               MOVS     R5,#+0
   3199          
   3200            /* Disable the Channel 4: Reset the CC4E Bit */
   3201            TIMx->CCER &= CCER_CC4E_Reset;
   \   00000008   078C               LDRH     R7,[R0, #+32]
   \   0000000A   37F48057           BICS     R7,R7,#0x1000
   \   0000000E   0784               STRH     R7,[R0, #+32]
   3202          
   3203            tmpccmr2 = TIMx->CCMR2;
   \   00000010   878B               LDRH     R7,[R0, #+28]
   \   00000012   3E00               MOVS     R6,R7
   3204            tmpccer = TIMx->CCER;
   \   00000014   078C               LDRH     R7,[R0, #+32]
   \   00000016   3C00               MOVS     R4,R7
   3205            tmp = (u16)(TIM_ICPolarity << 12);
   \   00000018   0903               LSLS     R1,R1,#+12
   \   0000001A   0D00               MOVS     R5,R1
   3206          
   3207            /* Select the Input and set the filter */
   3208            tmpccmr2 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
   \   0000001C   40F6FF41           MOVW     R1,#+3327
   \   00000020   0E40               ANDS     R6,R1,R6
   3209            tmpccmr2 |= (u16)(TIM_ICSelection << 8) | (u16)(TIM_ICFilter << 12);
   \   00000022   1903               LSLS     R1,R3,#+12
   \   00000024   51EA0221           ORRS     R1,R1,R2, LSL #+8
   \   00000028   0E43               ORRS     R6,R1,R6
   3210          
   3211            /* Select the Polarity and set the CC4E Bit */
   3212            tmpccer &= CCER_CC4P_Reset;
   \   0000002A   4DF6FF71           MOVW     R1,#+57343
   \   0000002E   0C40               ANDS     R4,R1,R4
   3213            tmpccer |= tmp | CCER_CC4E_Set;
   \   00000030   55F48051           ORRS     R1,R5,#0x1000
   \   00000034   0C43               ORRS     R4,R1,R4
   3214          
   3215            /* Write to TIMx CCMR2 and CCER registers */
   3216            TIMx->CCMR2 = tmpccmr2;
   \   00000036   8683               STRH     R6,[R0, #+28]
   3217            TIMx->CCER = tmpccer ;
   \   00000038   0484               STRH     R4,[R0, #+32]
   3218          }
   \   0000003A   F0BC               POP      {R4-R7}
   \   0000003C   7047               BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   002C0140           DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   00340140           DC32     0x40013400
   3219          
   3220          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                    .cstack
     --------                    -------
     TI1_Config                      16
     TI2_Config                      16
     TI3_Config                      16
     TI4_Config                      16
     TIM_ARRPreloadConfig             0
     TIM_BDTRConfig                   0
     TIM_BDTRStructInit               0
     TIM_CCPreloadControl             0
     TIM_CCxCmd                       8
     TIM_CCxNCmd                      8
     TIM_ClearFlag                    0
     TIM_ClearITPendingBit            0
     TIM_ClearOC1Ref                  0
     TIM_ClearOC2Ref                  0
     TIM_ClearOC3Ref                  0
     TIM_ClearOC4Ref                  0
     TIM_Cmd                          0
     TIM_CounterModeConfig            0
     TIM_CtrlPWMOutputs               0
     TIM_DMACmd                       0
     TIM_DMAConfig                    0
     TIM_DeInit                       8
     TIM_ETRClockMode1Config         16
     TIM_ETRClockMode2Config          8
     TIM_ETRConfig                    8
     TIM_EncoderInterfaceConfig      16
     TIM_ForcedOC1Config              0
     TIM_ForcedOC2Config              0
     TIM_ForcedOC3Config              0
     TIM_ForcedOC4Config              0
     TIM_GenerateEvent                0
     TIM_GetCapture1                  0
     TIM_GetCapture2                  0
     TIM_GetCapture3                  0
     TIM_GetCapture4                  0
     TIM_GetCounter                   0
     TIM_GetFlagStatus                0
     TIM_GetITStatus                  8
     TIM_GetPrescaler                 0
     TIM_ICInit                      16
     TIM_ICStructInit                 0
     TIM_ITConfig                     0
     TIM_ITRxExternalClockConfig      8
     TIM_InternalClockConfig          0
     TIM_OC1FastConfig                0
     TIM_OC1Init                      8
     TIM_OC1NPolarityConfig           0
     TIM_OC1PolarityConfig            0
     TIM_OC1PreloadConfig             0
     TIM_OC2FastConfig                0
     TIM_OC2Init                      8
     TIM_OC2NPolarityConfig           0
     TIM_OC2PolarityConfig            0
     TIM_OC2PreloadConfig             0
     TIM_OC3FastConfig                0
     TIM_OC3Init                      8
     TIM_OC3NPolarityConfig           0
     TIM_OC3PolarityConfig            0
     TIM_OC3PreloadConfig             0
     TIM_OC4FastConfig                0
     TIM_OC4Init                      8
     TIM_OC4PolarityConfig            0
     TIM_OC4PreloadConfig             0
     TIM_OCStructInit                 0
     TIM_PWMIConfig                  24
     TIM_PrescalerConfig              0
     TIM_SelectCCDMA                  0
     TIM_SelectCOM                    0
     TIM_SelectHallSensor             0
     TIM_SelectInputTrigger           0
     TIM_SelectMasterSlaveMode        0
     TIM_SelectOCxM                   8
     TIM_SelectOnePulseMode           0
     TIM_SelectOutputTrigger          0
     TIM_SelectSlaveMode              0
     TIM_SetAutoreload                0
     TIM_SetClockDivision             0
     TIM_SetCompare1                  0
     TIM_SetCompare2                  0
     TIM_SetCompare3                  0
     TIM_SetCompare4                  0
     TIM_SetCounter                   0
     TIM_SetIC1Prescaler              0
     TIM_SetIC2Prescaler              0
     TIM_SetIC3Prescaler              0
     TIM_SetIC4Prescaler              0
     TIM_TIxExternalClockConfig      16
     TIM_TimeBaseInit                 8
     TIM_TimeBaseStructInit           0
     TIM_UpdateDisableConfig          0
     TIM_UpdateRequestConfig          0


   Section sizes:

     Function/Label              Bytes
     --------------              -----
     TIM_DeInit                   228
     TIM_TimeBaseInit              54
     TIM_OC1Init                  118
     TIM_OC2Init                  132
     TIM_OC3Init                  130
     TIM_OC4Init                   96
     TIM_ICInit                   112
     TIM_PWMIConfig               132
     TIM_BDTRConfig                32
     TIM_TimeBaseStructInit        24
     TIM_OCStructInit              34
     TIM_ICStructInit              22
     TIM_BDTRStructInit            30
     TIM_Cmd                       28
     TIM_CtrlPWMOutputs            34
     TIM_ITConfig                  24
     TIM_GenerateEvent              4
     TIM_DMAConfig                  8
     TIM_DMACmd                    24
     TIM_InternalClockConfig       10
     TIM_ITRxExternalClockConfig   22
     TIM_TIxExternalClockConfig    60
     TIM_ETRClockMode1Config       46
     TIM_ETRClockMode2Config       26
     TIM_ETRConfig                 24
     TIM_PrescalerConfig            6
     TIM_CounterModeConfig         18
     TIM_SelectInputTrigger        18
     TIM_EncoderInterfaceConfig    62
     TIM_ForcedOC1Config           18
     TIM_ForcedOC2Config           20
     TIM_ForcedOC3Config           18
     TIM_ForcedOC4Config           20
     TIM_ARRPreloadConfig          28
     TIM_SelectCOM                 26
     TIM_SelectCCDMA               26
     TIM_CCPreloadControl          26
     TIM_OC1PreloadConfig          18
     TIM_OC2PreloadConfig          20
     TIM_OC3PreloadConfig          18
     TIM_OC4PreloadConfig          20
     TIM_OC1FastConfig             18
     TIM_OC2FastConfig             20
     TIM_OC3FastConfig             18
     TIM_OC4FastConfig             20
     TIM_ClearOC1Ref               18
     TIM_ClearOC2Ref               18
     TIM_ClearOC3Ref               18
     TIM_ClearOC4Ref               18
     TIM_OC1PolarityConfig         18
     TIM_OC1NPolarityConfig        18
     TIM_OC2PolarityConfig         20
     TIM_OC2NPolarityConfig        20
     TIM_OC3PolarityConfig         20
     TIM_OC3NPolarityConfig        20
     TIM_OC4PolarityConfig         20
     TIM_CCxCmd                    32
     TIM_CCxNCmd                   32
     TIM_SelectOCxM               106
     TIM_UpdateDisableConfig       28
     TIM_UpdateRequestConfig       28
     TIM_SelectHallSensor          26
     TIM_SelectOnePulseMode        18
     TIM_SelectOutputTrigger       16
     TIM_SelectSlaveMode           16
     TIM_SelectMasterSlaveMode     16
     TIM_SetCounter                 4
     TIM_SetAutoreload              4
     TIM_SetCompare1                4
     TIM_SetCompare2                4
     TIM_SetCompare3                4
     TIM_SetCompare4                6
     TIM_SetIC1Prescaler           16
     TIM_SetIC2Prescaler           18
     TIM_SetIC3Prescaler           16
     TIM_SetIC4Prescaler           18
     TIM_SetClockDivision          14
     TIM_GetCapture1                4
     TIM_GetCapture2                4
     TIM_GetCapture3                4
     TIM_GetCapture4                6
     TIM_GetCounter                 4
     TIM_GetPrescaler               4
     TIM_GetFlagStatus             26
     TIM_ClearFlag                  8
     TIM_GetITStatus               50
     TIM_ClearITPendingBit          8
     TI1_Config                    54
     TI2_Config                    62
     TI3_Config                    60
     TI4_Config                    62
     ??DataTable10                  4
     ??DataTable11                  4

 
 2 890 bytes in section .text
 
 2 890 bytes of CODE memory

Errors: none
Warnings: none
