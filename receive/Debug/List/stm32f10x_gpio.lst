###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     28/May/2011  10:37:10 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Documents and Settings\253642xvvn\桌面\nrf905se\bigbo #
#                    ard\send6\library\src\stm32f10x_gpio.c                   #
#    Command line =  "C:\Documents and Settings\253642xvvn\桌面\nrf905se\bigb #
#                    oard\send6\library\src\stm32f10x_gpio.c" -lC             #
#                    "C:\Documents and Settings\253642xvvn\桌面\nrf905se\bigb #
#                    oard\send6\Debug\List\" -lb "C:\Documents and            #
#                    Settings\253642xvvn\桌面\nrf905se\bigboard\send6\Debug\L #
#                    ist\" -o "C:\Documents and Settings\253642xvvn\桌面\nrf9 #
#                    05se\bigboard\send6\Debug\Obj\" --no_cse --no_unroll     #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "D:\Program Files\IAR        #
#                    Systems\Embedded Workbench 5.4\arm\INC\DLib_Config_Full. #
#                    h" -I "C:\Documents and Settings\253642xvvn\桌面\nrf905s #
#                    e\bigboard\send6\library\inc\" -I "C:\Documents and      #
#                    Settings\253642xvvn\桌面\nrf905se\bigboard\send6\board\" #
#                     -I "C:\Documents and Settings\253642xvvn\桌面\nrf905se\ #
#                    bigboard\send6\app\" -I "D:\Program Files\IAR            #
#                    Systems\Embedded Workbench 5.4\arm\INC\" -Ol             #
#    List file    =  C:\Documents and Settings\253642xvvn\桌面\nrf905se\bigbo #
#                    ard\send6\Debug\List\stm32f10x_gpio.lst                  #
#    Object file  =  C:\Documents and Settings\253642xvvn\桌面\nrf905se\bigbo #
#                    ard\send6\Debug\Obj\stm32f10x_gpio.o                     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\253642xvvn\桌面\nrf905se\bigboard\send6\library\src\stm32f10x_gpio.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : stm32f10x_gpio.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.0.1
      5          * Date               : 06/13/2008
      6          * Description        : This file provides all the GPIO firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          
     16          /* Includes ------------------------------------------------------------------*/
     17          #include "stm32f10x_gpio.h"
     18          #include "stm32f10x_rcc.h"
     19          
     20          /* Private typedef -----------------------------------------------------------*/
     21          /* Private define ------------------------------------------------------------*/
     22          /* ------------ RCC registers bit address in the alias region ----------- */
     23          #define AFIO_OFFSET                 (AFIO_BASE - PERIPH_BASE)
     24          
     25          /* --- EVENTCR Register ---*/
     26          /* Alias word address of EVOE bit */
     27          #define EVCR_OFFSET                 (AFIO_OFFSET + 0x00)
     28          #define EVOE_BitNumber              ((u8)0x07)
     29          #define EVCR_EVOE_BB                (PERIPH_BB_BASE + (EVCR_OFFSET * 32) + (EVOE_BitNumber * 4))
     30          
     31          #define EVCR_PORTPINCONFIG_MASK     ((u16)0xFF80)
     32          #define LSB_MASK                    ((u16)0xFFFF)
     33          #define DBGAFR_POSITION_MASK        ((u32)0x000F0000)
     34          #define DBGAFR_SWJCFG_MASK          ((u32)0xF0FFFFFF)
     35          #define DBGAFR_LOCATION_MASK        ((u32)0x00200000)
     36          #define DBGAFR_NUMBITS_MASK         ((u32)0x00100000)
     37          
     38          /* Private macro -------------------------------------------------------------*/
     39          /* Private variables ---------------------------------------------------------*/
     40          /* Private function prototypes -----------------------------------------------*/
     41          /* Private functions ---------------------------------------------------------*/
     42          
     43          /*******************************************************************************
     44          * Function Name  : GPIO_DeInit
     45          * Description    : Deinitializes the GPIOx peripheral registers to their default
     46          *                  reset values.
     47          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
     48          * Output         : None
     49          * Return         : None
     50          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
     51          void GPIO_DeInit(GPIO_TypeDef* GPIOx)
     52          {
   \                     GPIO_DeInit:
   \   00000000   80B5               PUSH     {R7,LR}
     53            /* Check the parameters */
     54            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
     55          
     56            switch (*(u32*)&GPIOx)
   \   00000002   2F49               LDR.N    R1,??GPIO_DeInit_0  ;; 0x40010800
   \   00000004   401A               SUBS     R0,R0,R1
   \   00000006   18D0               BEQ.N    ??GPIO_DeInit_1
   \   00000008   4FF48061           MOV      R1,#+1024
   \   0000000C   401A               SUBS     R0,R0,R1
   \   0000000E   1DD0               BEQ.N    ??GPIO_DeInit_2
   \   00000010   4FF48061           MOV      R1,#+1024
   \   00000014   401A               SUBS     R0,R0,R1
   \   00000016   22D0               BEQ.N    ??GPIO_DeInit_3
   \   00000018   4FF48061           MOV      R1,#+1024
   \   0000001C   401A               SUBS     R0,R0,R1
   \   0000001E   27D0               BEQ.N    ??GPIO_DeInit_4
   \   00000020   4FF48061           MOV      R1,#+1024
   \   00000024   401A               SUBS     R0,R0,R1
   \   00000026   2CD0               BEQ.N    ??GPIO_DeInit_5
   \   00000028   4FF48061           MOV      R1,#+1024
   \   0000002C   401A               SUBS     R0,R0,R1
   \   0000002E   31D0               BEQ.N    ??GPIO_DeInit_6
   \   00000030   4FF48061           MOV      R1,#+1024
   \   00000034   401A               SUBS     R0,R0,R1
   \   00000036   36D0               BEQ.N    ??GPIO_DeInit_7
   \   00000038   40E0               B.N      ??GPIO_DeInit_8
     57            {
     58              case GPIOA_BASE:
     59                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
   \                     ??GPIO_DeInit_1:
   \   0000003A   0121               MOVS     R1,#+1
   \   0000003C   0420               MOVS     R0,#+4
   \   0000003E   ........           BL       RCC_APB2PeriphResetCmd
     60                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
   \   00000042   0021               MOVS     R1,#+0
   \   00000044   0420               MOVS     R0,#+4
   \   00000046   ........           BL       RCC_APB2PeriphResetCmd
   \   0000004A   37E0               B.N      ??GPIO_DeInit_9
     61                break;
     62          
     63              case GPIOB_BASE:
     64                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
   \                     ??GPIO_DeInit_2:
   \   0000004C   0121               MOVS     R1,#+1
   \   0000004E   0820               MOVS     R0,#+8
   \   00000050   ........           BL       RCC_APB2PeriphResetCmd
     65                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
   \   00000054   0021               MOVS     R1,#+0
   \   00000056   0820               MOVS     R0,#+8
   \   00000058   ........           BL       RCC_APB2PeriphResetCmd
   \   0000005C   2EE0               B.N      ??GPIO_DeInit_9
     66                break;
     67          
     68              case GPIOC_BASE:
     69                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
   \                     ??GPIO_DeInit_3:
   \   0000005E   0121               MOVS     R1,#+1
   \   00000060   1020               MOVS     R0,#+16
   \   00000062   ........           BL       RCC_APB2PeriphResetCmd
     70                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
   \   00000066   0021               MOVS     R1,#+0
   \   00000068   1020               MOVS     R0,#+16
   \   0000006A   ........           BL       RCC_APB2PeriphResetCmd
   \   0000006E   25E0               B.N      ??GPIO_DeInit_9
     71                break;
     72          
     73              case GPIOD_BASE:
     74                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
   \                     ??GPIO_DeInit_4:
   \   00000070   0121               MOVS     R1,#+1
   \   00000072   2020               MOVS     R0,#+32
   \   00000074   ........           BL       RCC_APB2PeriphResetCmd
     75                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
   \   00000078   0021               MOVS     R1,#+0
   \   0000007A   2020               MOVS     R0,#+32
   \   0000007C   ........           BL       RCC_APB2PeriphResetCmd
   \   00000080   1CE0               B.N      ??GPIO_DeInit_9
     76                break;
     77          
     78              case GPIOE_BASE:
     79                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
   \                     ??GPIO_DeInit_5:
   \   00000082   0121               MOVS     R1,#+1
   \   00000084   4020               MOVS     R0,#+64
   \   00000086   ........           BL       RCC_APB2PeriphResetCmd
     80                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
   \   0000008A   0021               MOVS     R1,#+0
   \   0000008C   4020               MOVS     R0,#+64
   \   0000008E   ........           BL       RCC_APB2PeriphResetCmd
   \   00000092   13E0               B.N      ??GPIO_DeInit_9
     81                break;
     82          
     83              case GPIOF_BASE:
     84                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
   \                     ??GPIO_DeInit_6:
   \   00000094   0121               MOVS     R1,#+1
   \   00000096   8020               MOVS     R0,#+128
   \   00000098   ........           BL       RCC_APB2PeriphResetCmd
     85                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
   \   0000009C   0021               MOVS     R1,#+0
   \   0000009E   8020               MOVS     R0,#+128
   \   000000A0   ........           BL       RCC_APB2PeriphResetCmd
   \   000000A4   0AE0               B.N      ??GPIO_DeInit_9
     86                break;
     87          
     88              case GPIOG_BASE:
     89                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
   \                     ??GPIO_DeInit_7:
   \   000000A6   0121               MOVS     R1,#+1
   \   000000A8   4FF48070           MOV      R0,#+256
   \   000000AC   ........           BL       RCC_APB2PeriphResetCmd
     90                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
   \   000000B0   0021               MOVS     R1,#+0
   \   000000B2   4FF48070           MOV      R0,#+256
   \   000000B6   ........           BL       RCC_APB2PeriphResetCmd
   \   000000BA   FFE7               B.N      ??GPIO_DeInit_9
     91                break;
     92          
     93              default:
     94                break;
     95            }
     96          }
   \                     ??GPIO_DeInit_8:
   \                     ??GPIO_DeInit_9:
   \   000000BC   01BD               POP      {R0,PC}          ;; return
   \   000000BE   00BF               Nop      
   \                     ??GPIO_DeInit_0:
   \   000000C0   00080140           DC32     0x40010800
     97          
     98          /*******************************************************************************
     99          * Function Name  : GPIO_AFIODeInit
    100          * Description    : Deinitializes the Alternate Functions (remap, event control
    101          *                  and EXTI configuration) registers to their default reset
    102          *                  values.
    103          * Input          : None
    104          * Output         : None
    105          * Return         : None
    106          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    107          void GPIO_AFIODeInit(void)
    108          {
   \                     GPIO_AFIODeInit:
   \   00000000   80B5               PUSH     {R7,LR}
    109            RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   0120               MOVS     R0,#+1
   \   00000006   ........           BL       RCC_APB2PeriphResetCmd
    110            RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
   \   0000000A   0021               MOVS     R1,#+0
   \   0000000C   0120               MOVS     R0,#+1
   \   0000000E   ........           BL       RCC_APB2PeriphResetCmd
    111          }
   \   00000012   01BD               POP      {R0,PC}          ;; return
    112          
    113          /*******************************************************************************
    114          * Function Name  : GPIO_Init
    115          * Description    : Initializes the GPIOx peripheral according to the specified
    116          *                  parameters in the GPIO_InitStruct.
    117          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    118          *                  - GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
    119          *                    contains the configuration information for the specified GPIO
    120          *                    peripheral.
    121          * Output         : None
    122          * Return         : None
    123          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    124          void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
    125          {
   \                     GPIO_Init:
   \   00000000   F0B4               PUSH     {R4-R7}
    126            u32 currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   0026               MOVS     R6,#+0
   \   00000006   0023               MOVS     R3,#+0
   \   00000008   0025               MOVS     R5,#+0
    127            u32 tmpreg = 0x00, pinmask = 0x00;
   \   0000000A   0024               MOVS     R4,#+0
   \   0000000C   0027               MOVS     R7,#+0
    128          
    129            /* Check the parameters */
    130            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    131            assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
    132            assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
    133          
    134          /*---------------------------- GPIO Mode Configuration -----------------------*/
    135            currentmode = ((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x0F);
   \   0000000E   91F803C0           LDRB     R12,[R1, #+3]
   \   00000012   1CF00F0C           ANDS     R12,R12,#0xF
   \   00000016   6246               MOV      R2,R12
    136          
    137            if ((((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x10)) != 0x00)
   \   00000018   91F803C0           LDRB     R12,[R1, #+3]
   \   0000001C   1CF0100F           TST      R12,#0x10
   \   00000020   01D0               BEQ.N    ??GPIO_Init_0
    138            {
    139              /* Check the parameters */
    140              assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    141              /* Output mode */
    142              currentmode |= (u32)GPIO_InitStruct->GPIO_Speed;
   \   00000022   8B78               LDRB     R3,[R1, #+2]
   \   00000024   1A43               ORRS     R2,R3,R2
    143            }
    144          
    145          /*---------------------------- GPIO CRL Configuration ------------------------*/
    146            /* Configure the eight low port pins */
    147            if (((u32)GPIO_InitStruct->GPIO_Pin & ((u32)0x00FF)) != 0x00)
   \                     ??GPIO_Init_0:
   \   00000026   0B88               LDRH     R3,[R1, #+0]
   \   00000028   1B06               LSLS     R3,R3,#+24
   \   0000002A   20D0               BEQ.N    ??GPIO_Init_1
    148            {
    149              tmpreg = GPIOx->CRL;
   \   0000002C   0468               LDR      R4,[R0, #+0]
    150          
    151              for (pinpos = 0x00; pinpos < 0x08; pinpos++)
   \   0000002E   0023               MOVS     R3,#+0
   \   00000030   1AE0               B.N      ??GPIO_Init_2
    152              {
    153                pos = ((u32)0x01) << pinpos;
   \                     ??GPIO_Init_3:
   \   00000032   0125               MOVS     R5,#+1
   \   00000034   9D40               LSLS     R5,R5,R3
    154                /* Get the port pins position */
    155                currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
   \   00000036   0E88               LDRH     R6,[R1, #+0]
   \   00000038   2E40               ANDS     R6,R5,R6
    156          
    157                if (currentpin == pos)
   \   0000003A   AE42               CMP      R6,R5
   \   0000003C   13D1               BNE.N    ??GPIO_Init_4
    158                {
    159                  pos = pinpos << 2;
   \   0000003E   9D00               LSLS     R5,R3,#+2
    160                  /* Clear the corresponding low control register bits */
    161                  pinmask = ((u32)0x0F) << pos;
   \   00000040   0F27               MOVS     R7,#+15
   \   00000042   AF40               LSLS     R7,R7,R5
    162                  tmpreg &= ~pinmask;
   \   00000044   FE43               MVNS     R6,R7
   \   00000046   3440               ANDS     R4,R6,R4
    163          
    164                  /* Write the mode configuration in the corresponding bits */
    165                  tmpreg |= (currentmode << pos);
   \   00000048   12FA05F5           LSLS     R5,R2,R5
   \   0000004C   2C43               ORRS     R4,R5,R4
    166          
    167                  /* Reset the corresponding ODR bit */
    168                  if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
   \   0000004E   CD78               LDRB     R5,[R1, #+3]
   \   00000050   282D               CMP      R5,#+40
   \   00000052   02D1               BNE.N    ??GPIO_Init_5
    169                  {
    170                    GPIOx->BRR = (((u32)0x01) << pinpos);
   \   00000054   0125               MOVS     R5,#+1
   \   00000056   9D40               LSLS     R5,R5,R3
   \   00000058   4561               STR      R5,[R0, #+20]
    171                  }
    172                  /* Set the corresponding ODR bit */
    173                  if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
   \                     ??GPIO_Init_5:
   \   0000005A   CD78               LDRB     R5,[R1, #+3]
   \   0000005C   482D               CMP      R5,#+72
   \   0000005E   02D1               BNE.N    ??GPIO_Init_6
    174                  {
    175                    GPIOx->BSRR = (((u32)0x01) << pinpos);
   \   00000060   0125               MOVS     R5,#+1
   \   00000062   9D40               LSLS     R5,R5,R3
   \   00000064   0561               STR      R5,[R0, #+16]
    176                  }
    177                }
    178              }
   \                     ??GPIO_Init_6:
   \                     ??GPIO_Init_4:
   \   00000066   5B1C               ADDS     R3,R3,#+1
   \                     ??GPIO_Init_2:
   \   00000068   082B               CMP      R3,#+8
   \   0000006A   E2D3               BCC.N    ??GPIO_Init_3
    179              GPIOx->CRL = tmpreg;
   \   0000006C   0460               STR      R4,[R0, #+0]
    180            }
    181          
    182          /*---------------------------- GPIO CRH Configuration ------------------------*/
    183            /* Configure the eight high port pins */
    184            if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
   \                     ??GPIO_Init_1:
   \   0000006E   0B88               LDRH     R3,[R1, #+0]
   \   00000070   4FF48074           MOV      R4,#+256
   \   00000074   A342               CMP      R3,R4
   \   00000076   26D3               BCC.N    ??GPIO_Init_7
    185            {
    186              tmpreg = GPIOx->CRH;
   \   00000078   4468               LDR      R4,[R0, #+4]
    187              for (pinpos = 0x00; pinpos < 0x08; pinpos++)
   \   0000007A   0023               MOVS     R3,#+0
   \   0000007C   20E0               B.N      ??GPIO_Init_8
    188              {
    189                pos = (((u32)0x01) << (pinpos + 0x08));
   \                     ??GPIO_Init_9:
   \   0000007E   0125               MOVS     R5,#+1
   \   00000080   13F10806           ADDS     R6,R3,#+8
   \   00000084   B540               LSLS     R5,R5,R6
    190                /* Get the port pins position */
    191                currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
   \   00000086   0E88               LDRH     R6,[R1, #+0]
   \   00000088   2E40               ANDS     R6,R5,R6
    192                if (currentpin == pos)
   \   0000008A   AE42               CMP      R6,R5
   \   0000008C   17D1               BNE.N    ??GPIO_Init_10
    193                {
    194                  pos = pinpos << 2;
   \   0000008E   9D00               LSLS     R5,R3,#+2
    195                  /* Clear the corresponding high control register bits */
    196                  pinmask = ((u32)0x0F) << pos;
   \   00000090   0F27               MOVS     R7,#+15
   \   00000092   AF40               LSLS     R7,R7,R5
    197                  tmpreg &= ~pinmask;
   \   00000094   FE43               MVNS     R6,R7
   \   00000096   3440               ANDS     R4,R6,R4
    198          
    199                  /* Write the mode configuration in the corresponding bits */
    200                  tmpreg |= (currentmode << pos);
   \   00000098   12FA05F5           LSLS     R5,R2,R5
   \   0000009C   2C43               ORRS     R4,R5,R4
    201          
    202                  /* Reset the corresponding ODR bit */
    203                  if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
   \   0000009E   CD78               LDRB     R5,[R1, #+3]
   \   000000A0   282D               CMP      R5,#+40
   \   000000A2   04D1               BNE.N    ??GPIO_Init_11
    204                  {
    205                    GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
   \   000000A4   0125               MOVS     R5,#+1
   \   000000A6   13F10806           ADDS     R6,R3,#+8
   \   000000AA   B540               LSLS     R5,R5,R6
   \   000000AC   4561               STR      R5,[R0, #+20]
    206                  }
    207                  /* Set the corresponding ODR bit */
    208                  if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
   \                     ??GPIO_Init_11:
   \   000000AE   CD78               LDRB     R5,[R1, #+3]
   \   000000B0   482D               CMP      R5,#+72
   \   000000B2   04D1               BNE.N    ??GPIO_Init_12
    209                  {
    210                    GPIOx->BSRR = (((u32)0x01) << (pinpos + 0x08));
   \   000000B4   0125               MOVS     R5,#+1
   \   000000B6   13F10806           ADDS     R6,R3,#+8
   \   000000BA   B540               LSLS     R5,R5,R6
   \   000000BC   0561               STR      R5,[R0, #+16]
    211                  }
    212                }
    213              }
   \                     ??GPIO_Init_12:
   \                     ??GPIO_Init_10:
   \   000000BE   5B1C               ADDS     R3,R3,#+1
   \                     ??GPIO_Init_8:
   \   000000C0   082B               CMP      R3,#+8
   \   000000C2   DCD3               BCC.N    ??GPIO_Init_9
    214              GPIOx->CRH = tmpreg;
   \   000000C4   4460               STR      R4,[R0, #+4]
    215            }
    216          }
   \                     ??GPIO_Init_7:
   \   000000C6   F0BC               POP      {R4-R7}
   \   000000C8   7047               BX       LR               ;; return
    217          
    218          /*******************************************************************************
    219          * Function Name  : GPIO_StructInit
    220          * Description    : Fills each GPIO_InitStruct member with its default value.
    221          * Input          : - GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure
    222          *                    which will be initialized.
    223          * Output         : None
    224          * Return         : None
    225          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    226          void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
    227          {
    228            /* Reset GPIO init structure parameters values */
    229            GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
   \                     GPIO_StructInit:
   \   00000000   4FF6FF71           MOVW     R1,#+65535
   \   00000004   0180               STRH     R1,[R0, #+0]
    230            GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
   \   00000006   0221               MOVS     R1,#+2
   \   00000008   8170               STRB     R1,[R0, #+2]
    231            GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   0000000A   0421               MOVS     R1,#+4
   \   0000000C   C170               STRB     R1,[R0, #+3]
    232          }
   \   0000000E   7047               BX       LR               ;; return
    233          
    234          /*******************************************************************************
    235          * Function Name  : GPIO_ReadInputDataBit
    236          * Description    : Reads the specified input port pin.
    237          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    238          *                : - GPIO_Pin:  specifies the port bit to read.
    239          *                    This parameter can be GPIO_Pin_x where x can be (0..15).
    240          * Output         : None
    241          * Return         : The input port pin value.
    242          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    243          u8 GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
    244          {
   \                     GPIO_ReadInputDataBit:
   \   00000000   0200               MOVS     R2,R0
    245            u8 bitstatus = 0x00;
   \   00000002   0020               MOVS     R0,#+0
    246          
    247            /* Check the parameters */
    248            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    249            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
    250          
    251            if ((GPIOx->IDR & GPIO_Pin) != (u32)Bit_RESET)
   \   00000004   9268               LDR      R2,[R2, #+8]
   \   00000006   1140               ANDS     R1,R1,R2
   \   00000008   0A00               MOVS     R2,R1
   \   0000000A   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000C   521E               SUBS     R2,R2,#+1
   \   0000000E   9241               SBCS     R2,R2,R2
   \   00000010   D243               MVNS     R2,R2
   \   00000012   D20F               LSRS     R2,R2,#+31
   \   00000014   1000               MOVS     R0,R2
    252            {
    253              bitstatus = (u8)Bit_SET;
    254            }
    255            else
    256            {
    257              bitstatus = (u8)Bit_RESET;
    258            }
    259            return bitstatus;
   \   00000016   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   7047               BX       LR               ;; return
    260          }
    261          
    262          /*******************************************************************************
    263          * Function Name  : GPIO_ReadInputData
    264          * Description    : Reads the specified GPIO input data port.
    265          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    266          * Output         : None
    267          * Return         : GPIO input data port value.
    268          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    269          u16 GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
    270          {
    271            /* Check the parameters */
    272            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    273          
    274            return ((u16)GPIOx->IDR);
   \                     GPIO_ReadInputData:
   \   00000000   8068               LDR      R0,[R0, #+8]
   \   00000002   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   7047               BX       LR               ;; return
    275          }
    276          
    277          /*******************************************************************************
    278          * Function Name  : GPIO_ReadOutputDataBit
    279          * Description    : Reads the specified output data port bit.
    280          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    281          *                : - GPIO_Pin:  specifies the port bit to read.
    282          *                    This parameter can be GPIO_Pin_x where x can be (0..15).
    283          * Output         : None
    284          * Return         : The output port pin value.
    285          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    286          u8 GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
    287          {
   \                     GPIO_ReadOutputDataBit:
   \   00000000   0200               MOVS     R2,R0
    288            u8 bitstatus = 0x00;
   \   00000002   0020               MOVS     R0,#+0
    289          
    290            /* Check the parameters */
    291            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    292            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
    293          
    294            if ((GPIOx->ODR & GPIO_Pin) != (u32)Bit_RESET)
   \   00000004   D268               LDR      R2,[R2, #+12]
   \   00000006   1140               ANDS     R1,R1,R2
   \   00000008   0A00               MOVS     R2,R1
   \   0000000A   92B2               UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000C   521E               SUBS     R2,R2,#+1
   \   0000000E   9241               SBCS     R2,R2,R2
   \   00000010   D243               MVNS     R2,R2
   \   00000012   D20F               LSRS     R2,R2,#+31
   \   00000014   1000               MOVS     R0,R2
    295            {
    296              bitstatus = (u8)Bit_SET;
    297            }
    298            else
    299            {
    300              bitstatus = (u8)Bit_RESET;
    301            }
    302            return bitstatus;
   \   00000016   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   7047               BX       LR               ;; return
    303          }
    304          
    305          /*******************************************************************************
    306          * Function Name  : GPIO_ReadOutputData
    307          * Description    : Reads the specified GPIO output data port.
    308          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    309          * Output         : None
    310          * Return         : GPIO output data port value.
    311          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    312          u16 GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
    313          {
    314            /* Check the parameters */
    315            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    316          
    317            return ((u16)GPIOx->ODR);
   \                     GPIO_ReadOutputData:
   \   00000000   C068               LDR      R0,[R0, #+12]
   \   00000002   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   7047               BX       LR               ;; return
    318          }
    319          
    320          /*******************************************************************************
    321          * Function Name  : GPIO_SetBits
    322          * Description    : Sets the selected data port bits.
    323          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    324          *                  - GPIO_Pin: specifies the port bits to be written.
    325          *                    This parameter can be any combination of GPIO_Pin_x where
    326          *                    x can be (0..15).
    327          * Output         : None
    328          * Return         : None
    329          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    330          void GPIO_SetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
    331          {
    332            /* Check the parameters */
    333            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    334            assert_param(IS_GPIO_PIN(GPIO_Pin));
    335          
    336            GPIOx->BSRR = GPIO_Pin;
   \                     GPIO_SetBits:
   \   00000000   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0161               STR      R1,[R0, #+16]
    337          }
   \   00000004   7047               BX       LR               ;; return
    338          
    339          /*******************************************************************************
    340          * Function Name  : GPIO_ResetBits
    341          * Description    : Clears the selected data port bits.
    342          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    343          *                  - GPIO_Pin: specifies the port bits to be written.
    344          *                    This parameter can be any combination of GPIO_Pin_x where
    345          *                    x can be (0..15).
    346          * Output         : None
    347          * Return         : None
    348          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    349          void GPIO_ResetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
    350          {
    351            /* Check the parameters */
    352            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    353            assert_param(IS_GPIO_PIN(GPIO_Pin));
    354          
    355            GPIOx->BRR = GPIO_Pin;
   \                     GPIO_ResetBits:
   \   00000000   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   4161               STR      R1,[R0, #+20]
    356          }
   \   00000004   7047               BX       LR               ;; return
    357          
    358          /*******************************************************************************
    359          * Function Name  : GPIO_WriteBit
    360          * Description    : Sets or clears the selected data port bit.
    361          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    362          *                  - GPIO_Pin: specifies the port bit to be written.
    363          *                    This parameter can be one of GPIO_Pin_x where x can be (0..15).
    364          *                  - BitVal: specifies the value to be written to the selected bit.
    365          *                    This parameter can be one of the BitAction enum values:
    366          *                       - Bit_RESET: to clear the port pin
    367          *                       - Bit_SET: to set the port pin
    368          * Output         : None
    369          * Return         : None
    370          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    371          void GPIO_WriteBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin, BitAction BitVal)
    372          {
    373            /* Check the parameters */
    374            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    375            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
    376            assert_param(IS_GPIO_BIT_ACTION(BitVal));
    377          
    378            if (BitVal != Bit_RESET)
   \                     GPIO_WriteBit:
   \   00000000   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   002A               CMP      R2,#+0
   \   00000004   02D0               BEQ.N    ??GPIO_WriteBit_0
    379            {
    380              GPIOx->BSRR = GPIO_Pin;
   \   00000006   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000008   0161               STR      R1,[R0, #+16]
   \   0000000A   01E0               B.N      ??GPIO_WriteBit_1
    381            }
    382            else
    383            {
    384              GPIOx->BRR = GPIO_Pin;
   \                     ??GPIO_WriteBit_0:
   \   0000000C   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   4161               STR      R1,[R0, #+20]
    385            }
    386          }
   \                     ??GPIO_WriteBit_1:
   \   00000010   7047               BX       LR               ;; return
    387          
    388          /*******************************************************************************
    389          * Function Name  : GPIO_Write
    390          * Description    : Writes data to the specified GPIO data port.
    391          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    392          *                  - PortVal: specifies the value to be written to the port output
    393          *                    data register.
    394          * Output         : None
    395          * Return         : None
    396          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    397          void GPIO_Write(GPIO_TypeDef* GPIOx, u16 PortVal)
    398          {
    399            /* Check the parameters */
    400            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    401          
    402            GPIOx->ODR = PortVal;
   \                     GPIO_Write:
   \   00000000   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   C160               STR      R1,[R0, #+12]
    403          }
   \   00000004   7047               BX       LR               ;; return
    404          
    405          /*******************************************************************************
    406          * Function Name  : GPIO_PinLockConfig
    407          * Description    : Locks GPIO Pins configuration registers.
    408          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    409          *                  - GPIO_Pin: specifies the port bit to be written.
    410          *                    This parameter can be any combination of GPIO_Pin_x where
    411          *                    x can be (0..15).
    412          * Output         : None
    413          * Return         : None
    414          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    415          void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
    416          {
    417            u32 tmp = 0x00010000;
   \                     GPIO_PinLockConfig:
   \   00000000   5FF48032           MOVS     R2,#+65536
    418          
    419            /* Check the parameters */
    420            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    421            assert_param(IS_GPIO_PIN(GPIO_Pin));
    422          
    423            tmp |= GPIO_Pin;
   \   00000004   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   0A43               ORRS     R2,R1,R2
    424            /* Set LCKK bit */
    425            GPIOx->LCKR = tmp;
   \   00000008   8261               STR      R2,[R0, #+24]
    426            /* Reset LCKK bit */
    427            GPIOx->LCKR =  GPIO_Pin;
   \   0000000A   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   8161               STR      R1,[R0, #+24]
    428            /* Set LCKK bit */
    429            GPIOx->LCKR = tmp;
   \   0000000E   8261               STR      R2,[R0, #+24]
    430            /* Read LCKK bit*/
    431            tmp = GPIOx->LCKR;
   \   00000010   8269               LDR      R2,[R0, #+24]
    432            /* Read LCKK bit*/
    433            tmp = GPIOx->LCKR;
   \   00000012   8069               LDR      R0,[R0, #+24]
   \   00000014   0200               MOVS     R2,R0
    434          }
   \   00000016   7047               BX       LR               ;; return
    435          
    436          /*******************************************************************************
    437          * Function Name  : GPIO_EventOutputConfig
    438          * Description    : Selects the GPIO pin used as Event output.
    439          * Input          : - GPIO_PortSource: selects the GPIO port to be used as source
    440          *                    for Event output.
    441          *                    This parameter can be GPIO_PortSourceGPIOx where x can be
    442          *                    (A..E).
    443          *                  - GPIO_PinSource: specifies the pin for the Event output.
    444          *                    This parameter can be GPIO_PinSourcex where x can be (0..15).
    445          * Output         : None
    446          * Return         : None
    447          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    448          void GPIO_EventOutputConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
    449          {
    450            u32 tmpreg = 0x00;
   \                     GPIO_EventOutputConfig:
   \   00000000   0022               MOVS     R2,#+0
    451          
    452            /* Check the parameters */
    453            assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
    454            assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    455          
    456            tmpreg = AFIO->EVCR;
   \   00000002   074B               LDR.N    R3,??GPIO_EventOutputConfig_0  ;; 0x40010000
   \   00000004   1B68               LDR      R3,[R3, #+0]
   \   00000006   1A00               MOVS     R2,R3
    457            /* Clear the PORT[6:4] and PIN[3:0] bits */
    458            tmpreg &= EVCR_PORTPINCONFIG_MASK;
   \   00000008   4FF68073           MOVW     R3,#+65408
   \   0000000C   1A40               ANDS     R2,R3,R2
    459            tmpreg |= (u32)GPIO_PortSource << 0x04;
   \   0000000E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   52EA0012           ORRS     R2,R2,R0, LSL #+4
    460            tmpreg |= GPIO_PinSource;
   \   00000014   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0A43               ORRS     R2,R1,R2
    461          
    462            AFIO->EVCR = tmpreg;
   \   00000018   0148               LDR.N    R0,??GPIO_EventOutputConfig_0  ;; 0x40010000
   \   0000001A   0260               STR      R2,[R0, #+0]
    463          }
   \   0000001C   7047               BX       LR               ;; return
   \   0000001E   00BF               Nop      
   \                     ??GPIO_EventOutputConfig_0:
   \   00000020   00000140           DC32     0x40010000
    464          
    465          /*******************************************************************************
    466          * Function Name  : GPIO_EventOutputCmd
    467          * Description    : Enables or disables the Event Output.
    468          * Input          : - NewState: new state of the Event output.
    469          *                    This parameter can be: ENABLE or DISABLE.
    470          * Output         : None
    471          * Return         : None
    472          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    473          void GPIO_EventOutputCmd(FunctionalState NewState)
    474          {
    475            /* Check the parameters */
    476            assert_param(IS_FUNCTIONAL_STATE(NewState));
    477          
    478            *(vu32 *) EVCR_EVOE_BB = (u32)NewState;
   \                     GPIO_EventOutputCmd:
   \   00000000   0149               LDR.N    R1,??GPIO_EventOutputCmd_0  ;; 0x4220001c
   \   00000002   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0860               STR      R0,[R1, #+0]
    479          }
   \   00000006   7047               BX       LR               ;; return
   \                     ??GPIO_EventOutputCmd_0:
   \   00000008   1C002042           DC32     0x4220001c
    480          
    481          /*******************************************************************************
    482          * Function Name  : GPIO_PinRemapConfig
    483          * Description    : Changes the mapping of the specified pin.
    484          * Input          : - GPIO_Remap: selects the pin to remap.
    485          *                    This parameter can be one of the following values:
    486          *                       - GPIO_Remap_SPI1
    487          *                       - GPIO_Remap_I2C1
    488          *                       - GPIO_Remap_USART1
    489          *                       - GPIO_Remap_USART2
    490          *                       - GPIO_PartialRemap_USART3
    491          *                       - GPIO_FullRemap_USART3
    492          *                       - GPIO_PartialRemap_TIM1
    493          *                       - GPIO_FullRemap_TIM1
    494          *                       - GPIO_PartialRemap1_TIM2
    495          *                       - GPIO_PartialRemap2_TIM2
    496          *                       - GPIO_FullRemap_TIM2
    497          *                       - GPIO_PartialRemap_TIM3
    498          *                       - GPIO_FullRemap_TIM3
    499          *                       - GPIO_Remap_TIM4
    500          *                       - GPIO_Remap1_CAN
    501          *                       - GPIO_Remap2_CAN
    502          *                       - GPIO_Remap_PD01
    503          *                       - GPIO_Remap_TIM5CH4_LSI
    504          *                       - GPIO_Remap_ADC1_ETRGINJ
    505          *                       - GPIO_Remap_ADC1_ETRGREG
    506          *                       - GPIO_Remap_ADC2_ETRGINJ
    507          *                       - GPIO_Remap_ADC2_ETRGREG
    508          *                       - GPIO_Remap_SWJ_NoJTRST
    509          *                       - GPIO_Remap_SWJ_JTAGDisable
    510          *                       - GPIO_Remap_SWJ_Disable
    511          *                  - NewState: new state of the port pin remapping.
    512          *                    This parameter can be: ENABLE or DISABLE.
    513          * Output         : None
    514          * Return         : None
    515          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    516          void GPIO_PinRemapConfig(u32 GPIO_Remap, FunctionalState NewState)
    517          {
   \                     GPIO_PinRemapConfig:
   \   00000000   78B4               PUSH     {R3-R6}
    518            u32 tmp = 0x00, tmp1 = 0x00, tmpreg = 0x00, tmpmask = 0x00;
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   0024               MOVS     R4,#+0
   \   00000006   0023               MOVS     R3,#+0
   \   00000008   0025               MOVS     R5,#+0
    519          
    520            /* Check the parameters */
    521            assert_param(IS_GPIO_REMAP(GPIO_Remap));
    522            assert_param(IS_FUNCTIONAL_STATE(NewState));
    523          
    524            tmpreg = AFIO->MAPR;
   \   0000000A   1B4E               LDR.N    R6,??GPIO_PinRemapConfig_0  ;; 0x40010004
   \   0000000C   3668               LDR      R6,[R6, #+0]
   \   0000000E   3300               MOVS     R3,R6
    525          
    526            tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
   \   00000010   10F47026           ANDS     R6,R0,#0xF0000
   \   00000014   360C               LSRS     R6,R6,#+16
   \   00000016   3500               MOVS     R5,R6
    527            tmp = GPIO_Remap & LSB_MASK;
   \   00000018   86B2               UXTH     R6,R0            ;; ZeroExt  R6,R0,#+16,#+16
   \   0000001A   3200               MOVS     R2,R6
    528          
    529            if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
   \   0000001C   10F44016           ANDS     R6,R0,#0x300000
   \   00000020   B6F5401F           CMP      R6,#+3145728
   \   00000024   08D1               BNE.N    ??GPIO_PinRemapConfig_1
    530            {
    531              tmpreg &= DBGAFR_SWJCFG_MASK;
   \   00000026   33F07063           BICS     R3,R3,#0xF000000
    532              AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
   \   0000002A   134C               LDR.N    R4,??GPIO_PinRemapConfig_0  ;; 0x40010004
   \   0000002C   2468               LDR      R4,[R4, #+0]
   \   0000002E   34F07064           BICS     R4,R4,#0xF000000
   \   00000032   114D               LDR.N    R5,??GPIO_PinRemapConfig_0  ;; 0x40010004
   \   00000034   2C60               STR      R4,[R5, #+0]
   \   00000036   12E0               B.N      ??GPIO_PinRemapConfig_2
    533            }
    534            else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
   \                     ??GPIO_PinRemapConfig_1:
   \   00000038   10F4801F           TST      R0,#0x100000
   \   0000003C   06D0               BEQ.N    ??GPIO_PinRemapConfig_3
    535            {
    536              tmp1 = ((u32)0x03) << tmpmask;
   \   0000003E   0324               MOVS     R4,#+3
   \   00000040   AC40               LSLS     R4,R4,R5
    537              tmpreg &= ~tmp1;
   \   00000042   E443               MVNS     R4,R4
   \   00000044   2340               ANDS     R3,R4,R3
    538              tmpreg |= ~DBGAFR_SWJCFG_MASK;
   \   00000046   53F07063           ORRS     R3,R3,#0xF000000
   \   0000004A   08E0               B.N      ??GPIO_PinRemapConfig_4
    539            }
    540            else
    541            {
    542              tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
   \                     ??GPIO_PinRemapConfig_3:
   \   0000004C   440D               LSRS     R4,R0,#+21
   \   0000004E   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000050   2401               LSLS     R4,R4,#+4
   \   00000052   12FA04F4           LSLS     R4,R2,R4
   \   00000056   E443               MVNS     R4,R4
   \   00000058   2340               ANDS     R3,R4,R3
    543              tmpreg |= ~DBGAFR_SWJCFG_MASK;
   \   0000005A   53F07063           ORRS     R3,R3,#0xF000000
    544            }
    545          
    546            if (NewState != DISABLE)
   \                     ??GPIO_PinRemapConfig_4:
   \                     ??GPIO_PinRemapConfig_2:
   \   0000005E   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000060   0029               CMP      R1,#+0
   \   00000062   05D0               BEQ.N    ??GPIO_PinRemapConfig_5
    547            {
    548              tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
   \   00000064   400D               LSRS     R0,R0,#+21
   \   00000066   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   0001               LSLS     R0,R0,#+4
   \   0000006A   12FA00F0           LSLS     R0,R2,R0
   \   0000006E   0343               ORRS     R3,R0,R3
    549            }
    550          
    551            AFIO->MAPR = tmpreg;
   \                     ??GPIO_PinRemapConfig_5:
   \   00000070   0148               LDR.N    R0,??GPIO_PinRemapConfig_0  ;; 0x40010004
   \   00000072   0360               STR      R3,[R0, #+0]
    552          }
   \   00000074   71BC               POP      {R0,R4-R6}
   \   00000076   7047               BX       LR               ;; return
   \                     ??GPIO_PinRemapConfig_0:
   \   00000078   04000140           DC32     0x40010004
    553          
    554          /*******************************************************************************
    555          * Function Name  : GPIO_EXTILineConfig
    556          * Description    : Selects the GPIO pin used as EXTI Line.
    557          * Input          : - GPIO_PortSource: selects the GPIO port to be used as
    558          *                    source for EXTI lines.
    559          *                    This parameter can be GPIO_PortSourceGPIOx where x can be
    560          *                    (A..G).
    561          *                  - GPIO_PinSource: specifies the EXTI line to be configured.
    562          *                   This parameter can be GPIO_PinSourcex where x can be (0..15).
    563          * Output         : None
    564          * Return         : None
    565          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    566          void GPIO_EXTILineConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
    567          {
   \                     GPIO_EXTILineConfig:
   \   00000000   18B4               PUSH     {R3,R4}
    568            u32 tmp = 0x00;
   \   00000002   0022               MOVS     R2,#+0
    569          
    570            /* Check the parameters */
    571            assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
    572            assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    573          
    574            tmp = ((u32)0x0F) << (0x04 * (GPIO_PinSource & (u8)0x03));
   \   00000004   0F23               MOVS     R3,#+15
   \   00000006   11F00304           ANDS     R4,R1,#0x3
   \   0000000A   E4B2               UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   A400               LSLS     R4,R4,#+2
   \   0000000E   A340               LSLS     R3,R3,R4
   \   00000010   1A00               MOVS     R2,R3
    575          
    576            AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
   \   00000012   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   8B10               ASRS     R3,R1,#+2
   \   00000016   0E4C               LDR.N    R4,??GPIO_EXTILineConfig_0  ;; 0x40010008
   \   00000018   54F82330           LDR      R3,[R4, R3, LSL #+2]
   \   0000001C   D243               MVNS     R2,R2
   \   0000001E   1A40               ANDS     R2,R2,R3
   \   00000020   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   8B10               ASRS     R3,R1,#+2
   \   00000024   0A4C               LDR.N    R4,??GPIO_EXTILineConfig_0  ;; 0x40010008
   \   00000026   44F82320           STR      R2,[R4, R3, LSL #+2]
    577            AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((u32)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (u8)0x03)));
   \   0000002A   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002C   8A10               ASRS     R2,R1,#+2
   \   0000002E   084B               LDR.N    R3,??GPIO_EXTILineConfig_0  ;; 0x40010008
   \   00000030   53F82220           LDR      R2,[R3, R2, LSL #+2]
   \   00000034   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   11F00303           ANDS     R3,R1,#0x3
   \   0000003A   DBB2               UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000003C   9B00               LSLS     R3,R3,#+2
   \   0000003E   9840               LSLS     R0,R0,R3
   \   00000040   1043               ORRS     R0,R0,R2
   \   00000042   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000044   8910               ASRS     R1,R1,#+2
   \   00000046   024A               LDR.N    R2,??GPIO_EXTILineConfig_0  ;; 0x40010008
   \   00000048   42F82100           STR      R0,[R2, R1, LSL #+2]
    578          }
   \   0000004C   11BC               POP      {R0,R4}
   \   0000004E   7047               BX       LR               ;; return
   \                     ??GPIO_EXTILineConfig_0:
   \   00000050   08000140           DC32     0x40010008
    579          
    580          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function               .cstack
     --------               -------
     GPIO_AFIODeInit             8
     GPIO_DeInit                 8
     GPIO_EXTILineConfig         8
     GPIO_EventOutputCmd         0
     GPIO_EventOutputConfig      0
     GPIO_Init                  16
     GPIO_PinLockConfig          0
     GPIO_PinRemapConfig        16
     GPIO_ReadInputData          0
     GPIO_ReadInputDataBit       0
     GPIO_ReadOutputData         0
     GPIO_ReadOutputDataBit      0
     GPIO_ResetBits              0
     GPIO_SetBits                0
     GPIO_StructInit             0
     GPIO_Write                  0
     GPIO_WriteBit               0


   Section sizes:

     Function/Label         Bytes
     --------------         -----
     GPIO_DeInit             196
     GPIO_AFIODeInit          20
     GPIO_Init               202
     GPIO_StructInit          16
     GPIO_ReadInputDataBit    26
     GPIO_ReadInputData        6
     GPIO_ReadOutputDataBit   26
     GPIO_ReadOutputData       6
     GPIO_SetBits              6
     GPIO_ResetBits            6
     GPIO_WriteBit            18
     GPIO_Write                6
     GPIO_PinLockConfig       24
     GPIO_EventOutputConfig   36
     GPIO_EventOutputCmd      12
     GPIO_PinRemapConfig     124
     GPIO_EXTILineConfig      84

 
 814 bytes in section .text
 
 814 bytes of CODE memory

Errors: none
Warnings: none
