###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.2.51295/W32 for ARM     11/Apr/2011  13:51:29 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\LiYang\Desktop\newest\Demo\fatfs\ff.c           #
#    Command line =  C:\Users\LiYang\Desktop\newest\Demo\fatfs\ff.c -lC       #
#                    C:\Users\LiYang\Desktop\newest\Demo\project\EWARMv5\Debu #
#                    g\List\ -lb C:\Users\LiYang\Desktop\newest\Demo\project\ #
#                    EWARMv5\Debug\List\ -o C:\Users\LiYang\Desktop\newest\De #
#                    mo\project\EWARMv5\Debug\Obj\ --debug --endian=little    #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "E:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    5.4\arm\INC\DLib_Config_Full.h" -I                       #
#                    C:\Users\LiYang\Desktop\newest\Demo\project\EWARMv5\..\. #
#                    .\include\ -I C:\Users\LiYang\Desktop\newest\Demo\projec #
#                    t\EWARMv5\..\..\source\ -I C:\Users\LiYang\Desktop\newes #
#                    t\Demo\project\EWARMv5\..\..\..\FWLib\library\inc\ -I    #
#                    C:\Users\LiYang\Desktop\newest\Demo\project\EWARMv5\..\. #
#                    .\..\USBLib\library\inc\ -I                              #
#                    C:\Users\LiYang\Desktop\newest\Demo\project\EWARMv5\..\. #
#                    .\fatfs\ -I "E:\Program Files\IAR Systems\Embedded       #
#                    Workbench 5.4\arm\INC\" -Ohz                             #
#    List file    =  C:\Users\LiYang\Desktop\newest\Demo\project\EWARMv5\Debu #
#                    g\List\ff.lst                                            #
#    Object file  =  C:\Users\LiYang\Desktop\newest\Demo\project\EWARMv5\Debu #
#                    g\Obj\ff.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\LiYang\Desktop\newest\Demo\fatfs\ff.c
      1          /*----------------------------------------------------------------------------/
      2          /  FatFs - FAT file system module  R0.07e                    (C)ChaN, 2009
      3          /-----------------------------------------------------------------------------/
      4          / FatFs module is a generic FAT file system module for small embedded systems.
      5          / This is a free software that opened for education, research and commercial
      6          / developments under license policy of following trems.
      7          /
      8          /  Copyright (C) 2009, ChaN, all right reserved.
      9          /
     10          / * The FatFs module is a free software and there is NO WARRANTY.
     11          / * No restriction on use. You can use, modify and redistribute it for
     12          /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
     13          / * Redistributions of source code must retain the above copyright notice.
     14          /
     15          /-----------------------------------------------------------------------------/
     16          / Feb 26,'06 R0.00  Prototype.
     17          /
     18          / Apr 29,'06 R0.01  First stable version.
     19          /
     20          / Jun 01,'06 R0.02  Added FAT12 support.
     21          /                   Removed unbuffered mode.
     22          /                   Fixed a problem on small (<32M) patition.
     23          / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
     24          /
     25          / Sep 22,'06 R0.03  Added f_rename().
     26          /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
     27          / Dec 11,'06 R0.03a Improved cluster scan algolithm to write files fast.
     28          /                   Fixed f_mkdir() creates incorrect directory on FAT32.
     29          /
     30          / Feb 04,'07 R0.04  Supported multiple drive system.
     31          /                   Changed some interfaces for multiple drive system.
     32          /                   Changed f_mountdrv() to f_mount().
     33          /                   Added f_mkfs().
     34          / Apr 01,'07 R0.04a Supported multiple partitions on a plysical drive.
     35          /                   Added a capability of extending file size to f_lseek().
     36          /                   Added minimization level 3.
     37          /                   Fixed an endian sensitive code in f_mkfs().
     38          / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
     39          /                   Added FSInfo support.
     40          /                   Fixed DBCS name can result FR_INVALID_NAME.
     41          /                   Fixed short seek (<= csize) collapses the file object.
     42          /
     43          / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
     44          /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
     45          /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
     46          / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
     47          /                   Fixed off by one error at FAT sub-type determination.
     48          /                   Fixed btr in f_read() can be mistruncated.
     49          /                   Fixed cached sector is not flushed when create and close
     50          /                   without write.
     51          /
     52          / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
     53          /                   Improved performance of f_lseek() on moving to the same
     54          /                   or following cluster.
     55          /
     56          / Apr 01,'09 R0.07  Merged Tiny-FatFs as a buffer configuration option.
     57          /                   Added long file name support.
     58          /                   Added multiple code page support.
     59          /                   Added re-entrancy for multitask operation.
     60          /                   Added auto cluster size selection to f_mkfs().
     61          /                   Added rewind option to f_readdir().
     62          /                   Changed result code of critical errors.
     63          /                   Renamed string functions to avoid name collision.
     64          / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
     65          /                   Added multiple sector size support.
     66          / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
     67          /                   Fixed wrong cache control in f_lseek().
     68          /                   Added relative path feature.
     69          /                   Added f_chdir() and f_chdrive().
     70          /                   Added proper case conversion to extended char.
     71          / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
     72          /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
     73          /                   Fixed name matching error on the 13 char boundary.
     74          /                   Added a configuration option, _LFN_UNICODE.
     75          /                   Changed f_readdir() to return the SFN with always upper
     76          /                   case on non-LFN cfg.
     77          /---------------------------------------------------------------------------*/
     78          
     79          #include "ff.h"			/* FatFs configurations and declarations */
     80          #include "diskio.h"		/* Declarations of low level disk I/O functions */
     81          
     82          /*--------------------------------------------------------------------------
     83          
     84             Module Private Definitions
     85          
     86          ---------------------------------------------------------------------------*/
     87          
     88          #if _FATFS != 0x007E
     89          #error Wrong include file (ff.h).
     90          #endif
     91          
     92          #if _FS_REENTRANT
     93          #if _USE_LFN == 1
     94          #error Static LFN work area must not be used in re-entrant configuration.
     95          #endif
     96          #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
     97          #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
     98          
     99          #else
    100          #define	ENTER_FF(fs)
    101          #define LEAVE_FF(fs, res)	return res
    102          
    103          #endif
    104          
    105          #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
    106          
    107          #ifndef NULL
    108          #define	NULL	0
    109          #endif
    110          
    111          /* Name status flags */
    112          #define NS			11		/* Offset of name status byte */
    113          #define NS_LOSS		0x01	/* Out of 8.3 format */
    114          #define NS_LFN		0x02	/* Force to create LFN entry */
    115          #define NS_LAST		0x04	/* Last segment */
    116          #define NS_BODY		0x08	/* Lower case flag (body) */
    117          #define NS_EXT		0x10	/* Lower case flag (ext) */
    118          #define NS_DOT		0x20	/* Dot entry */
    119          
    120          
    121          
    122          
    123          /*--------------------------------------------------------------------------
    124          
    125             Private Work Area
    126          
    127          ---------------------------------------------------------------------------*/
    128          
    129          #if _DRIVES < 1 || _DRIVES > 9
    130          #error Number of drives must be 1-9.
    131          #endif
    132          static

   \                                 In section .bss, align 4
    133          FATFS *FatFs[_DRIVES];	/* Pointer to the file system objects (logical drives) */
    134          
    135          static
    136          WORD Fsid;				/* File system mount ID */
   \                     Fsid:
   \   00000000                      DS8 2
   \   00000002                      DS8 2
   \   00000004                      DS8 4
    137          
    138          #if _FS_RPATH
    139          static
    140          BYTE Drive;				/* Current drive */
    141          #endif
    142          
    143          
    144          #if _USE_LFN == 1	/* LFN with static LFN working buffer */
    145          static

   \                                 In section .bss, align 4
    146          WCHAR LfnBuf[_MAX_LFN + 1];
   \                     LfnBuf:
   \   00000000                      DS8 512
    147          #define	NAMEBUF(sp,lp)	BYTE sp[12]; WCHAR *lp = LfnBuf
    148          #define INITBUF(dj,sp,lp)	dj.fn = sp; dj.lfn = lp
    149          
    150          #elif _USE_LFN > 1	/* LFN with dynamic LFN working buffer */
    151          #define	NAMEBUF(sp,lp)	BYTE sp[12]; WCHAR lbuf[_MAX_LFN + 1], *lp = lbuf
    152          #define INITBUF(dj,sp,lp)	dj.fn = sp; dj.lfn = lp
    153          
    154          #else				/* No LFN */
    155          #define	NAMEBUF(sp,lp)	BYTE sp[12]
    156          #define INITBUF(dj,sp,lp)	dj.fn = sp
    157          
    158          #endif
    159          
    160          
    161          
    162          
    163          /*--------------------------------------------------------------------------
    164          
    165             Module Private Functions
    166          
    167          ---------------------------------------------------------------------------*/
    168          
    169          
    170          /*-----------------------------------------------------------------------*/
    171          /* String functions                                                      */
    172          /*-----------------------------------------------------------------------*/
    173          
    174          /* Copy memory to memory */

   \                                 In section .text, align 2, keep-with-next
    175          static
    176          void mem_cpy (void* dst, const void* src, int cnt) {
    177          	char *d = (char*)dst;
    178          	const char *s = (const char *)src;
   \                     mem_cpy:
   \   00000000   03E0               B.N      ??mem_cpy_0
    179          	while (cnt--) *d++ = *s++;
   \                     ??mem_cpy_1:
   \   00000002   11F8013B           LDRB     R3,[R1], #+1
   \   00000006   00F8013B           STRB     R3,[R0], #+1
   \                     ??mem_cpy_0:
   \   0000000A   1346               MOV      R3,R2
   \   0000000C   5A1E               SUBS     R2,R3,#+1
   \   0000000E   002B               CMP      R3,#+0
   \   00000010   F7D1               BNE.N    ??mem_cpy_1
    180          }
   \   00000012   7047               BX       LR               ;; return
    181          
    182          /* Fill memory */

   \                                 In section .text, align 2, keep-with-next
    183          static
    184          void mem_set (void* dst, int val, int cnt) {
    185          	char *d = (char*)dst;
   \                     mem_set:
   \   00000000   01E0               B.N      ??mem_set_0
    186          	while (cnt--) *d++ = (char)val;
   \                     ??mem_set_1:
   \   00000002   00F8011B           STRB     R1,[R0], #+1
   \                     ??mem_set_0:
   \   00000006   1346               MOV      R3,R2
   \   00000008   5A1E               SUBS     R2,R3,#+1
   \   0000000A   002B               CMP      R3,#+0
   \   0000000C   F9D1               BNE.N    ??mem_set_1
    187          }
   \   0000000E   7047               BX       LR               ;; return
    188          
    189          /* Compare memory to memory */
    190          static
    191          int mem_cmp (const void* dst, const void* src, int cnt) {
    192          	const char *d = (const char *)dst, *s = (const char *)src;
    193          	int r = 0;
    194          	while (cnt-- && (r = *d++ - *s++) == 0) ;
    195          	return r;
    196          }
    197          
    198          /* Check if chr is contained in the string */

   \                                 In section .text, align 2, keep-with-next
    199          static
    200          int chk_chr (const char* str, int chr) {
   \                     chk_chr:
   \   00000000   00E0               B.N      ??chk_chr_0
    201          	while (*str && *str != chr) str++;
   \                     ??chk_chr_1:
   \   00000002   401C               ADDS     R0,R0,#+1
   \                     ??chk_chr_0:
   \   00000004   0278               LDRB     R2,[R0, #+0]
   \   00000006   0AB1               CBZ      R2,??chk_chr_2
   \   00000008   8A42               CMP      R2,R1
   \   0000000A   FAD1               BNE.N    ??chk_chr_1
    202          	return *str;
   \                     ??chk_chr_2:
   \   0000000C   1046               MOV      R0,R2
   \   0000000E   7047               BX       LR               ;; return
    203          }
    204          
    205          
    206          
    207          /*-----------------------------------------------------------------------*/
    208          /* Request/Release grant to access the volume                            */
    209          /*-----------------------------------------------------------------------*/
    210          #if _FS_REENTRANT
    211          
    212          static
    213          BOOL lock_fs (
    214          	FATFS *fs		/* File system object */
    215          )
    216          {
    217          	return ff_req_grant(fs->sobj);
    218          }
    219          
    220          
    221          static
    222          void unlock_fs (
    223          	FATFS *fs,		/* File system object */
    224          	FRESULT res		/* Result code to be returned */
    225          )
    226          {
    227          	if (res != FR_NOT_ENABLED &&
    228          		res != FR_INVALID_DRIVE &&
    229          		res != FR_INVALID_OBJECT &&
    230          		res != FR_TIMEOUT) {
    231          		ff_rel_grant(fs->sobj);
    232          	}
    233          }
    234          #endif
    235          
    236          
    237          
    238          /*-----------------------------------------------------------------------*/
    239          /* Change window offset                                                  */
    240          /*-----------------------------------------------------------------------*/
    241          

   \                                 In section .text, align 2, keep-with-next
    242          static
    243          FRESULT move_window (
    244          	FATFS *fs,		/* File system object */
    245          	DWORD sector	/* Sector number to make apperance in the fs->win[] */
    246          )					/* Move to zero only writes back dirty window */
    247          {
   \                     move_window:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0546               MOV      R5,R0
   \   00000004   0E46               MOV      R6,R1
    248          	DWORD wsect;
    249          
    250          
    251          	wsect = fs->winsect;
   \   00000006   EC6A               LDR      R4,[R5, #+44]
    252          	if (wsect != sector) {	/* Changed current window */
   \   00000008   B442               CMP      R4,R6
   \   0000000A   23D0               BEQ.N    ??move_window_0
    253          #if !_FS_READONLY
    254          		if (fs->wflag) {	/* Write back dirty window if needed */
   \   0000000C   2879               LDRB     R0,[R5, #+4]
   \   0000000E   A8B1               CBZ      R0,??move_window_1
    255          			if (disk_write(fs->drive, fs->win, wsect, 1) != RES_OK)
   \   00000010   ........           BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_14:
   \   00000014   0028               CMP      R0,#+0
   \   00000016   01D0               BEQ.N    ??move_window_2
    256          				return FR_DISK_ERR;
   \                     ??move_window_3:
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   F2BD               POP      {R1,R4-R7,PC}
    257          			fs->wflag = 0;
   \                     ??move_window_2:
   \   0000001C   2871               STRB     R0,[R5, #+4]
    258          			if (wsect < (fs->fatbase + fs->sects_fat)) {	/* In FAT area */
   \   0000001E   286A               LDR      R0,[R5, #+32]
   \   00000020   A969               LDR      R1,[R5, #+24]
   \   00000022   0818               ADDS     R0,R1,R0
   \   00000024   8442               CMP      R4,R0
   \   00000026   09D2               BCS.N    ??move_window_1
    259          				BYTE nf;
    260          				for (nf = fs->n_fats; nf > 1; nf--) {	/* Refrect the change to all FAT copies */
   \   00000028   EF78               LDRB     R7,[R5, #+3]
   \   0000002A   05E0               B.N      ??move_window_4
    261          					wsect += fs->sects_fat;
   \                     ??move_window_5:
   \   0000002C   A869               LDR      R0,[R5, #+24]
   \   0000002E   0419               ADDS     R4,R0,R4
    262          					disk_write(fs->drive, fs->win, wsect, 1);
   \   00000030   ........           BL       ?Subroutine4
    263          				}
   \                     ??CrossCallReturnLabel_13:
   \   00000034   7F1E               SUBS     R7,R7,#+1
   \   00000036   FFB2               UXTB     R7,R7
   \                     ??move_window_4:
   \   00000038   022F               CMP      R7,#+2
   \   0000003A   F7D2               BCS.N    ??move_window_5
    264          			}
    265          		}
    266          #endif
    267          		if (sector) {
   \                     ??move_window_1:
   \   0000003C   002E               CMP      R6,#+0
   \   0000003E   09D0               BEQ.N    ??move_window_0
    268          			if (disk_read(fs->drive, fs->win, sector, 1) != RES_OK)
   \   00000040   0123               MOVS     R3,#+1
   \   00000042   3246               MOV      R2,R6
   \   00000044   05F13001           ADD      R1,R5,#+48
   \   00000048   6878               LDRB     R0,[R5, #+1]
   \   0000004A   ........           BL       disk_read
   \   0000004E   0028               CMP      R0,#+0
   \   00000050   E2D1               BNE.N    ??move_window_3
    269          				return FR_DISK_ERR;
    270          			fs->winsect = sector;
   \   00000052   EE62               STR      R6,[R5, #+44]
    271          		}
    272          	}
    273          
    274          	return FR_OK;
   \                     ??move_window_0:
   \   00000054   0020               MOVS     R0,#+0
   \   00000056   F2BD               POP      {R1,R4-R7,PC}    ;; return
    275          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4:
   \   00000000   0123               MOVS     R3,#+1
   \   00000002   2246               MOV      R2,R4
   \   00000004   05F13001           ADD      R1,R5,#+48
   \   00000008   6878               LDRB     R0,[R5, #+1]
   \   0000000A   ........           B.W      disk_write
    276          
    277          
    278          
    279          
    280          /*-----------------------------------------------------------------------*/
    281          /* Clean-up cached data                                                  */
    282          /*-----------------------------------------------------------------------*/
    283          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    284          static
    285          FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
    286          	FATFS *fs	/* File system object */
    287          )
    288          {
   \                     sync:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0446               MOV      R4,R0
    289          	FRESULT res;
    290          
    291          
    292          	res = move_window(fs, 0);
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   ........           BL       move_window
   \   0000000A   0500               MOVS     R5,R0
    293          	if (res == FR_OK) {
   \   0000000C   4ED1               BNE.N    ??sync_0
    294          		/* Update FSInfo sector if needed */
    295          		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
   \   0000000E   2078               LDRB     R0,[R4, #+0]
   \   00000010   0328               CMP      R0,#+3
   \   00000012   44D1               BNE.N    ??sync_1
   \   00000014   6079               LDRB     R0,[R4, #+5]
   \   00000016   0028               CMP      R0,#+0
   \   00000018   41D0               BEQ.N    ??sync_1
    296          			fs->winsect = 0;
   \   0000001A   0020               MOVS     R0,#+0
   \   0000001C   E062               STR      R0,[R4, #+44]
    297          			mem_set(fs->win, 0, 512);
   \   0000001E   4FF40072           MOV      R2,#+512
   \   00000022   0021               MOVS     R1,#+0
   \   00000024   04F13000           ADD      R0,R4,#+48
   \   00000028   ........           BL       mem_set
    298          			ST_WORD(fs->win+BS_55AA, 0xAA55);
   \   0000002C   04F50570           ADD      R0,R4,#+532
   \   00000030   5521               MOVS     R1,#+85
   \   00000032   8176               STRB     R1,[R0, #+26]
   \   00000034   AA21               MOVS     R1,#+170
   \   00000036   C176               STRB     R1,[R0, #+27]
    299          			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
   \   00000038   5221               MOVS     R1,#+82
   \   0000003A   84F83010           STRB     R1,[R4, #+48]
   \   0000003E   04F13001           ADD      R1,R4,#+48
   \   00000042   5222               MOVS     R2,#+82
   \   00000044   4A70               STRB     R2,[R1, #+1]
   \   00000046   6122               MOVS     R2,#+97
   \   00000048   8A70               STRB     R2,[R1, #+2]
   \   0000004A   4122               MOVS     R2,#+65
   \   0000004C   CA70               STRB     R2,[R1, #+3]
    300          			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
   \   0000004E   7221               MOVS     R1,#+114
   \   00000050   84F81412           STRB     R1,[R4, #+532]
   \   00000054   4170               STRB     R1,[R0, #+1]
   \   00000056   8270               STRB     R2,[R0, #+2]
   \   00000058   6121               MOVS     R1,#+97
   \   0000005A   C170               STRB     R1,[R0, #+3]
    301          			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
   \   0000005C   2169               LDR      R1,[R4, #+16]
   \   0000005E   0171               STRB     R1,[R0, #+4]
   \   00000060   2169               LDR      R1,[R4, #+16]
   \   00000062   0904               LSLS     R1,R1,#+16
   \   00000064   090E               LSRS     R1,R1,#+24
   \   00000066   4171               STRB     R1,[R0, #+5]
   \   00000068   2169               LDR      R1,[R4, #+16]
   \   0000006A   090C               LSRS     R1,R1,#+16
   \   0000006C   8171               STRB     R1,[R0, #+6]
   \   0000006E   2169               LDR      R1,[R4, #+16]
   \   00000070   090E               LSRS     R1,R1,#+24
   \   00000072   C171               STRB     R1,[R0, #+7]
    302          			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
   \   00000074   E168               LDR      R1,[R4, #+12]
   \   00000076   0172               STRB     R1,[R0, #+8]
   \   00000078   E168               LDR      R1,[R4, #+12]
   \   0000007A   0904               LSLS     R1,R1,#+16
   \   0000007C   090E               LSRS     R1,R1,#+24
   \   0000007E   4172               STRB     R1,[R0, #+9]
   \   00000080   E168               LDR      R1,[R4, #+12]
   \   00000082   090C               LSRS     R1,R1,#+16
   \   00000084   8172               STRB     R1,[R0, #+10]
   \   00000086   E168               LDR      R1,[R4, #+12]
   \   00000088   090E               LSRS     R1,R1,#+24
   \   0000008A   C172               STRB     R1,[R0, #+11]
    303          			disk_write(fs->drive, fs->win, fs->fsi_sector, 1);
   \   0000008C   0123               MOVS     R3,#+1
   \   0000008E   6269               LDR      R2,[R4, #+20]
   \   00000090   04F13001           ADD      R1,R4,#+48
   \   00000094   6078               LDRB     R0,[R4, #+1]
   \   00000096   ........           BL       disk_write
    304          			fs->fsi_flag = 0;
   \   0000009A   0020               MOVS     R0,#+0
   \   0000009C   6071               STRB     R0,[R4, #+5]
    305          		}
    306          		/* Make sure that no pending write process in the physical drive */
    307          		if (disk_ioctl(fs->drive, CTRL_SYNC, (void*)NULL) != RES_OK)
   \                     ??sync_1:
   \   0000009E   0022               MOVS     R2,#+0
   \   000000A0   0021               MOVS     R1,#+0
   \   000000A2   6078               LDRB     R0,[R4, #+1]
   \   000000A4   ........           BL       disk_ioctl
   \   000000A8   00B1               CBZ      R0,??sync_0
    308          			res = FR_DISK_ERR;
   \   000000AA   0125               MOVS     R5,#+1
    309          	}
    310          
    311          	return res;
   \                     ??sync_0:
   \   000000AC   2846               MOV      R0,R5
   \   000000AE   32BD               POP      {R1,R4,R5,PC}    ;; return
    312          }
    313          #endif
    314          
    315          
    316          
    317          
    318          /*-----------------------------------------------------------------------*/
    319          /* FAT access - Read value of a FAT entry                                */
    320          /*-----------------------------------------------------------------------*/
    321          
    322          

   \                                 In section .text, align 2, keep-with-next
    323          DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Interal error, Else:Cluster status */
    324          	FATFS *fs,	/* File system object */
    325          	DWORD clst	/* Cluster# to get the link information */
    326          )
    327          {
   \                     get_fat:
   \   00000000   2DE9F041           PUSH     {R4-R8,LR}
   \   00000004   0446               MOV      R4,R0
   \   00000006   0D46               MOV      R5,R1
    328          	UINT wc, bc;
    329          	DWORD fsect;
    330          
    331          
    332          	if (clst < 2 || clst >= fs->max_clust)	/* Range check */
   \   00000008   022D               CMP      R5,#+2
   \   0000000A   02D3               BCC.N    ??get_fat_0
   \   0000000C   E069               LDR      R0,[R4, #+28]
   \   0000000E   8542               CMP      R5,R0
   \   00000010   01D3               BCC.N    ??get_fat_1
    333          		return 1;
   \                     ??get_fat_0:
   \   00000012   0120               MOVS     R0,#+1
   \   00000014   23E0               B.N      ??get_fat_2
    334          
    335          	fsect = fs->fatbase;
   \                     ??get_fat_1:
   \   00000016   266A               LDR      R6,[R4, #+32]
    336          	switch (fs->fs_type) {
   \   00000018   2078               LDRB     R0,[R4, #+0]
   \   0000001A   0128               CMP      R0,#+1
   \   0000001C   04D0               BEQ.N    ??get_fat_3
   \   0000001E   0228               CMP      R0,#+2
   \   00000020   22D0               BEQ.N    ??get_fat_4
   \   00000022   0328               CMP      R0,#+3
   \   00000024   32D0               BEQ.N    ??get_fat_5
   \   00000026   4BE0               B.N      ??get_fat_6
    337          	case FS_FAT12 :
    338          		bc = clst; bc += bc / 2;
   \                     ??get_fat_3:
   \   00000028   05EB5507           ADD      R7,R5,R5, LSR #+1
    339          		if (move_window(fs, fsect + (bc / SS(fs)))) break;
   \   0000002C   ........           BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_42:
   \   00000030   0028               CMP      R0,#+0
   \   00000032   45D1               BNE.N    ??get_fat_6
    340          		wc = fs->win[bc & (SS(fs) - 1)]; bc++;
   \   00000034   F805               LSLS     R0,R7,#+23
   \   00000036   C00D               LSRS     R0,R0,#+23
   \   00000038   0019               ADDS     R0,R0,R4
   \   0000003A   90F83080           LDRB     R8,[R0, #+48]
   \   0000003E   7F1C               ADDS     R7,R7,#+1
    341          		if (move_window(fs, fsect + (bc / SS(fs)))) break;
   \   00000040   ........           BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_41:
   \   00000044   0028               CMP      R0,#+0
   \   00000046   3BD1               BNE.N    ??get_fat_6
    342          		wc |= (WORD)fs->win[bc & (SS(fs) - 1)] << 8;
   \   00000048   F805               LSLS     R0,R7,#+23
   \   0000004A   C00D               LSRS     R0,R0,#+23
   \   0000004C   0019               ADDS     R0,R0,R4
   \   0000004E   90F83000           LDRB     R0,[R0, #+48]
   \   00000052   48EA0021           ORR      R1,R8,R0, LSL #+8
    343          		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
   \   00000056   15F0010F           TST      R5,#0x1
   \   0000005A   02D0               BEQ.N    ??get_fat_7
   \   0000005C   0809               LSRS     R0,R1,#+4
   \                     ??get_fat_2:
   \   0000005E   BDE8F081           POP      {R4-R8,PC}
   \                     ??get_fat_7:
   \   00000062   0805               LSLS     R0,R1,#+20
   \   00000064   000D               LSRS     R0,R0,#+20
   \   00000066   FAE7               B.N      ??get_fat_2
    344          
    345          	case FS_FAT16 :
    346          		if (move_window(fs, fsect + (clst / (SS(fs) / 2)))) break;
   \                     ??get_fat_4:
   \   00000068   06EB1521           ADD      R1,R6,R5, LSR #+8
   \   0000006C   ........           BL       ??Subroutine21_0
   \                     ??CrossCallReturnLabel_40:
   \   00000070   0028               CMP      R0,#+0
   \   00000072   25D1               BNE.N    ??get_fat_6
    347          		return LD_WORD(&fs->win[((WORD)clst * 2) & (SS(fs) - 1)]);
   \   00000074   6800               LSLS     R0,R5,#+1
   \   00000076   C005               LSLS     R0,R0,#+23
   \   00000078   C00D               LSRS     R0,R0,#+23
   \   0000007A   0019               ADDS     R0,R0,R4
   \   0000007C   00F13001           ADD      R1,R0,#+48
   \   00000080   4978               LDRB     R1,[R1, #+1]
   \   00000082   90F83000           LDRB     R0,[R0, #+48]
   \   00000086   40EA0120           ORR      R0,R0,R1, LSL #+8
   \   0000008A   E8E7               B.N      ??get_fat_2
    348          
    349          	case FS_FAT32 :
    350          		if (move_window(fs, fsect + (clst / (SS(fs) / 4)))) break;
   \                     ??get_fat_5:
   \   0000008C   06EBD511           ADD      R1,R6,R5, LSR #+7
   \   00000090   ........           BL       ??Subroutine21_0
   \                     ??CrossCallReturnLabel_39:
   \   00000094   0028               CMP      R0,#+0
   \   00000096   13D1               BNE.N    ??get_fat_6
    351          		return LD_DWORD(&fs->win[((WORD)clst * 4) & (SS(fs) - 1)]) & 0x0FFFFFFF;
   \   00000098   A800               LSLS     R0,R5,#+2
   \   0000009A   C005               LSLS     R0,R0,#+23
   \   0000009C   C00D               LSRS     R0,R0,#+23
   \   0000009E   0019               ADDS     R0,R0,R4
   \   000000A0   00F13001           ADD      R1,R0,#+48
   \   000000A4   CA78               LDRB     R2,[R1, #+3]
   \   000000A6   8B78               LDRB     R3,[R1, #+2]
   \   000000A8   1B04               LSLS     R3,R3,#+16
   \   000000AA   43EA0262           ORR      R2,R3,R2, LSL #+24
   \   000000AE   4978               LDRB     R1,[R1, #+1]
   \   000000B0   42EA0121           ORR      R1,R2,R1, LSL #+8
   \   000000B4   90F83000           LDRB     R0,[R0, #+48]
   \   000000B8   0843               ORRS     R0,R0,R1
   \   000000BA   0001               LSLS     R0,R0,#+4
   \   000000BC   0009               LSRS     R0,R0,#+4
   \   000000BE   CEE7               B.N      ??get_fat_2
    352          	}
    353          
    354          	return 0xFFFFFFFF;	/* An error occured at the disk I/O layer */
   \                     ??get_fat_6:
   \   000000C0   4FF0FF30           MOV      R0,#-1
   \   000000C4   CBE7               B.N      ??get_fat_2
    355          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?Subroutine8:
   \   00000000   06EB5721           ADD      R1,R6,R7, LSR #+9
   \   00000004                      REQUIRE ??Subroutine21_0
   \   00000004                      ;; // Fall through to label ??Subroutine21_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine21_0:
   \   00000000   2046               MOV      R0,R4
   \   00000002   ....               B.N      move_window
    356          
    357          
    358          
    359          
    360          /*-----------------------------------------------------------------------*/
    361          /* FAT access - Change value of a FAT entry                              */
    362          /*-----------------------------------------------------------------------*/
    363          #if !_FS_READONLY
    364          

   \                                 In section .text, align 2, keep-with-next
    365          FRESULT put_fat (
    366          	FATFS *fs,	/* File system object */
    367          	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->max_clust - 1 */
    368          	DWORD val	/* New value to mark the cluster */
    369          )
    370          {
   \                     put_fat:
   \   00000000   2DE9F041           PUSH     {R4-R8,LR}
   \   00000004   0546               MOV      R5,R0
   \   00000006   0E46               MOV      R6,R1
   \   00000008   1446               MOV      R4,R2
    371          	UINT bc;
    372          	BYTE *p;
    373          	DWORD fsect;
    374          	FRESULT res;
    375          
    376          
    377          	if (clst < 2 || clst >= fs->max_clust) {	/* Range check */
   \   0000000A   022E               CMP      R6,#+2
   \   0000000C   02D3               BCC.N    ??put_fat_0
   \   0000000E   E869               LDR      R0,[R5, #+28]
   \   00000010   8642               CMP      R6,R0
   \   00000012   01D3               BCC.N    ??put_fat_1
    378          		res = FR_INT_ERR;
   \                     ??put_fat_0:
   \   00000014   0220               MOVS     R0,#+2
   \   00000016   5EE0               B.N      ??put_fat_2
    379          
    380          	} else {
    381          		fsect = fs->fatbase;
   \                     ??put_fat_1:
   \   00000018   D5F82080           LDR      R8,[R5, #+32]
    382          		switch (fs->fs_type) {
   \   0000001C   2004               LSLS     R0,R4,#+16
   \   0000001E   070E               LSRS     R7,R0,#+24
   \   00000020   2878               LDRB     R0,[R5, #+0]
   \   00000022   0128               CMP      R0,#+1
   \   00000024   04D0               BEQ.N    ??put_fat_3
   \   00000026   0228               CMP      R0,#+2
   \   00000028   30D0               BEQ.N    ??put_fat_4
   \   0000002A   0328               CMP      R0,#+3
   \   0000002C   3DD0               BEQ.N    ??put_fat_5
   \   0000002E   4FE0               B.N      ??put_fat_6
    383          		case FS_FAT12 :
    384          			bc = clst; bc += bc / 2;
   \                     ??put_fat_3:
   \   00000030   06EB5607           ADD      R7,R6,R6, LSR #+1
    385          			res = move_window(fs, fsect + (bc / SS(fs)));
   \   00000034   ........           BL       ?Subroutine9
    386          			if (res != FR_OK) break;
   \                     ??CrossCallReturnLabel_46:
   \   00000038   0028               CMP      R0,#+0
   \   0000003A   4AD1               BNE.N    ??put_fat_7
    387          			p = &fs->win[bc & (SS(fs) - 1)];
   \   0000003C   F805               LSLS     R0,R7,#+23
   \   0000003E   C00D               LSRS     R0,R0,#+23
   \   00000040   4019               ADDS     R0,R0,R5
   \   00000042   00F13001           ADD      R1,R0,#+48
    388          			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
   \   00000046   16F0010F           TST      R6,#0x1
   \   0000004A   1DBF               ITTTE    NE 
   \   0000004C   0878               LDRBNE   R0,[R1, #+0]
   \   0000004E   00F00F00           ANDNE    R0,R0,#0xF
   \   00000052   40EA0410           ORRNE    R0,R0,R4, LSL #+4
   \   00000056   2046               MOVEQ    R0,R4
   \   00000058   0870               STRB     R0,[R1, #+0]
    389          			bc++;
   \   0000005A   7F1C               ADDS     R7,R7,#+1
    390          			fs->wflag = 1;
   \   0000005C   0120               MOVS     R0,#+1
   \   0000005E   2871               STRB     R0,[R5, #+4]
    391          			res = move_window(fs, fsect + (bc / SS(fs)));
   \   00000060   ........           BL       ?Subroutine9
    392          			if (res != FR_OK) break;
   \                     ??CrossCallReturnLabel_45:
   \   00000064   0028               CMP      R0,#+0
   \   00000066   34D1               BNE.N    ??put_fat_7
    393          			p = &fs->win[bc & (SS(fs) - 1)];
   \   00000068   F905               LSLS     R1,R7,#+23
   \   0000006A   C90D               LSRS     R1,R1,#+23
   \   0000006C   4919               ADDS     R1,R1,R5
   \   0000006E   3031               ADDS     R1,R1,#+48
    394          			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
   \   00000070   16F0010F           TST      R6,#0x1
   \   00000074   01D0               BEQ.N    ??put_fat_8
   \   00000076   2209               LSRS     R2,R4,#+4
   \   00000078   06E0               B.N      ??put_fat_9
   \                     ??put_fat_8:
   \   0000007A   0A78               LDRB     R2,[R1, #+0]
   \   0000007C   02F0F002           AND      R2,R2,#0xF0
   \   00000080   230A               LSRS     R3,R4,#+8
   \   00000082   03F00F03           AND      R3,R3,#0xF
   \   00000086   1A43               ORRS     R2,R3,R2
   \                     ??put_fat_9:
   \   00000088   0A70               STRB     R2,[R1, #+0]
   \   0000008A   22E0               B.N      ??put_fat_7
    395          			break;
    396          
    397          		case FS_FAT16 :
    398          			res = move_window(fs, fsect + (clst / (SS(fs) / 2)));
   \                     ??put_fat_4:
   \   0000008C   08EB1621           ADD      R1,R8,R6, LSR #+8
   \   00000090   ........           BL       ??Subroutine22_0
    399          			if (res != FR_OK) break;
   \                     ??CrossCallReturnLabel_44:
   \   00000094   0028               CMP      R0,#+0
   \   00000096   1CD1               BNE.N    ??put_fat_7
    400          			ST_WORD(&fs->win[((WORD)clst * 2) & (SS(fs) - 1)], (WORD)val);
   \   00000098   7100               LSLS     R1,R6,#+1
   \   0000009A   C905               LSLS     R1,R1,#+23
   \   0000009C   C90D               LSRS     R1,R1,#+23
   \   0000009E   4919               ADDS     R1,R1,R5
   \   000000A0   81F83040           STRB     R4,[R1, #+48]
   \   000000A4   3031               ADDS     R1,R1,#+48
   \   000000A6   4F70               STRB     R7,[R1, #+1]
   \   000000A8   13E0               B.N      ??put_fat_7
    401          			break;
    402          
    403          		case FS_FAT32 :
    404          			res = move_window(fs, fsect + (clst / (SS(fs) / 4)));
   \                     ??put_fat_5:
   \   000000AA   08EBD611           ADD      R1,R8,R6, LSR #+7
   \   000000AE   ........           BL       ??Subroutine22_0
    405          			if (res != FR_OK) break;
   \                     ??CrossCallReturnLabel_43:
   \   000000B2   0028               CMP      R0,#+0
   \   000000B4   0DD1               BNE.N    ??put_fat_7
    406          			ST_DWORD(&fs->win[((WORD)clst * 4) & (SS(fs) - 1)], val);
   \   000000B6   B100               LSLS     R1,R6,#+2
   \   000000B8   C905               LSLS     R1,R1,#+23
   \   000000BA   C90D               LSRS     R1,R1,#+23
   \   000000BC   4919               ADDS     R1,R1,R5
   \   000000BE   81F83040           STRB     R4,[R1, #+48]
   \   000000C2   3031               ADDS     R1,R1,#+48
   \   000000C4   4F70               STRB     R7,[R1, #+1]
   \   000000C6   220C               LSRS     R2,R4,#+16
   \   000000C8   8A70               STRB     R2,[R1, #+2]
   \   000000CA   220E               LSRS     R2,R4,#+24
   \   000000CC   CA70               STRB     R2,[R1, #+3]
   \   000000CE   00E0               B.N      ??put_fat_7
    407          			break;
    408          
    409          		default :
    410          			res = FR_INT_ERR;
   \                     ??put_fat_6:
   \   000000D0   0220               MOVS     R0,#+2
    411          		}
    412          		fs->wflag = 1;
   \                     ??put_fat_7:
   \   000000D2   0121               MOVS     R1,#+1
   \   000000D4   2971               STRB     R1,[R5, #+4]
    413          	}
    414          
    415          	return res;
   \                     ??put_fat_2:
   \   000000D6   BDE8F081           POP      {R4-R8,PC}       ;; return
    416          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?Subroutine9:
   \   00000000   08EB5721           ADD      R1,R8,R7, LSR #+9
   \   00000004                      REQUIRE ??Subroutine22_0
   \   00000004                      ;; // Fall through to label ??Subroutine22_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine22_0:
   \   00000000   2846               MOV      R0,R5
   \   00000002   ....               B.N      move_window
    417          #endif /* !_FS_READONLY */
    418          
    419          
    420          
    421          
    422          /*-----------------------------------------------------------------------*/
    423          /* FAT handling - Remove a cluster chain                                 */
    424          /*-----------------------------------------------------------------------*/
    425          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    426          static
    427          FRESULT remove_chain (
    428          	FATFS *fs,			/* File system object */
    429          	DWORD clst			/* Cluster# to remove a chain from */
    430          )
    431          {
   \                     remove_chain:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0546               MOV      R5,R0
   \   00000004   0C46               MOV      R4,R1
    432          	FRESULT res;
    433          	DWORD nxt;
    434          
    435          
    436          	if (clst < 2 || clst >= fs->max_clust) {	/* Check the range of cluster# */
   \   00000006   022C               CMP      R4,#+2
   \   00000008   02D3               BCC.N    ??remove_chain_0
   \   0000000A   E869               LDR      R0,[R5, #+28]
   \   0000000C   8442               CMP      R4,R0
   \   0000000E   01D3               BCC.N    ??remove_chain_1
    437          		res = FR_INT_ERR;
   \                     ??remove_chain_0:
   \   00000010   0227               MOVS     R7,#+2
   \   00000012   22E0               B.N      ??remove_chain_2
    438          
    439          	} else {
    440          		res = FR_OK;
   \                     ??remove_chain_1:
   \   00000014   0027               MOVS     R7,#+0
    441          		while (clst < fs->max_clust) {			/* Not a last link? */
    442          			nxt = get_fat(fs, clst);			/* Get cluster status */
   \                     ??remove_chain_3:
   \   00000016   2146               MOV      R1,R4
   \   00000018   2846               MOV      R0,R5
   \   0000001A   ........           BL       get_fat
   \   0000001E   0600               MOVS     R6,R0
    443          			if (nxt == 0) break;				/* Empty cluster? */
   \   00000020   1BD0               BEQ.N    ??remove_chain_2
    444          			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
   \   00000022   012E               CMP      R6,#+1
   \   00000024   F4D0               BEQ.N    ??remove_chain_0
    445          			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
   \   00000026   4FF0FF30           MOV      R0,#-1
   \   0000002A   8642               CMP      R6,R0
   \   0000002C   01D1               BNE.N    ??remove_chain_4
   \   0000002E   0127               MOVS     R7,#+1
   \   00000030   13E0               B.N      ??remove_chain_2
    446          			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
   \                     ??remove_chain_4:
   \   00000032   0022               MOVS     R2,#+0
   \   00000034   2146               MOV      R1,R4
   \   00000036   2846               MOV      R0,R5
   \   00000038   ........           BL       put_fat
   \   0000003C   0700               MOVS     R7,R0
    447          			if (res != FR_OK) break;
   \   0000003E   0CD1               BNE.N    ??remove_chain_2
    448          			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
   \   00000040   2869               LDR      R0,[R5, #+16]
   \   00000042   4FF0FF31           MOV      R1,#-1
   \   00000046   8842               CMP      R0,R1
   \   00000048   03D0               BEQ.N    ??remove_chain_5
    449          				fs->free_clust++;
   \   0000004A   401C               ADDS     R0,R0,#+1
   \   0000004C   2861               STR      R0,[R5, #+16]
    450          				fs->fsi_flag = 1;
   \   0000004E   0120               MOVS     R0,#+1
   \   00000050   6871               STRB     R0,[R5, #+5]
    451          			}
    452          			clst = nxt;	/* Next cluster */
   \                     ??remove_chain_5:
   \   00000052   3446               MOV      R4,R6
    453          		}
   \   00000054   E869               LDR      R0,[R5, #+28]
   \   00000056   8442               CMP      R4,R0
   \   00000058   DDD3               BCC.N    ??remove_chain_3
    454          	}
    455          
    456          	return res;
   \                     ??remove_chain_2:
   \   0000005A   3846               MOV      R0,R7
   \   0000005C   F2BD               POP      {R1,R4-R7,PC}    ;; return
    457          }
    458          #endif
    459          
    460          
    461          
    462          
    463          /*-----------------------------------------------------------------------*/
    464          /* FAT handling - Stretch or Create a cluster chain                      */
    465          /*-----------------------------------------------------------------------*/
    466          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    467          static
    468          DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
    469          	FATFS *fs,			/* File system object */
    470          	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
    471          )
    472          {
   \                     create_chain:
   \   00000000   2DE9F041           PUSH     {R4-R8,LR}
   \   00000004   0446               MOV      R4,R0
   \   00000006   0E00               MOVS     R6,R1
    473          	DWORD cs, ncl, scl, mcl;
    474          
    475          
    476          	mcl = fs->max_clust;
   \   00000008   D4F81C80           LDR      R8,[R4, #+28]
    477          	if (clst == 0) {		/* Create new chain */
   \   0000000C   05D1               BNE.N    ??create_chain_0
    478          		scl = fs->last_clust;			/* Get suggested start point */
   \   0000000E   E768               LDR      R7,[R4, #+12]
    479          		if (scl == 0 || scl >= mcl) scl = 1;
   \   00000010   0FB1               CBZ      R7,??create_chain_1
   \   00000012   4745               CMP      R7,R8
   \   00000014   0AD3               BCC.N    ??create_chain_2
   \                     ??create_chain_1:
   \   00000016   0127               MOVS     R7,#+1
   \   00000018   08E0               B.N      ??create_chain_2
    480          	}
    481          	else {					/* Stretch existing chain */
    482          		cs = get_fat(fs, clst);			/* Check the cluster status */
   \                     ??create_chain_0:
   \   0000001A   ........           BL       get_fat
    483          		if (cs < 2) return 1;			/* It is an invalid cluster */
   \   0000001E   0228               CMP      R0,#+2
   \   00000020   01D2               BCS.N    ??create_chain_3
   \   00000022   0120               MOVS     R0,#+1
   \   00000024   13E0               B.N      ??create_chain_4
    484          		if (cs < mcl) return cs;		/* It is already followed by next cluster */
   \                     ??create_chain_3:
   \   00000026   4045               CMP      R0,R8
   \   00000028   11D3               BCC.N    ??create_chain_4
    485          		scl = clst;
   \   0000002A   3746               MOV      R7,R6
    486          	}
    487          
    488          	ncl = scl;				/* Start cluster */
   \                     ??create_chain_2:
   \   0000002C   3D46               MOV      R5,R7
   \   0000002E   07E0               B.N      ??create_chain_5
    489          	for (;;) {
    490          		ncl++;							/* Next cluster */
    491          		if (ncl >= mcl) {				/* Wrap around */
    492          			ncl = 2;
    493          			if (ncl > scl) return 0;	/* No free custer */
    494          		}
    495          		cs = get_fat(fs, ncl);			/* Get the cluster status */
    496          		if (cs == 0) break;				/* Found a free cluster */
    497          		if (cs == 0xFFFFFFFF || cs == 1)/* An error occured */
   \                     ??create_chain_6:
   \   00000030   4FF0FF31           MOV      R1,#-1
   \   00000034   8842               CMP      R0,R1
   \   00000036   0AD0               BEQ.N    ??create_chain_4
   \   00000038   0128               CMP      R0,#+1
   \   0000003A   08D0               BEQ.N    ??create_chain_4
    498          			return cs;
    499          		if (ncl == scl) return 0;		/* No free custer */
   \   0000003C   BD42               CMP      R5,R7
   \   0000003E   05D0               BEQ.N    ??create_chain_7
   \                     ??create_chain_5:
   \   00000040   6D1C               ADDS     R5,R5,#+1
   \   00000042   4545               CMP      R5,R8
   \   00000044   05D3               BCC.N    ??create_chain_8
   \   00000046   0225               MOVS     R5,#+2
   \   00000048   022F               CMP      R7,#+2
   \   0000004A   02D2               BCS.N    ??create_chain_8
   \                     ??create_chain_7:
   \   0000004C   0020               MOVS     R0,#+0
   \                     ??create_chain_4:
   \   0000004E   BDE8F081           POP      {R4-R8,PC}
   \                     ??create_chain_8:
   \   00000052   2946               MOV      R1,R5
   \   00000054   2046               MOV      R0,R4
   \   00000056   ........           BL       get_fat
   \   0000005A   0028               CMP      R0,#+0
   \   0000005C   E8D1               BNE.N    ??create_chain_6
    500          	}
    501          
    502          	if (put_fat(fs, ncl, 0x0FFFFFFF))	/* Mark the new cluster "in use" */
   \   0000005E   6FF07042           MVN      R2,#-268435456
   \   00000062   2946               MOV      R1,R5
   \   00000064   2046               MOV      R0,R4
   \   00000066   ........           BL       put_fat
   \   0000006A   0028               CMP      R0,#+0
   \   0000006C   02D0               BEQ.N    ??create_chain_9
    503          		return 0xFFFFFFFF;
   \                     ??create_chain_10:
   \   0000006E   4FF0FF30           MOV      R0,#-1
   \   00000072   ECE7               B.N      ??create_chain_4
    504          	if (clst != 0) {					/* Link it to the previous one if needed */
   \                     ??create_chain_9:
   \   00000074   36B1               CBZ      R6,??create_chain_11
    505          		if (put_fat(fs, clst, ncl))
   \   00000076   2A46               MOV      R2,R5
   \   00000078   3146               MOV      R1,R6
   \   0000007A   2046               MOV      R0,R4
   \   0000007C   ........           BL       put_fat
   \   00000080   0028               CMP      R0,#+0
   \   00000082   F4D1               BNE.N    ??create_chain_10
    506          			return 0xFFFFFFFF;
    507          	}
    508          
    509          	fs->last_clust = ncl;				/* Update FSINFO */
   \                     ??create_chain_11:
   \   00000084   E560               STR      R5,[R4, #+12]
    510          	if (fs->free_clust != 0xFFFFFFFF) {
   \   00000086   2069               LDR      R0,[R4, #+16]
   \   00000088   4FF0FF31           MOV      R1,#-1
   \   0000008C   8842               CMP      R0,R1
   \   0000008E   03D0               BEQ.N    ??create_chain_12
    511          		fs->free_clust--;
   \   00000090   401E               SUBS     R0,R0,#+1
   \   00000092   2061               STR      R0,[R4, #+16]
    512          		fs->fsi_flag = 1;
   \   00000094   0120               MOVS     R0,#+1
   \   00000096   6071               STRB     R0,[R4, #+5]
    513          	}
    514          
    515          	return ncl;		/* Return new cluster number */
   \                     ??create_chain_12:
   \   00000098   2846               MOV      R0,R5
   \                     ??create_chain_13:
   \   0000009A   D8E7               B.N      ??create_chain_4
    516          }
    517          #endif /* !_FS_READONLY */
    518          
    519          
    520          
    521          
    522          /*-----------------------------------------------------------------------*/
    523          /* Get sector# from cluster#                                             */
    524          /*-----------------------------------------------------------------------*/
    525          
    526          

   \                                 In section .text, align 2, keep-with-next
    527          DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
    528          	FATFS *fs,		/* File system object */
    529          	DWORD clst		/* Cluster# to be converted */
    530          )
    531          {
    532          	clst -= 2;
   \                     clust2sect:
   \   00000000   891E               SUBS     R1,R1,#+2
    533          	if (clst >= (fs->max_clust - 2)) return 0;		/* Invalid cluster# */
   \   00000002   C269               LDR      R2,[R0, #+28]
   \   00000004   921E               SUBS     R2,R2,#+2
   \   00000006   9142               CMP      R1,R2
   \   00000008   01D3               BCC.N    ??clust2sect_0
   \   0000000A   0020               MOVS     R0,#+0
   \   0000000C   7047               BX       LR
    534          	return clst * fs->csize + fs->database;
   \                     ??clust2sect_0:
   \   0000000E   8278               LDRB     R2,[R0, #+2]
   \   00000010   806A               LDR      R0,[R0, #+40]
   \   00000012   01FB0200           MLA      R0,R1,R2,R0
   \   00000016   7047               BX       LR               ;; return
    535          }
    536          
    537          
    538          
    539          
    540          /*-----------------------------------------------------------------------*/
    541          /* Directory handling - Seek directory index                             */
    542          /*-----------------------------------------------------------------------*/
    543          

   \                                 In section .text, align 2, keep-with-next
    544          static
    545          FRESULT dir_seek (
    546          	DIR *dj,		/* Pointer to directory object */
    547          	WORD idx		/* Directory index number */
    548          )
    549          {
   \                     dir_seek:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0446               MOV      R4,R0
   \   00000004   0D46               MOV      R5,R1
    550          	DWORD clst;
    551          	WORD ic;
    552          
    553          
    554          	dj->index = idx;
   \   00000006   E580               STRH     R5,[R4, #+6]
    555          	clst = dj->sclust;
   \   00000008   A068               LDR      R0,[R4, #+8]
    556          	if (clst == 1 || clst >= dj->fs->max_clust)	/* Check start cluster range */
   \   0000000A   0128               CMP      R0,#+1
   \   0000000C   03D0               BEQ.N    ??dir_seek_0
   \   0000000E   2168               LDR      R1,[R4, #+0]
   \   00000010   CA69               LDR      R2,[R1, #+28]
   \   00000012   9042               CMP      R0,R2
   \   00000014   01D3               BCC.N    ??dir_seek_1
    557          		return FR_INT_ERR;
   \                     ??dir_seek_0:
   \   00000016   0220               MOVS     R0,#+2
   \   00000018   70BD               POP      {R4-R6,PC}
    558          	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
   \                     ??dir_seek_1:
   \   0000001A   18B9               CBNZ     R0,??dir_seek_2
   \   0000001C   0878               LDRB     R0,[R1, #+0]
   \   0000001E   0328               CMP      R0,#+3
   \   00000020   01D1               BNE.N    ??dir_seek_3
    559          		clst = dj->fs->dirbase;
   \   00000022   486A               LDR      R0,[R1, #+36]
    560          
    561          	if (clst == 0) {	/* Static table */
   \                     ??dir_seek_2:
   \   00000024   30B9               CBNZ     R0,??dir_seek_4
    562          		dj->clust = clst;
   \                     ??dir_seek_3:
   \   00000026   0020               MOVS     R0,#+0
   \   00000028   E060               STR      R0,[R4, #+12]
    563          		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
   \   0000002A   0889               LDRH     R0,[R1, #+8]
   \   0000002C   8542               CMP      R5,R0
   \   0000002E   F2D2               BCS.N    ??dir_seek_0
    564          			return FR_INT_ERR;
    565          		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / 32);	/* Sector# */
   \   00000030   486A               LDR      R0,[R1, #+36]
   \   00000032   1CE0               B.N      ??dir_seek_5
    566          	}
    567          	else {				/* Dynamic table */
    568          		ic = SS(dj->fs) / 32 * dj->fs->csize;	/* Entries per cluster */
   \                     ??dir_seek_4:
   \   00000034   8978               LDRB     R1,[R1, #+2]
   \   00000036   0E01               LSLS     R6,R1,#+4
   \   00000038   06E0               B.N      ??dir_seek_6
    569          		while (idx >= ic) {	/* Follow cluster chain */
    570          			clst = get_fat(dj->fs, clst);				/* Get next cluster */
    571          			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    572          			if (clst < 2 || clst >= dj->fs->max_clust)	/* Reached to end of table or int error */
   \                     ??dir_seek_7:
   \   0000003A   0228               CMP      R0,#+2
   \   0000003C   EBD3               BCC.N    ??dir_seek_0
   \   0000003E   2168               LDR      R1,[R4, #+0]
   \   00000040   C969               LDR      R1,[R1, #+28]
   \   00000042   8842               CMP      R0,R1
   \   00000044   E7D2               BCS.N    ??dir_seek_0
    573          				return FR_INT_ERR;
    574          			idx -= ic;
   \   00000046   AD1B               SUBS     R5,R5,R6
   \                     ??dir_seek_6:
   \   00000048   2268               LDR      R2,[R4, #+0]
   \   0000004A   ADB2               UXTH     R5,R5
   \   0000004C   B542               CMP      R5,R6
   \   0000004E   09D3               BCC.N    ??dir_seek_8
   \   00000050   0146               MOV      R1,R0
   \   00000052   1046               MOV      R0,R2
   \   00000054   ........           BL       get_fat
   \   00000058   4FF0FF31           MOV      R1,#-1
   \   0000005C   8842               CMP      R0,R1
   \   0000005E   ECD1               BNE.N    ??dir_seek_7
   \   00000060   0120               MOVS     R0,#+1
   \   00000062   70BD               POP      {R4-R6,PC}
    575          		}
    576          		dj->clust = clst;
   \                     ??dir_seek_8:
   \   00000064   E060               STR      R0,[R4, #+12]
    577          		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / 32);	/* Sector# */
   \   00000066   0146               MOV      R1,R0
   \   00000068   1046               MOV      R0,R2
   \   0000006A   ........           BL       clust2sect
   \                     ??dir_seek_5:
   \   0000006E   00EB1510           ADD      R0,R0,R5, LSR #+4
   \   00000072   2061               STR      R0,[R4, #+16]
    578          	}
    579          
    580          	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / 32)) * 32;	/* Ptr to the entry in the sector */
   \   00000074   05F00F00           AND      R0,R5,#0xF
   \   00000078   2168               LDR      R1,[R4, #+0]
   \   0000007A   01EB4010           ADD      R0,R1,R0, LSL #+5
   \   0000007E   3030               ADDS     R0,R0,#+48
   \   00000080   6061               STR      R0,[R4, #+20]
    581          
    582          	return FR_OK;	/* Seek succeeded */
   \   00000082   0020               MOVS     R0,#+0
   \   00000084   70BD               POP      {R4-R6,PC}       ;; return
    583          }
    584          
    585          
    586          
    587          
    588          /*-----------------------------------------------------------------------*/
    589          /* Directory handling - Move directory index next                        */
    590          /*-----------------------------------------------------------------------*/
    591          

   \                                 In section .text, align 2, keep-with-next
    592          static
    593          FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not streach */
    594          	DIR *dj,		/* Pointer to directory object */
    595          	BOOL streach	/* False: Do not streach table, True: Streach table if needed */
    596          )
    597          {
   \                     dir_next:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0446               MOV      R4,R0
   \   00000004   0F46               MOV      R7,R1
    598          	DWORD clst;
    599          	WORD i;
    600          
    601          
    602          	i = dj->index + 1;
   \   00000006   E088               LDRH     R0,[R4, #+6]
   \   00000008   451C               ADDS     R5,R0,#+1
   \   0000000A   ADB2               UXTH     R5,R5
    603          	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
   \   0000000C   2800               MOVS     R0,R5
   \   0000000E   02D0               BEQ.N    ??dir_next_0
   \   00000010   2069               LDR      R0,[R4, #+16]
   \   00000012   0028               CMP      R0,#+0
   \   00000014   01D1               BNE.N    ??dir_next_1
    604          		return FR_NO_FILE;
   \                     ??dir_next_0:
   \   00000016   0420               MOVS     R0,#+4
   \   00000018   F2BD               POP      {R1,R4-R7,PC}
    605          
    606          	if (!(i % (SS(dj->fs) / 32))) {	/* Sector changed? */
   \                     ??dir_next_1:
   \   0000001A   15F00F0F           TST      R5,#0xF
   \   0000001E   57D1               BNE.N    ??dir_next_2
    607          		dj->sect++;					/* Next sector */
   \   00000020   401C               ADDS     R0,R0,#+1
   \   00000022   2061               STR      R0,[R4, #+16]
    608          
    609          		if (dj->clust == 0) {	/* Static table */
   \   00000024   E168               LDR      R1,[R4, #+12]
   \   00000026   2068               LDR      R0,[R4, #+0]
   \   00000028   19B9               CBNZ     R1,??dir_next_3
    610          			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
   \   0000002A   0089               LDRH     R0,[R0, #+8]
   \   0000002C   8542               CMP      R5,R0
   \   0000002E   4FD3               BCC.N    ??dir_next_2
   \   00000030   F1E7               B.N      ??dir_next_0
    611          				return FR_NO_FILE;
    612          		}
    613          		else {					/* Dynamic table */
    614          			if (((i / (SS(dj->fs) / 32)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
   \                     ??dir_next_3:
   \   00000032   8278               LDRB     R2,[R0, #+2]
   \   00000034   521E               SUBS     R2,R2,#+1
   \   00000036   12EA151F           TST      R2,R5, LSR #+4
   \   0000003A   49D1               BNE.N    ??dir_next_2
    615          				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
   \   0000003C   ........           BL       get_fat
   \   00000040   0646               MOV      R6,R0
    616          				if (clst <= 1) return FR_INT_ERR;
   \   00000042   022E               CMP      R6,#+2
   \   00000044   01D2               BCS.N    ??dir_next_4
   \                     ??dir_next_5:
   \   00000046   0220               MOVS     R0,#+2
   \   00000048   F2BD               POP      {R1,R4-R7,PC}
    617          				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   \                     ??dir_next_4:
   \   0000004A   4FF0FF30           MOV      R0,#-1
   \   0000004E   8642               CMP      R6,R0
   \   00000050   01D1               BNE.N    ??dir_next_6
   \                     ??dir_next_7:
   \   00000052   0120               MOVS     R0,#+1
   \   00000054   F2BD               POP      {R1,R4-R7,PC}
    618          				if (clst >= dj->fs->max_clust) {				/* When it reached end of dynamic table */
   \                     ??dir_next_6:
   \   00000056   2068               LDR      R0,[R4, #+0]
   \   00000058   C169               LDR      R1,[R0, #+28]
   \   0000005A   8E42               CMP      R6,R1
   \   0000005C   34D3               BCC.N    ??dir_next_8
    619          #if !_FS_READONLY
    620          					BYTE c;
    621          					if (!streach) return FR_NO_FILE;			/* When do not streach, report EOT */
   \   0000005E   002F               CMP      R7,#+0
   \   00000060   D9D0               BEQ.N    ??dir_next_0
    622          					clst = create_chain(dj->fs, dj->clust);		/* Streach cluster chain */
   \   00000062   E168               LDR      R1,[R4, #+12]
   \   00000064   ........           BL       create_chain
   \   00000068   0600               MOVS     R6,R0
    623          					if (clst == 0) return FR_DENIED;			/* No free cluster */
   \   0000006A   01D1               BNE.N    ??dir_next_9
   \   0000006C   0720               MOVS     R0,#+7
   \   0000006E   F2BD               POP      {R1,R4-R7,PC}
    624          					if (clst == 1) return FR_INT_ERR;
   \                     ??dir_next_9:
   \   00000070   012E               CMP      R6,#+1
   \   00000072   E8D0               BEQ.N    ??dir_next_5
    625          					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   \   00000074   4FF0FF30           MOV      R0,#-1
   \   00000078   8642               CMP      R6,R0
   \   0000007A   EAD0               BEQ.N    ??dir_next_7
    626          					/* Clean-up streached table */
    627          					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
   \   0000007C   0021               MOVS     R1,#+0
   \   0000007E   ........           BL       ??Subroutine23_0
   \                     ??CrossCallReturnLabel_50:
   \   00000082   0028               CMP      R0,#+0
   \   00000084   E5D1               BNE.N    ??dir_next_7
    628          					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
   \   00000086   4FF40072           MOV      R2,#+512
   \   0000008A   0021               MOVS     R1,#+0
   \   0000008C   2068               LDR      R0,[R4, #+0]
   \   0000008E   3030               ADDS     R0,R0,#+48
   \   00000090   ........           BL       mem_set
    629          					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
   \   00000094   ........           BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_59:
   \   00000098   2168               LDR      R1,[R4, #+0]
   \   0000009A   C862               STR      R0,[R1, #+44]
    630          					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
   \   0000009C   0027               MOVS     R7,#+0
   \   0000009E   0CE0               B.N      ??dir_next_10
    631          						dj->fs->wflag = 1;
   \                     ??dir_next_11:
   \   000000A0   0121               MOVS     R1,#+1
   \   000000A2   0171               STRB     R1,[R0, #+4]
    632          						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
   \   000000A4   0021               MOVS     R1,#+0
   \   000000A6   ........           BL       ??Subroutine23_0
   \                     ??CrossCallReturnLabel_49:
   \   000000AA   0028               CMP      R0,#+0
   \   000000AC   D1D1               BNE.N    ??dir_next_7
    633          						dj->fs->winsect++;
   \   000000AE   2068               LDR      R0,[R4, #+0]
   \   000000B0   C16A               LDR      R1,[R0, #+44]
   \   000000B2   491C               ADDS     R1,R1,#+1
   \   000000B4   C162               STR      R1,[R0, #+44]
    634          					}
   \   000000B6   7F1C               ADDS     R7,R7,#+1
   \   000000B8   FFB2               UXTB     R7,R7
   \                     ??dir_next_10:
   \   000000BA   2068               LDR      R0,[R4, #+0]
   \   000000BC   8278               LDRB     R2,[R0, #+2]
   \   000000BE   9742               CMP      R7,R2
   \   000000C0   EED3               BCC.N    ??dir_next_11
    635          					dj->fs->winsect -= c;						/* Rewind window address */
   \   000000C2   C16A               LDR      R1,[R0, #+44]
   \   000000C4   C91B               SUBS     R1,R1,R7
   \   000000C6   C162               STR      R1,[R0, #+44]
    636          #else
    637          					return FR_NO_FILE;			/* Report EOT */
    638          #endif
    639          				}
    640          				dj->clust = clst;				/* Initialize data for new cluster */
   \                     ??dir_next_8:
   \   000000C8   E660               STR      R6,[R4, #+12]
    641          				dj->sect = clust2sect(dj->fs, clst);
   \   000000CA   ........           BL       ?Subroutine11
    642          			}
    643          		}
    644          	}
   \                     ??CrossCallReturnLabel_58:
   \   000000CE   2061               STR      R0,[R4, #+16]
    645          
    646          	dj->index = i;
   \                     ??dir_next_2:
   \   000000D0   E580               STRH     R5,[R4, #+6]
    647          	dj->dir = dj->fs->win + (i % (SS(dj->fs) / 32)) * 32;
   \   000000D2   05F00F00           AND      R0,R5,#0xF
   \   000000D6   2168               LDR      R1,[R4, #+0]
   \   000000D8   01EB4010           ADD      R0,R1,R0, LSL #+5
   \   000000DC   3030               ADDS     R0,R0,#+48
   \   000000DE   6061               STR      R0,[R4, #+20]
    648          
    649          	return FR_OK;
   \   000000E0   0020               MOVS     R0,#+0
   \   000000E2   F2BD               POP      {R1,R4-R7,PC}    ;; return
    650          }

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine23_0:
   \   00000000   2068               LDR      R0,[R4, #+0]
   \   00000002   ....               B.N      move_window

   \                                 In section .text, align 4, keep-with-next
   \                     ?Subroutine11:
   \   00000000   3146               MOV      R1,R6
   \   00000002   00BF               Nop      
   \   00000004                      REQUIRE ??Subroutine24_0
   \   00000004                      ;; // Fall through to label ??Subroutine24_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine24_0:
   \   00000000   2068               LDR      R0,[R4, #+0]
   \   00000002   ........           B.W      clust2sect
    651          
    652          
    653          
    654          
    655          /*-----------------------------------------------------------------------*/
    656          /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
    657          /*-----------------------------------------------------------------------*/
    658          #if _USE_LFN
    659          static

   \                                 In section .rodata, align 4
    660          const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory entry */
   \                     LfnOfs:
   \   00000000   01030507090E       DC8 1, 3, 5, 7, 9, 14, 16, 18, 20, 22, 24, 28, 30, 0, 0, 0
   \              10121416181C
   \              1E000000    
    661          
    662          
    663          static
    664          BOOL cmp_lfn (			/* True:Matched, False:Not matched */
    665          	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
    666          	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
    667          )
    668          {
    669          	int i, s;
    670          	WCHAR wc, uc;
    671          
    672          
    673          	i = ((dir[LDIR_Ord] & 0xBF) - 1) * 13;	/* Get offset in the LFN buffer */
    674          	s = 0; wc = 1;
    675          	do {
    676          		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
    677          		if (wc) {	/* Last char has not been processed */
    678          			wc = ff_wtoupper(uc);		/* Convert it to upper case */
    679          			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
    680          				return False;			/* Not matched */
    681          		} else {
    682          			if (uc != 0xFFFF) return False;	/* Check filler */
    683          		}
    684          	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
    685          
    686          	if ((dir[LDIR_Ord] & 0x40) && wc && lfnbuf[i])	/* Last segment matched but different length */
    687          		return False;
    688          
    689          	return True;					/* The part of LFN matched */
    690          }
    691          
    692          
    693          
    694          static
    695          BOOL pick_lfn (			/* True:Succeeded, False:Buffer overflow */
    696          	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
    697          	BYTE *dir			/* Pointer to the directory entry */
    698          )
    699          {
    700          	int i, s;
    701          	WCHAR wc, uc;
    702          
    703          
    704          	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
    705          
    706          	s = 0; wc = 1;
    707          	do {
    708          		uc = LD_WORD(dir+LfnOfs[s]);			/* Pick an LFN character from the entry */
    709          		if (wc) {	/* Last char has not been processed */
    710          			if (i >= _MAX_LFN) return False;	/* Buffer overflow? */
    711          			lfnbuf[i++] = wc = uc;				/* Store it */
    712          		} else {
    713          			if (uc != 0xFFFF) return False;		/* Check filler */
    714          		}
    715          	} while (++s < 13);						/* Read all character in the entry */
    716          
    717          	if (dir[LDIR_Ord] & 0x40) {				/* Put terminator if it is the last LFN part */
    718          		if (i >= _MAX_LFN) return False;	/* Buffer overflow? */
    719          		lfnbuf[i] = 0;
    720          	}
    721          
    722          	return True;
    723          }
    724          
    725          
    726          #if !_FS_READONLY
    727          static
    728          void fit_lfn (
    729          	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
    730          	BYTE *dir,				/* Pointer to the directory entry */
    731          	BYTE ord,				/* LFN order (1-20) */
    732          	BYTE sum				/* SFN sum */
    733          )
    734          {
    735          	int i, s;
    736          	WCHAR wc;
    737          
    738          
    739          	dir[LDIR_Chksum] = sum;			/* Set check sum */
    740          	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
    741          	dir[LDIR_Type] = 0;
    742          	ST_WORD(dir+LDIR_FstClusLO, 0);
    743          
    744          	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
    745          	s = wc = 0;
    746          	do {
    747          		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
    748          		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
    749          		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
    750          	} while (++s < 13);
    751          	if (wc == 0xFFFF || !lfnbuf[i]) ord |= 0x40;	/* Bottom LFN part is the start of LFN sequence */
    752          	dir[LDIR_Ord] = ord;			/* Set the LFN order */
    753          }
    754          
    755          #endif
    756          #endif
    757          
    758          
    759          
    760          /*-----------------------------------------------------------------------*/
    761          /* Create numbered name                                                  */
    762          /*-----------------------------------------------------------------------*/
    763          #if _USE_LFN

   \                                 In section .text, align 2, keep-with-next
    764          void gen_numname (
    765          	BYTE *dst,			/* Pointer to genartated SFN */
    766          	const BYTE *src,	/* Pointer to source SFN to be modified */
    767          	const WCHAR *lfn,	/* Pointer to LFN */
    768          	WORD num			/* Sequense number */
    769          )
    770          {
   \                     gen_numname:
   \   00000000   7CB5               PUSH     {R2-R6,LR}
   \   00000002   0546               MOV      R5,R0
   \   00000004   1646               MOV      R6,R2
   \   00000006   1C46               MOV      R4,R3
    771          	char ns[8];
    772          	int i, j;
    773          
    774          
    775          	mem_cpy(dst, src, 11);
   \   00000008   0B22               MOVS     R2,#+11
   \   0000000A   ........           BL       mem_cpy
    776          
    777          	if (num > 5) {	/* On many collisions, generate a hash number instead of sequencial number */
   \   0000000E   062C               CMP      R4,#+6
   \   00000010   09D3               BCC.N    ??gen_numname_0
    778          		do num = (num >> 1) + (num << 15) + (WORD)*lfn++; while (*lfn);
   \                     ??gen_numname_1:
   \   00000012   A4B2               UXTH     R4,R4
   \   00000014   E003               LSLS     R0,R4,#+15
   \   00000016   00EB5400           ADD      R0,R0,R4, LSR #+1
   \   0000001A   3188               LDRH     R1,[R6, #+0]
   \   0000001C   0C18               ADDS     R4,R1,R0
   \   0000001E   36F8020F           LDRH     R0,[R6, #+2]!
   \   00000022   0028               CMP      R0,#+0
   \   00000024   F5D1               BNE.N    ??gen_numname_1
    779          	}
    780          
    781          	/* itoa */
    782          	i = 7;
   \                     ??gen_numname_0:
   \   00000026   0721               MOVS     R1,#+7
   \   00000028   0A22               MOVS     R2,#+10
   \   0000002A   00AB               ADD      R3,SP,#+0
   \                     ??gen_numname_2:
   \   0000002C   A4B2               UXTH     R4,R4
   \   0000002E   94FBF2F0           SDIV     R0,R4,R2
   \   00000032   00FB1244           MLS      R4,R0,R2,R4
   \   00000036   3034               ADDS     R4,R4,#+48
   \   00000038   CC54               STRB     R4,[R1, R3]
   \   0000003A   491E               SUBS     R1,R1,#+1
    783          	do {
    784          		ns[i--] = (num % 10) + '0';
    785          		num /= 10;
    786          	} while (num);
   \   0000003C   84B2               UXTH     R4,R0
   \   0000003E   002C               CMP      R4,#+0
   \   00000040   F4D1               BNE.N    ??gen_numname_2
    787          	ns[i] = '~';
   \   00000042   7E20               MOVS     R0,#+126
   \   00000044   C854               STRB     R0,[R1, R3]
    788          
    789          	/* Append the number */
    790          	for (j = 0; j < i && dst[j] != ' '; j++) {
   \   00000046   0020               MOVS     R0,#+0
   \   00000048   00E0               B.N      ??gen_numname_3
   \                     ??gen_numname_4:
   \   0000004A   401C               ADDS     R0,R0,#+1
   \                     ??gen_numname_3:
   \   0000004C   8842               CMP      R0,R1
   \   0000004E   02DA               BGE.N    ??gen_numname_5
   \   00000050   425D               LDRB     R2,[R0, R5]
   \   00000052   202A               CMP      R2,#+32
   \   00000054   F9D1               BNE.N    ??gen_numname_4
    791          		if (IsDBCS1(dst[j])) {
    792          			if (j == i - 1) break;
    793          			j++;
    794          		}
    795          	}
    796          	do {
    797          		dst[j++] = (i < 8) ? ns[i++] : ' ';
   \                     ??gen_numname_5:
   \   00000056   0246               MOV      R2,R0
   \   00000058   501C               ADDS     R0,R2,#+1
   \   0000005A   0829               CMP      R1,#+8
   \   0000005C   BABF               ITTE     LT 
   \   0000005E   CC5C               LDRBLT   R4,[R1, R3]
   \   00000060   491C               ADDLT    R1,R1,#+1
   \   00000062   2024               MOVGE    R4,#+32
   \   00000064   5455               STRB     R4,[R2, R5]
    798          	} while (j < 8);
   \   00000066   0828               CMP      R0,#+8
   \   00000068   F5DB               BLT.N    ??gen_numname_5
    799          }
   \   0000006A   73BD               POP      {R0,R1,R4-R6,PC}  ;; return
    800          #endif
    801          
    802          
    803          
    804          
    805          /*-----------------------------------------------------------------------*/
    806          /* Calculate sum of an SFN                                               */
    807          /*-----------------------------------------------------------------------*/
    808          #if _USE_LFN

   \                                 In section .text, align 2, keep-with-next
    809          static
    810          BYTE sum_sfn (
    811          	const BYTE *dir		/* Ptr to directory entry */
    812          )
    813          {
   \                     sum_sfn:
   \   00000000   0146               MOV      R1,R0
    814          	BYTE sum = 0;
   \   00000002   0020               MOVS     R0,#+0
    815          	int n = 11;
   \   00000004   0B22               MOVS     R2,#+11
    816          
    817          	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
   \                     ??sum_sfn_0:
   \   00000006   0346               MOV      R3,R0
   \   00000008   C001               LSLS     R0,R0,#+7
   \   0000000A   00EB5300           ADD      R0,R0,R3, LSR #+1
   \   0000000E   11F8013B           LDRB     R3,[R1], #+1
   \   00000012   1818               ADDS     R0,R3,R0
   \   00000014   C0B2               UXTB     R0,R0
   \   00000016   521E               SUBS     R2,R2,#+1
   \   00000018   F5D1               BNE.N    ??sum_sfn_0
    818          	return sum;
   \   0000001A   7047               BX       LR               ;; return
    819          }
    820          #endif
    821          
    822          
    823          
    824          
    825          /*-----------------------------------------------------------------------*/
    826          /* Directory handling - Find an object in the directory                  */
    827          /*-----------------------------------------------------------------------*/
    828          

   \                                 In section .text, align 2, keep-with-next
    829          static
    830          FRESULT dir_find (
    831          	DIR *dj			/* Pointer to the directory object linked to the file name */
    832          )
    833          {
   \                     dir_find:
   \   00000000   2DE9F84F           PUSH     {R3-R11,LR}
   \   00000004   0446               MOV      R4,R0
    834          	FRESULT res;
    835          	BYTE c, *dir;
    836          #if _USE_LFN
    837          	BYTE a, ord, sum;
    838          #endif
    839          
    840          	res = dir_seek(dj, 0);			/* Rewind directory object */
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   ........           BL       dir_seek
   \   0000000C   5FEA0009           MOVS     R9,R0
    841          	if (res != FR_OK) return res;
   \   00000010   02D0               BEQ.N    ??dir_find_0
   \                     ??dir_find_1:
   \   00000012   4846               MOV      R0,R9
   \   00000014   BDE8F28F           POP      {R1,R4-R11,PC}   ;; return
   \                     ??dir_find_0:
   \   00000018   4FF0FF0B           MOV      R11,#+255
   \   0000001C   FF25               MOVS     R5,#+255
   \   0000001E   21E0               B.N      ??dir_find_2
    842          
    843          #if _USE_LFN
    844          	ord = sum = 0xFF;
    845          #endif
    846          	do {
    847          		res = move_window(dj->fs, dj->sect);
    848          		if (res != FR_OK) break;
    849          		dir = dj->dir;					/* Ptr to the directory entry of current index */
    850          		c = dir[DIR_Name];
    851          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    852          #if _USE_LFN	/* LFN configuration */
    853          		a = dir[DIR_Attr] & AM_MASK;
    854          		if (c == 0xE5 || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
    855          			ord = 0xFF;
    856          		} else {
    857          			if (a == AM_LFN) {			/* An LFN entry is found */
    858          				if (dj->lfn) {
    859          					if (c & 0x40) {		/* Is it start of LFN sequence? */
    860          						sum = dir[LDIR_Chksum];
    861          						c &= 0xBF; ord = c;	/* LFN start order */
    862          						dj->lfn_idx = dj->index;
    863          					}
    864          					/* Check validity of the LFN entry and compare it with given name */
    865          					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
    866          				}
    867          			} else {					/* An SFN entry is found */
    868          				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
   \                     ??dir_find_3:
   \   00000020   EDB2               UXTB     R5,R5
   \   00000022   25B9               CBNZ     R5,??dir_find_4
   \   00000024   3046               MOV      R0,R6
   \   00000026   ........           BL       sum_sfn
   \   0000002A   8345               CMP      R11,R0
   \   0000002C   F1D0               BEQ.N    ??dir_find_1
    869          				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   \                     ??dir_find_4:
   \   0000002E   FF25               MOVS     R5,#+255
   \   00000030   4FF6FF70           MOVW     R0,#+65535
   \   00000034   2084               STRH     R0,[R4, #+32]
    870          				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
   \   00000036   A069               LDR      R0,[R4, #+24]
   \   00000038   C17A               LDRB     R1,[R0, #+11]
   \   0000003A   11F0010F           TST      R1,#0x1
   \   0000003E   0CD1               BNE.N    ??dir_find_5
   \   00000040   0B21               MOVS     R1,#+11
   \   00000042   0022               MOVS     R2,#+0
   \                     ??dir_find_6:
   \   00000044   0B46               MOV      R3,R1
   \   00000046   591E               SUBS     R1,R3,#+1
   \   00000048   2BB1               CBZ      R3,??dir_find_7
   \   0000004A   16F8012B           LDRB     R2,[R6], #+1
   \   0000004E   10F8013B           LDRB     R3,[R0], #+1
   \   00000052   D21A               SUBS     R2,R2,R3
   \   00000054   F6D0               BEQ.N    ??dir_find_6
    871          			}
   \                     ??dir_find_7:
   \   00000056   002A               CMP      R2,#+0
   \   00000058   DBD0               BEQ.N    ??dir_find_1
    872          		}
    873          #else		/* Non LFN configuration */
    874          		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    875          			break;
    876          #endif
    877          		res = dir_next(dj, False);		/* Next entry */
   \                     ??dir_find_5:
   \   0000005A   ........           BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_4:
   \   0000005E   5FEA0009           MOVS     R9,R0
    878          	} while (res == FR_OK);
   \   00000062   D6D1               BNE.N    ??dir_find_1
   \                     ??dir_find_2:
   \   00000064   ........           BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_55:
   \   00000068   5FEA0009           MOVS     R9,R0
   \   0000006C   D1D1               BNE.N    ??dir_find_1
   \   0000006E   6669               LDR      R6,[R4, #+20]
   \   00000070   3078               LDRB     R0,[R6, #+0]
   \   00000072   0100               MOVS     R1,R0
   \   00000074   02D1               BNE.N    ??dir_find_8
   \   00000076   4FF00409           MOV      R9,#+4
   \   0000007A   CAE7               B.N      ??dir_find_1
   \                     ??dir_find_8:
   \   0000007C   F17A               LDRB     R1,[R6, #+11]
   \   0000007E   01F03F01           AND      R1,R1,#0x3F
   \   00000082   E528               CMP      R0,#+229
   \   00000084   04D0               BEQ.N    ??dir_find_9
   \   00000086   11F0080F           TST      R1,#0x8
   \   0000008A   03D0               BEQ.N    ??dir_find_10
   \   0000008C   0F29               CMP      R1,#+15
   \   0000008E   03D0               BEQ.N    ??dir_find_11
   \                     ??dir_find_9:
   \   00000090   FF25               MOVS     R5,#+255
   \   00000092   E2E7               B.N      ??dir_find_5
   \                     ??dir_find_10:
   \   00000094   0F29               CMP      R1,#+15
   \   00000096   C3D1               BNE.N    ??dir_find_3
   \                     ??dir_find_11:
   \   00000098   D4F81C90           LDR      R9,[R4, #+28]
   \   0000009C   B9F1000F           CMP      R9,#+0
   \   000000A0   DBD0               BEQ.N    ??dir_find_5
   \   000000A2   10F0400F           TST      R0,#0x40
   \   000000A6   06D0               BEQ.N    ??dir_find_12
   \   000000A8   96F80DB0           LDRB     R11,[R6, #+13]
   \   000000AC   00F0BF00           AND      R0,R0,#0xBF
   \   000000B0   0546               MOV      R5,R0
   \   000000B2   E188               LDRH     R1,[R4, #+6]
   \   000000B4   2184               STRH     R1,[R4, #+32]
   \                     ??dir_find_12:
   \   000000B6   EDB2               UXTB     R5,R5
   \   000000B8   A842               CMP      R0,R5
   \   000000BA   E9D1               BNE.N    ??dir_find_9
   \   000000BC   717B               LDRB     R1,[R6, #+13]
   \   000000BE   8B45               CMP      R11,R1
   \   000000C0   E6D1               BNE.N    ??dir_find_9
   \   000000C2   3078               LDRB     R0,[R6, #+0]
   \   000000C4   00F0BF00           AND      R0,R0,#0xBF
   \   000000C8   401E               SUBS     R0,R0,#+1
   \   000000CA   0D21               MOVS     R1,#+13
   \   000000CC   00FB01F8           MUL      R8,R0,R1
   \   000000D0   0027               MOVS     R7,#+0
   \   000000D2   4FF0010A           MOV      R10,#+1
   \                     ??dir_find_13:
   \   000000D6   ....               LDR.N    R0,??DataTable2  ;; LfnOfs
   \   000000D8   385C               LDRB     R0,[R7, R0]
   \   000000DA   8119               ADDS     R1,R0,R6
   \   000000DC   4978               LDRB     R1,[R1, #+1]
   \   000000DE   805D               LDRB     R0,[R0, R6]
   \   000000E0   40EA0120           ORR      R0,R0,R1, LSL #+8
   \   000000E4   5146               MOV      R1,R10
   \   000000E6   71B1               CBZ      R1,??dir_find_14
   \   000000E8   ........           BL       ff_wtoupper
   \   000000EC   8246               MOV      R10,R0
   \   000000EE   B8F1FF0F           CMP      R8,#+255
   \   000000F2   CDDA               BGE.N    ??dir_find_9
   \   000000F4   39F81800           LDRH     R0,[R9, R8, LSL #+1]
   \   000000F8   ........           BL       ff_wtoupper
   \   000000FC   08F10108           ADD      R8,R8,#+1
   \   00000100   8245               CMP      R10,R0
   \   00000102   04D0               BEQ.N    ??dir_find_15
   \   00000104   C4E7               B.N      ??dir_find_9
   \                     ??dir_find_14:
   \   00000106   4FF6FF71           MOVW     R1,#+65535
   \   0000010A   8842               CMP      R0,R1
   \   0000010C   C0D1               BNE.N    ??dir_find_9
   \                     ??dir_find_15:
   \   0000010E   7F1C               ADDS     R7,R7,#+1
   \   00000110   0D2F               CMP      R7,#+13
   \   00000112   E0DB               BLT.N    ??dir_find_13
   \   00000114   3078               LDRB     R0,[R6, #+0]
   \   00000116   10F0400F           TST      R0,#0x40
   \   0000011A   06D0               BEQ.N    ??dir_find_16
   \   0000011C   BAF1000F           CMP      R10,#+0
   \   00000120   03D0               BEQ.N    ??dir_find_16
   \   00000122   39F81800           LDRH     R0,[R9, R8, LSL #+1]
   \   00000126   0028               CMP      R0,#+0
   \   00000128   B2D1               BNE.N    ??dir_find_9
   \                     ??dir_find_16:
   \   0000012A   6D1E               SUBS     R5,R5,#+1
   \   0000012C   95E7               B.N      ??dir_find_5
    879          
    880          	return res;
    881          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?Subroutine7:
   \   00000000   2169               LDR      R1,[R4, #+16]
   \   00000002   00BF               Nop      
   \   00000004                      REQUIRE ??Subroutine23_0
   \   00000004                      ;; // Fall through to label ??Subroutine23_0

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   2046               MOV      R0,R4
   \   00000004   ....               B.N      dir_next
    882          
    883          
    884          
    885          
    886          /*-----------------------------------------------------------------------*/
    887          /* Read an object from the directory                                     */
    888          /*-----------------------------------------------------------------------*/
    889          #if _FS_MINIMIZE <= 1

   \                                 In section .text, align 2, keep-with-next
    890          static
    891          FRESULT dir_read (
    892          	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
    893          )
    894          {
   \                     dir_read:
   \   00000000   2DE9F846           PUSH     {R3-R7,R9,R10,LR}
   \   00000004   0446               MOV      R4,R0
    895          	FRESULT res;
    896          	BYTE c, *dir;
    897          #if _USE_LFN
    898          	BYTE a, ord = 0xFF, sum = 0xFF;
   \   00000006   FF26               MOVS     R6,#+255
   \   00000008   FF27               MOVS     R7,#+255
    899          #endif
    900          
    901          	res = FR_NO_FILE;
   \   0000000A   0425               MOVS     R5,#+4
   \   0000000C   ........           LDR.W    R10,??DataTable2  ;; LfnOfs
   \   00000010   4FF6FF79           MOVW     R9,#+65535
    902          	while (dj->sect) {
   \                     ??dir_read_0:
   \   00000014   2169               LDR      R1,[R4, #+16]
   \   00000016   D9B1               CBZ      R1,??dir_read_1
    903          		res = move_window(dj->fs, dj->sect);
   \   00000018   ........           BL       ??Subroutine23_0
   \                     ??CrossCallReturnLabel_48:
   \   0000001C   0546               MOV      R5,R0
    904          		if (res != FR_OK) break;
   \   0000001E   B8B9               CBNZ     R0,??dir_read_1
    905          		dir = dj->dir;					/* Ptr to the directory entry of current index */
   \   00000020   6069               LDR      R0,[R4, #+20]
    906          		c = dir[DIR_Name];
   \   00000022   0178               LDRB     R1,[R0, #+0]
    907          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   \   00000024   0A00               MOVS     R2,R1
   \   00000026   01D1               BNE.N    ??dir_read_2
   \   00000028   0425               MOVS     R5,#+4
   \   0000002A   11E0               B.N      ??dir_read_1
    908          #if _USE_LFN	/* LFN configuration */
    909          		a = dir[DIR_Attr] & AM_MASK;
   \                     ??dir_read_2:
   \   0000002C   C27A               LDRB     R2,[R0, #+11]
   \   0000002E   02F03F02           AND      R2,R2,#0x3F
    910          		if (c == 0xE5 || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
   \   00000032   E529               CMP      R1,#+229
   \   00000034   06D0               BEQ.N    ??dir_read_3
   \   00000036   2E29               CMP      R1,#+46
   \   00000038   04D0               BEQ.N    ??dir_read_3
   \   0000003A   12F0080F           TST      R2,#0x8
   \   0000003E   0ED0               BEQ.N    ??dir_read_4
   \   00000040   0F2A               CMP      R2,#+15
   \   00000042   0ED0               BEQ.N    ??dir_read_5
    911          			ord = 0xFF;
   \                     ??dir_read_3:
   \   00000044   FF26               MOVS     R6,#+255
    912          		} else {
    913          			if (a == AM_LFN) {			/* An LFN entry is found */
    914          				if (c & 0x40) {			/* Is it start of LFN sequence? */
    915          					sum = dir[LDIR_Chksum];
    916          					c &= 0xBF; ord = c;
    917          					dj->lfn_idx = dj->index;
    918          				}
    919          				/* Check LFN validity and capture it */
    920          				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
    921          			} else {					/* An SFN entry is found */
    922          				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
    923          					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
    924          				break;
    925          			}
    926          		}
    927          #else		/* Non LFN configuration */
    928          		if (c != 0xE5 && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
    929          			break;
    930          #endif
    931          		res = dir_next(dj, False);				/* Next entry */
   \                     ??dir_read_6:
   \   00000046   ........           BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_3:
   \   0000004A   0546               MOV      R5,R0
    932          		if (res != FR_OK) break;
   \   0000004C   0028               CMP      R0,#+0
   \   0000004E   E1D0               BEQ.N    ??dir_read_0
    933          	}
    934          
    935          	if (res != FR_OK) dj->sect = 0;
   \                     ??dir_read_1:
   \   00000050   002D               CMP      R5,#+0
   \   00000052   01D0               BEQ.N    ??dir_read_7
   \   00000054   0020               MOVS     R0,#+0
   \   00000056   2061               STR      R0,[R4, #+16]
    936          
    937          	return res;
   \                     ??dir_read_7:
   \   00000058   2846               MOV      R0,R5
   \   0000005A   BDE8F286           POP      {R1,R4-R7,R9,R10,PC}  ;; return
   \                     ??dir_read_4:
   \   0000005E   0F2A               CMP      R2,#+15
   \   00000060   3BD1               BNE.N    ??dir_read_8
   \                     ??dir_read_5:
   \   00000062   11F0400F           TST      R1,#0x40
   \   00000066   05D0               BEQ.N    ??dir_read_9
   \   00000068   477B               LDRB     R7,[R0, #+13]
   \   0000006A   01F0BF01           AND      R1,R1,#0xBF
   \   0000006E   0E46               MOV      R6,R1
   \   00000070   E288               LDRH     R2,[R4, #+6]
   \   00000072   2284               STRH     R2,[R4, #+32]
   \                     ??dir_read_9:
   \   00000074   F6B2               UXTB     R6,R6
   \   00000076   B142               CMP      R1,R6
   \   00000078   E4D1               BNE.N    ??dir_read_3
   \   0000007A   427B               LDRB     R2,[R0, #+13]
   \   0000007C   9742               CMP      R7,R2
   \   0000007E   E1D1               BNE.N    ??dir_read_3
   \   00000080   E169               LDR      R1,[R4, #+28]
   \   00000082   0278               LDRB     R2,[R0, #+0]
   \   00000084   02F03F02           AND      R2,R2,#0x3F
   \   00000088   521E               SUBS     R2,R2,#+1
   \   0000008A   0D23               MOVS     R3,#+13
   \   0000008C   5A43               MULS     R2,R2,R3
   \   0000008E   0023               MOVS     R3,#+0
   \   00000090   4FF0010C           MOV      R12,#+1
   \                     ??dir_read_10:
   \   00000094   13F80AE0           LDRB     LR,[R3, R10]
   \   00000098   0EEB0005           ADD      R5,LR,R0
   \   0000009C   6D78               LDRB     R5,[R5, #+1]
   \   0000009E   1EF800E0           LDRB     LR,[LR, R0]
   \   000000A2   4EEA0525           ORR      R5,LR,R5, LSL #+8
   \   000000A6   BCF1000F           CMP      R12,#+0
   \   000000AA   06D0               BEQ.N    ??dir_read_11
   \   000000AC   FF2A               CMP      R2,#+255
   \   000000AE   C9DA               BGE.N    ??dir_read_3
   \   000000B0   AC46               MOV      R12,R5
   \   000000B2   21F812C0           STRH     R12,[R1, R2, LSL #+1]
   \   000000B6   521C               ADDS     R2,R2,#+1
   \   000000B8   01E0               B.N      ??dir_read_12
   \                     ??dir_read_11:
   \   000000BA   4D45               CMP      R5,R9
   \   000000BC   C2D1               BNE.N    ??dir_read_3
   \                     ??dir_read_12:
   \   000000BE   5B1C               ADDS     R3,R3,#+1
   \   000000C0   0D2B               CMP      R3,#+13
   \   000000C2   E7DB               BLT.N    ??dir_read_10
   \   000000C4   0078               LDRB     R0,[R0, #+0]
   \   000000C6   10F0400F           TST      R0,#0x40
   \   000000CA   04D0               BEQ.N    ??dir_read_13
   \   000000CC   FF2A               CMP      R2,#+255
   \   000000CE   B9DA               BGE.N    ??dir_read_3
   \   000000D0   0020               MOVS     R0,#+0
   \   000000D2   21F81200           STRH     R0,[R1, R2, LSL #+1]
   \                     ??dir_read_13:
   \   000000D6   761E               SUBS     R6,R6,#+1
   \   000000D8   B5E7               B.N      ??dir_read_6
   \                     ??dir_read_8:
   \   000000DA   F6B2               UXTB     R6,R6
   \   000000DC   1EB9               CBNZ     R6,??dir_read_14
   \   000000DE   ........           BL       sum_sfn
   \   000000E2   8742               CMP      R7,R0
   \   000000E4   B4D0               BEQ.N    ??dir_read_1
   \                     ??dir_read_14:
   \   000000E6   A4F82090           STRH     R9,[R4, #+32]
   \   000000EA   B1E7               B.N      ??dir_read_1
    938          }
    939          #endif
    940          
    941          
    942          
    943          /*-----------------------------------------------------------------------*/
    944          /* Register an object to the directory                                   */
    945          /*-----------------------------------------------------------------------*/
    946          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    947          static
    948          FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
    949          	DIR *dj				/* Target directory with object name to be created */
    950          )
    951          {
   \                     dir_register:
   \   00000000   2DE9FE4F           PUSH     {R1-R11,LR}
   \   00000004   0446               MOV      R4,R0
    952          	FRESULT res;
    953          	BYTE c, *dir;
    954          #if _USE_LFN	/* LFN configuration */
    955          	WORD n, ne, is;
    956          	BYTE sn[12], *fn, sum;
    957          	WCHAR *lfn;
    958          
    959          
    960          	fn = dj->fn; lfn = dj->lfn;
   \   00000006   A569               LDR      R5,[R4, #+24]
   \   00000008   E669               LDR      R6,[R4, #+28]
    961          	mem_cpy(sn, fn, 12);
   \   0000000A   0C22               MOVS     R2,#+12
   \   0000000C   2946               MOV      R1,R5
   \   0000000E   00A8               ADD      R0,SP,#+0
   \   00000010   ........           BL       mem_cpy
    962          
    963          	if (_FS_RPATH && (sn[NS] & NS_DOT)) return FR_INVALID_NAME;	/* Cannot create dot entry */
    964          
    965          	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
   \   00000014   0DF10009           ADD      R9,SP,#+0
   \   00000018   99F80B00           LDRB     R0,[R9, #+11]
   \   0000001C   10F0010F           TST      R0,#0x1
   \   00000020   21D0               BEQ.N    ??dir_register_0
    966          		fn[NS] = 0; dj->lfn = NULL;			/* Find only SFN */
   \   00000022   0020               MOVS     R0,#+0
   \   00000024   E872               STRB     R0,[R5, #+11]
   \   00000026   E061               STR      R0,[R4, #+28]
    967          		for (n = 1; n < 100; n++) {
   \   00000028   0127               MOVS     R7,#+1
    968          			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
   \                     ??dir_register_1:
   \   0000002A   BBB2               UXTH     R3,R7
   \   0000002C   3246               MOV      R2,R6
   \   0000002E   00A9               ADD      R1,SP,#+0
   \   00000030   2846               MOV      R0,R5
   \   00000032   ........           BL       gen_numname
    969          			res = dir_find(dj);				/* Check if the name collides with existing SFN */
   \   00000036   2046               MOV      R0,R4
   \   00000038   ........           BL       dir_find
   \   0000003C   8046               MOV      R8,R0
    970          			if (res != FR_OK) break;
   \   0000003E   18B9               CBNZ     R0,??dir_register_2
    971          		}
   \   00000040   7F1C               ADDS     R7,R7,#+1
   \   00000042   B8B2               UXTH     R0,R7
   \   00000044   6428               CMP      R0,#+100
   \   00000046   F0D3               BCC.N    ??dir_register_1
    972          		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
   \                     ??dir_register_2:
   \   00000048   BFB2               UXTH     R7,R7
   \   0000004A   642F               CMP      R7,#+100
   \   0000004C   01D1               BNE.N    ??dir_register_3
   \   0000004E   0720               MOVS     R0,#+7
   \   00000050   03E0               B.N      ??dir_register_4
    973          		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
   \                     ??dir_register_3:
   \   00000052   4046               MOV      R0,R8
   \   00000054   0428               CMP      R0,#+4
   \   00000056   02D0               BEQ.N    ??dir_register_5
   \                     ??dir_register_6:
   \   00000058   4046               MOV      R0,R8
   \                     ??dir_register_4:
   \   0000005A   BDE8FE8F           POP      {R1-R11,PC}
    974          		fn[NS] = sn[NS]; dj->lfn = lfn;
   \                     ??dir_register_5:
   \   0000005E   99F80B00           LDRB     R0,[R9, #+11]
   \   00000062   E872               STRB     R0,[R5, #+11]
   \   00000064   E661               STR      R6,[R4, #+28]
    975          	}
    976          
    977          	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve reserve an SFN + LFN entries. */
   \                     ??dir_register_0:
   \   00000066   4FF00D0A           MOV      R10,#+13
   \   0000006A   99F80B00           LDRB     R0,[R9, #+11]
   \   0000006E   10F0020F           TST      R0,#0x2
   \   00000072   0ED0               BEQ.N    ??dir_register_7
    978          		for (ne = 0; lfn[ne]; ne++) ;
   \   00000074   0020               MOVS     R0,#+0
   \   00000076   01E0               B.N      ??dir_register_8
   \                     ??dir_register_9:
   \   00000078   401C               ADDS     R0,R0,#+1
   \   0000007A   80B2               UXTH     R0,R0
   \                     ??dir_register_8:
   \   0000007C   0146               MOV      R1,R0
   \   0000007E   36F81120           LDRH     R2,[R6, R1, LSL #+1]
   \   00000082   002A               CMP      R2,#+0
   \   00000084   F8D1               BNE.N    ??dir_register_9
    979          		ne = (ne + 25) / 13;
   \   00000086   01F11900           ADD      R0,R1,#+25
   \   0000008A   90FBFAF5           SDIV     R5,R0,R10
   \   0000008E   ADB2               UXTH     R5,R5
   \   00000090   00E0               B.N      ??dir_register_10
    980          	} else {						/* Otherwise reserve only an SFN entry. */
    981          		ne = 1;
   \                     ??dir_register_7:
   \   00000092   0125               MOVS     R5,#+1
    982          	}
    983          
    984          	/* Reserve contiguous entries */
    985          	res = dir_seek(dj, 0);
   \                     ??dir_register_10:
   \   00000094   ........           BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_12:
   \   00000098   8046               MOV      R8,R0
    986          	if (res != FR_OK) return res;
   \   0000009A   0028               CMP      R0,#+0
   \   0000009C   DCD1               BNE.N    ??dir_register_6
    987          	n = is = 0;
   \   0000009E   0026               MOVS     R6,#+0
   \   000000A0   0027               MOVS     R7,#+0
    988          	do {
    989          		res = move_window(dj->fs, dj->sect);
   \                     ??dir_register_11:
   \   000000A2   ........           BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_54:
   \   000000A6   8046               MOV      R8,R0
    990          		if (res != FR_OK) break;
   \   000000A8   A0B9               CBNZ     R0,??dir_register_12
    991          		c = *dj->dir;				/* Check the entry status */
   \   000000AA   6069               LDR      R0,[R4, #+20]
   \   000000AC   0078               LDRB     R0,[R0, #+0]
    992          		if (c == 0xE5 || c == 0) {	/* Is it a blank entry? */
   \   000000AE   E528               CMP      R0,#+229
   \   000000B0   00D0               BEQ.N    ??dir_register_13
   \   000000B2   38B9               CBNZ     R0,??dir_register_14
    993          			if (n == 0) is = dj->index;	/* First index of the contigulus entry */
   \                     ??dir_register_13:
   \   000000B4   3800               MOVS     R0,R7
   \   000000B6   00D1               BNE.N    ??dir_register_15
   \   000000B8   E688               LDRH     R6,[R4, #+6]
    994          			if (++n == ne) break;	/* A contiguous entry that requiered count is found */
   \                     ??dir_register_15:
   \   000000BA   7F1C               ADDS     R7,R7,#+1
   \   000000BC   BFB2               UXTH     R7,R7
   \   000000BE   AF42               CMP      R7,R5
   \   000000C0   01D1               BNE.N    ??dir_register_16
   \   000000C2   07E0               B.N      ??dir_register_12
    995          		} else {
    996          			n = 0;					/* Not a blank entry. Restart to search */
   \                     ??dir_register_14:
   \   000000C4   0027               MOVS     R7,#+0
    997          		}
    998          		res = dir_next(dj, True);	/* Next entry with table streach */
   \                     ??dir_register_16:
   \   000000C6   0121               MOVS     R1,#+1
   \   000000C8   2046               MOV      R0,R4
   \   000000CA   ........           BL       dir_next
   \   000000CE   8046               MOV      R8,R0
    999          	} while (res == FR_OK);
   \   000000D0   0028               CMP      R0,#+0
   \   000000D2   E6D0               BEQ.N    ??dir_register_11
   1000          
   1001          	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
   \                     ??dir_register_12:
   \   000000D4   4046               MOV      R0,R8
   \   000000D6   0028               CMP      R0,#+0
   \   000000D8   51D1               BNE.N    ??dir_register_17
   \   000000DA   022D               CMP      R5,#+2
   \   000000DC   4FD3               BCC.N    ??dir_register_17
   1002          		res = dir_seek(dj, is);
   \   000000DE   3146               MOV      R1,R6
   \   000000E0   2046               MOV      R0,R4
   \   000000E2   ........           BL       dir_seek
   \   000000E6   8046               MOV      R8,R0
   1003          		if (res == FR_OK) {
   \   000000E8   0028               CMP      R0,#+0
   \   000000EA   48D1               BNE.N    ??dir_register_17
   1004          			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
   \   000000EC   A069               LDR      R0,[R4, #+24]
   \   000000EE   ........           BL       sum_sfn
   \   000000F2   0646               MOV      R6,R0
   1005          			ne--;
   \   000000F4   4FF6FF77           MOVW     R7,#+65535
   \   000000F8   7D19               ADDS     R5,R7,R5
   \   000000FA   ADB2               UXTH     R5,R5
   \   000000FC   ........           LDR.W    R9,??DataTable2  ;; LfnOfs
   1006          			do {					/* Store LFN entries in bottom first */
   1007          				res = move_window(dj->fs, dj->sect);
   \                     ??dir_register_18:
   \   00000100   ........           BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_53:
   \   00000104   8046               MOV      R8,R0
   1008          				if (res != FR_OK) break;
   \   00000106   0028               CMP      R0,#+0
   \   00000108   39D1               BNE.N    ??dir_register_17
   1009          				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
   \   0000010A   6169               LDR      R1,[R4, #+20]
   \   0000010C   E269               LDR      R2,[R4, #+28]
   \   0000010E   4E73               STRB     R6,[R1, #+13]
   \   00000110   0F23               MOVS     R3,#+15
   \   00000112   CB72               STRB     R3,[R1, #+11]
   \   00000114   0023               MOVS     R3,#+0
   \   00000116   0B73               STRB     R3,[R1, #+12]
   \   00000118   8B76               STRB     R3,[R1, #+26]
   \   0000011A   CB76               STRB     R3,[R1, #+27]
   \   0000011C   E8B2               UXTB     R0,R5
   \   0000011E   431E               SUBS     R3,R0,#+1
   \   00000120   03FB0AF3           MUL      R3,R3,R10
   \   00000124   4FF0000C           MOV      R12,#+0
   \   00000128   01E0               B.N      ??dir_register_19
   \                     ??dir_register_20:
   \   0000012A   BE45               CMP      LR,R7
   \   0000012C   02D0               BEQ.N    ??dir_register_21
   \                     ??dir_register_19:
   \   0000012E   32F813E0           LDRH     LR,[R2, R3, LSL #+1]
   \   00000132   5B1C               ADDS     R3,R3,#+1
   \                     ??dir_register_21:
   \   00000134   1CF80980           LDRB     R8,[R12, R9]
   \   00000138   08F801E0           STRB     LR,[R8, R1]
   \   0000013C   8844               ADD      R8,R8,R1
   \   0000013E   4FEA1E2B           LSR      R11,LR,#+8
   \   00000142   88F801B0           STRB     R11,[R8, #+1]
   \   00000146   BEF1000F           CMP      LR,#+0
   \   0000014A   00D1               BNE.N    ??dir_register_22
   \   0000014C   BE46               MOV      LR,R7
   \                     ??dir_register_22:
   \   0000014E   0CF1010C           ADD      R12,R12,#+1
   \   00000152   BCF10D0F           CMP      R12,#+13
   \   00000156   E8DB               BLT.N    ??dir_register_20
   \   00000158   BE45               CMP      LR,R7
   \   0000015A   02D0               BEQ.N    ??dir_register_23
   \   0000015C   32F81320           LDRH     R2,[R2, R3, LSL #+1]
   \   00000160   0AB9               CBNZ     R2,??dir_register_24
   \                     ??dir_register_23:
   \   00000162   40F04000           ORR      R0,R0,#0x40
   \                     ??dir_register_24:
   \   00000166   0870               STRB     R0,[R1, #+0]
   1010          				dj->fs->wflag = 1;
   \   00000168   2068               LDR      R0,[R4, #+0]
   \   0000016A   0121               MOVS     R1,#+1
   \   0000016C   0171               STRB     R1,[R0, #+4]
   1011          				res = dir_next(dj, False);	/* Next entry */
   \   0000016E   ........           BL       ?Subroutine0
   1012          			} while (res == FR_OK && --ne);
   \                     ??CrossCallReturnLabel_2:
   \   00000172   8046               MOV      R8,R0
   \   00000174   18B9               CBNZ     R0,??dir_register_17
   \   00000176   7D19               ADDS     R5,R7,R5
   \   00000178   ADB2               UXTH     R5,R5
   \   0000017A   2800               MOVS     R0,R5
   \   0000017C   C0D1               BNE.N    ??dir_register_18
   1013          		}
   1014          	}
   1015          
   1016          #else	/* Non LFN configuration */
   1017          	res = dir_seek(dj, 0);
   1018          	if (res == FR_OK) {
   1019          		do {	/* Find a blank entry for the SFN */
   1020          			res = move_window(dj->fs, dj->sect);
   1021          			if (res != FR_OK) break;
   1022          			c = *dj->dir;
   1023          			if (c == 0xE5 || c == 0) break;	/* Is it a blank entry? */
   1024          			res = dir_next(dj, True);		/* Next entry with table streach */
   1025          		} while (res == FR_OK);
   1026          	}
   1027          #endif
   1028          
   1029          	if (res == FR_OK) {		/* Initialize the SFN entry */
   \                     ??dir_register_17:
   \   0000017E   4046               MOV      R0,R8
   \   00000180   0028               CMP      R0,#+0
   \   00000182   15D1               BNE.N    ??dir_register_25
   1030          		res = move_window(dj->fs, dj->sect);
   \   00000184   ........           BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_52:
   \   00000188   8046               MOV      R8,R0
   1031          		if (res == FR_OK) {
   \   0000018A   0028               CMP      R0,#+0
   \   0000018C   10D1               BNE.N    ??dir_register_25
   1032          			dir = dj->dir;
   \   0000018E   6569               LDR      R5,[R4, #+20]
   1033          			mem_set(dir, 0, 32);		/* Clean the entry */
   \   00000190   2022               MOVS     R2,#+32
   \   00000192   ........           BL       ??Subroutine25_0
   1034          			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
   \                     ??CrossCallReturnLabel_60:
   \   00000196   0B22               MOVS     R2,#+11
   \   00000198   A169               LDR      R1,[R4, #+24]
   \   0000019A   2846               MOV      R0,R5
   \   0000019C   ........           BL       mem_cpy
   1035          			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
   \   000001A0   A069               LDR      R0,[R4, #+24]
   \   000001A2   C07A               LDRB     R0,[R0, #+11]
   \   000001A4   00F01800           AND      R0,R0,#0x18
   \   000001A8   2873               STRB     R0,[R5, #+12]
   1036          			dj->fs->wflag = 1;
   \   000001AA   2068               LDR      R0,[R4, #+0]
   \   000001AC   0121               MOVS     R1,#+1
   \   000001AE   0171               STRB     R1,[R0, #+4]
   \                     ??dir_register_25:
   \   000001B0   52E7               B.N      ??dir_register_6
   1037          		}
   1038          	}
   1039          
   1040          	return res;
   1041          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   2046               MOV      R0,R4
   \   00000004   ........           B.W      dir_seek

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine25_0:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   2846               MOV      R0,R5
   \   00000004   ........           B.W      mem_set
   1042          #endif /* !_FS_READONLY */
   1043          
   1044          
   1045          
   1046          
   1047          /*-----------------------------------------------------------------------*/
   1048          /* Remove an object from the directory                                   */
   1049          /*-----------------------------------------------------------------------*/
   1050          #if !_FS_READONLY && !_FS_MINIMIZE

   \                                 In section .text, align 2, keep-with-next
   1051          static
   1052          FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
   1053          	DIR *dj				/* Directory object pointing the entry to be removed */
   1054          )
   1055          {
   \                     dir_remove:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0446               MOV      R4,R0
   1056          	FRESULT res;
   1057          #if _USE_LFN	/* LFN configuration */
   1058          	WORD i;
   1059          
   1060          	i = dj->index;	/* SFN index */
   \   00000004   E588               LDRH     R5,[R4, #+6]
   1061          	res = dir_seek(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
   \   00000006   218C               LDRH     R1,[R4, #+32]
   \   00000008   4FF6FF70           MOVW     R0,#+65535
   \   0000000C   8142               CMP      R1,R0
   \   0000000E   00D1               BNE.N    ??dir_remove_0
   \   00000010   2946               MOV      R1,R5
   \                     ??dir_remove_0:
   \   00000012   2046               MOV      R0,R4
   \   00000014   ........           BL       dir_seek
   1062          	if (res == FR_OK) {
   \   00000018   0100               MOVS     R1,R0
   \   0000001A   13D1               BNE.N    ??dir_remove_1
   1063          		do {
   1064          			res = move_window(dj->fs, dj->sect);
   \                     ??dir_remove_2:
   \   0000001C   ........           BL       ?Subroutine7
   1065          			if (res != FR_OK) break;
   \                     ??CrossCallReturnLabel_51:
   \   00000020   0100               MOVS     R1,R0
   \   00000022   0CD1               BNE.N    ??dir_remove_3
   1066          			*dj->dir = 0xE5;			/* Mark the entry "deleted" */
   \   00000024   6169               LDR      R1,[R4, #+20]
   \   00000026   E522               MOVS     R2,#+229
   \   00000028   0A70               STRB     R2,[R1, #+0]
   1067          			dj->fs->wflag = 1;
   \   0000002A   2168               LDR      R1,[R4, #+0]
   \   0000002C   0122               MOVS     R2,#+1
   \   0000002E   0A71               STRB     R2,[R1, #+4]
   1068          			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
   \   00000030   E188               LDRH     R1,[R4, #+6]
   \   00000032   A942               CMP      R1,R5
   \   00000034   03D2               BCS.N    ??dir_remove_3
   1069          			res = dir_next(dj, False);	/* Next entry */
   \   00000036   ........           BL       ?Subroutine0
   1070          		} while (res == FR_OK);
   \                     ??CrossCallReturnLabel_1:
   \   0000003A   0100               MOVS     R1,R0
   \   0000003C   EED0               BEQ.N    ??dir_remove_2
   1071          		if (res == FR_NO_FILE) res = FR_INT_ERR;
   \                     ??dir_remove_3:
   \   0000003E   0428               CMP      R0,#+4
   \   00000040   00D1               BNE.N    ??dir_remove_1
   \   00000042   0220               MOVS     R0,#+2
   1072          	}
   1073          
   1074          #else			/* Non LFN configuration */
   1075          	res = dir_seek(dj, dj->index);
   1076          	if (res == FR_OK) {
   1077          		res = move_window(dj->fs, dj->sect);
   1078          		if (res == FR_OK) {
   1079          			*dj->dir = 0xE5;			/* Mark the entry "deleted" */
   1080          			dj->fs->wflag = 1;
   1081          		}
   1082          	}
   1083          #endif
   1084          
   1085          	return res;
   \                     ??dir_remove_1:
   \   00000044   32BD               POP      {R1,R4,R5,PC}    ;; return
   1086          }
   1087          #endif /* !_FS_READONLY */
   1088          
   1089          
   1090          
   1091          
   1092          /*-----------------------------------------------------------------------*/
   1093          /* Pick a segment and create the object name in directory form           */
   1094          /*-----------------------------------------------------------------------*/
   1095          

   \                                 In section .text, align 4, keep-with-next
   1096          static
   1097          FRESULT create_name (
   1098          	DIR *dj,			/* Pointer to the directory object */
   1099          	const XCHAR **path	/* Pointer to pointer to the segment in the path string */
   1100          )
   1101          {
   \                     create_name:
   \   00000000   2DE9F14F           PUSH     {R0,R4-R11,LR}
   \   00000004   0D46               MOV      R5,R1
   1102          #ifdef _EXCVT
   1103          	static const BYTE cvt[] = _EXCVT;
   1104          #endif
   1105          
   1106          #if _USE_LFN	/* LFN configuration */
   1107          	BYTE b, cf;
   1108          	WCHAR w, *lfn;
   1109          	int i, ni, si, di;
   1110          	const XCHAR *p;
   1111          
   1112          	/* Create LFN in Unicode */
   1113          	si = di = 0;
   \   00000006   0024               MOVS     R4,#+0
   \   00000008   0026               MOVS     R6,#+0
   1114          	p = *path;
   \   0000000A   2F68               LDR      R7,[R5, #+0]
   1115          	lfn = dj->lfn;
   \   0000000C   D0F81CB0           LDR      R11,[R0, #+28]
   \   00000010   10E0               B.N      ??create_name_0
   1116          	for (;;) {
   1117          		w = p[si++];					/* Get a character */
   1118          		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
   1119          		if (di >= _MAX_LFN)				/* Reject too long name */
   1120          			return FR_INVALID_NAME;
   1121          #if !_LFN_UNICODE
   1122          		w &= 0xFF;
   1123          		if (IsDBCS1(w)) {				/* If it is a DBC 1st byte */
   1124          			b = p[si++];				/* Get 2nd byte */
   1125          			if (!IsDBCS2(b))			/* Reject invalid code for DBC */
   1126          				return FR_INVALID_NAME;
   1127          			w = (w << 8) + b;
                 			^
Warning[Pe111]: statement is unreachable
   1128          		}
   1129          		w = ff_convert(w, 1);			/* Convert OEM to Unicode */
   \                     ??create_name_1:
   \   00000012   0121               MOVS     R1,#+1
   \   00000014   ........           BL       ff_convert
   \   00000018   8146               MOV      R9,R0
   1130          		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
   \   0000001A   0028               CMP      R0,#+0
   \   0000001C   1BD0               BEQ.N    ??create_name_2
   1131          #endif
   1132          		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
   \   0000001E   8028               CMP      R0,#+128
   \   00000020   05D2               BCS.N    ??create_name_3
   \   00000022   4946               MOV      R1,R9
   \   00000024   6848               LDR.N    R0,??create_name_4  ;; ??cvt + 128
   \   00000026   ........           BL       chk_chr
   \   0000002A   0028               CMP      R0,#+0
   \   0000002C   13D1               BNE.N    ??create_name_2
   1133          			return FR_INVALID_NAME;
   1134          		lfn[di++] = w;					/* Store the Unicode char */
   \                     ??create_name_3:
   \   0000002E   2BF81490           STRH     R9,[R11, R4, LSL #+1]
   \   00000032   641C               ADDS     R4,R4,#+1
   \                     ??create_name_0:
   \   00000034   F15D               LDRB     R1,[R6, R7]
   \   00000036   761C               ADDS     R6,R6,#+1
   \   00000038   0846               MOV      R0,R1
   \   0000003A   2028               CMP      R0,#+32
   \   0000003C   03D3               BCC.N    ??create_name_5
   \   0000003E   2F28               CMP      R0,#+47
   \   00000040   01D0               BEQ.N    ??create_name_5
   \   00000042   5C28               CMP      R0,#+92
   \   00000044   05D1               BNE.N    ??create_name_6
   1135          	}
   1136          	*path = &p[si];						/* Rerurn pointer to the next segment */
   \                     ??create_name_5:
   \   00000046   F019               ADDS     R0,R6,R7
   \   00000048   2860               STR      R0,[R5, #+0]
   1137          	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   \   0000004A   2029               CMP      R1,#+32
   \   0000004C   05D2               BCS.N    ??create_name_7
   \   0000004E   0425               MOVS     R5,#+4
   \   00000050   06E0               B.N      ??create_name_8
   \                     ??create_name_6:
   \   00000052   FF2C               CMP      R4,#+255
   \   00000054   DDDB               BLT.N    ??create_name_1
   \                     ??create_name_2:
   \   00000056   0620               MOVS     R0,#+6
   \   00000058   74E0               B.N      ??create_name_9
   \                     ??create_name_7:
   \   0000005A   0025               MOVS     R5,#+0
   \   0000005C   00E0               B.N      ??create_name_8
   1138          #if _FS_RPATH
   1139          	if ((di == 1 && lfn[di - 1] == '.') || /* Is this a dot entry? */
   1140          		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {
   1141          		lfn[di] = 0;
   1142          		for (i = 0; i < 11; i++)
   1143          			dj->fn[i] = (i < di) ? '.' : ' ';
   1144          		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
   1145          		return FR_OK;
   1146          	}
   1147          #endif
   1148          	while (di) {						/* Strip trailing spaces and dots */
   1149          		w = lfn[di - 1];
   1150          		if (w != ' ' && w != '.') break;
   1151          		di--;
   \                     ??create_name_10:
   \   0000005E   641E               SUBS     R4,R4,#+1
   \                     ??create_name_8:
   \   00000060   002C               CMP      R4,#+0
   \   00000062   F8D0               BEQ.N    ??create_name_2
   \   00000064   0BEB4400           ADD      R0,R11,R4, LSL #+1
   \   00000068   30F8021C           LDRH     R1,[R0, #-2]
   \   0000006C   2029               CMP      R1,#+32
   \   0000006E   F6D0               BEQ.N    ??create_name_10
   \   00000070   2E29               CMP      R1,#+46
   \   00000072   F4D0               BEQ.N    ??create_name_10
   1152          	}
   1153          	if (!di) return FR_INVALID_NAME;	/* Reject null string */
   1154          
   1155          	lfn[di] = 0;						/* LFN is created */
   \   00000074   0020               MOVS     R0,#+0
   \   00000076   2BF81400           STRH     R0,[R11, R4, LSL #+1]
   1156          
   1157          	/* Create SFN in directory form */
   1158          	mem_set(dj->fn, ' ', 11);
   \   0000007A   0B22               MOVS     R2,#+11
   \   0000007C   2021               MOVS     R1,#+32
   \   0000007E   0098               LDR      R0,[SP, #+0]
   \   00000080   8069               LDR      R0,[R0, #+24]
   \   00000082   ........           BL       mem_set
   1159          	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
   \   00000086   0026               MOVS     R6,#+0
   \   00000088   00E0               B.N      ??create_name_11
   \                     ??create_name_12:
   \   0000008A   761C               ADDS     R6,R6,#+1
   \                     ??create_name_11:
   \   0000008C   3BF81600           LDRH     R0,[R11, R6, LSL #+1]
   \   00000090   2028               CMP      R0,#+32
   \   00000092   FAD0               BEQ.N    ??create_name_12
   \   00000094   2E28               CMP      R0,#+46
   \   00000096   F8D0               BEQ.N    ??create_name_12
   1160          	if (si) cf |= NS_LOSS | NS_LFN;
   \   00000098   0EB1               CBZ      R6,??create_name_13
   \   0000009A   45F00305           ORR      R5,R5,#0x3
   \                     ??create_name_13:
   \   0000009E   0BEB4400           ADD      R0,R11,R4, LSL #+1
   \   000000A2   30F8020C           LDRH     R0,[R0, #-2]
   \   000000A6   2E28               CMP      R0,#+46
   \   000000A8   01D0               BEQ.N    ??create_name_14
   1161          	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
   \   000000AA   641E               SUBS     R4,R4,#+1
   \   000000AC   F7D1               BNE.N    ??create_name_13
   1162          
   1163          	b = i = 0; ni = 8;
   \                     ??create_name_14:
   \   000000AE   0027               MOVS     R7,#+0
   \   000000B0   B846               MOV      R8,R7
   \   000000B2   4FF0080A           MOV      R10,#+8
   \   000000B6   00E0               B.N      ??create_name_15
   1164          	for (;;) {
   1165          		w = lfn[si++];					/* Get an LFN char */
   1166          		if (!w) break;					/* Break on enf of the LFN */
   1167          		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
   1168          			cf |= NS_LOSS | NS_LFN; continue;
   \                     ??create_name_16:
   \   000000B8   0D46               MOV      R5,R1
   1169          		}
   \                     ??create_name_15:
   \   000000BA   3BF81690           LDRH     R9,[R11, R6, LSL #+1]
   \   000000BE   761C               ADDS     R6,R6,#+1
   \   000000C0   4FEA8800           LSL      R0,R8,#+2
   \   000000C4   C0B2               UXTB     R0,R0
   \   000000C6   4946               MOV      R1,R9
   \   000000C8   89B1               CBZ      R1,??create_name_17
   \   000000CA   45F00301           ORR      R1,R5,#0x3
   \   000000CE   C9B2               UXTB     R1,R1
   \   000000D0   4A46               MOV      R2,R9
   \   000000D2   202A               CMP      R2,#+32
   \   000000D4   F0D0               BEQ.N    ??create_name_16
   \   000000D6   2E2A               CMP      R2,#+46
   \   000000D8   01D1               BNE.N    ??create_name_18
   \   000000DA   A642               CMP      R6,R4
   \   000000DC   ECD1               BNE.N    ??create_name_16
   1170          
   1171          		if (i >= ni || si == di) {		/* Extension or end of SFN */
   \                     ??create_name_18:
   \   000000DE   5745               CMP      R7,R10
   \   000000E0   01DA               BGE.N    ??create_name_19
   \   000000E2   A642               CMP      R6,R4
   \   000000E4   3BD1               BNE.N    ??create_name_20
   1172          			if (ni == 11) {				/* Long extension */
   \                     ??create_name_19:
   \   000000E6   BAF10B0F           CMP      R10,#+11
   \   000000EA   2DD1               BNE.N    ??create_name_21
   1173          				cf |= NS_LOSS | NS_LFN; break;
   \   000000EC   0D46               MOV      R5,R1
   1174          			}
   1175          			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
   1176          			if (si > di) break;			/* No extension */
   1177          			si = di; i = 8; ni = 11;	/* Enter extension section */
   1178          			b <<= 2; continue;
   1179          		}
   1180          
   1181          		if (w >= 0x80) {				/* Non ASCII char */
   1182          #ifdef _EXCVT
   1183          			w = ff_convert(w, 0);		/* Unicode -> OEM code */
   1184          			if (w) w = cvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
   1185          #else
   1186          			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
   1187          #endif
   1188          			cf |= NS_LFN;				/* Force create LFN entry */
   1189          		}
   1190          
   1191          		if (_DF1S && w >= 0x100) {		/* Double byte char */
   1192          			if (i >= ni - 1) {
   1193          				cf |= NS_LOSS | NS_LFN; i = ni; continue;
   1194          			}
   1195          			dj->fn[i++] = (BYTE)(w >> 8);
   1196          		} else {						/* Single byte char */
   1197          			if (!w || chk_chr("+,;[=]", w)) {		/* Replace illegal chars for SFN */
   1198          				w = '_'; cf |= NS_LOSS | NS_LFN;	/* Lossy conversion */
   1199          			} else {
   1200          				if (IsUpper(w)) {		/* ASCII large capital */
   1201          					b |= 2;
   1202          				} else {
   1203          					if (IsLower(w)) {	/* ASCII small capital */
   1204          						b |= 1; w -= 0x20;
   1205          					}
   1206          				}
   1207          			}
   1208          		}
   1209          		dj->fn[i++] = (BYTE)w;
   1210          	}
   1211          
   1212          	if (dj->fn[0] == 0xE5) dj->fn[0] = 0x05;	/* If the first char collides with deleted mark, replace it with 0x05 */
   \                     ??create_name_17:
   \   000000EE   0099               LDR      R1,[SP, #+0]
   \   000000F0   8969               LDR      R1,[R1, #+24]
   \   000000F2   0A78               LDRB     R2,[R1, #+0]
   \   000000F4   E52A               CMP      R2,#+229
   \   000000F6   01D1               BNE.N    ??create_name_22
   \   000000F8   0522               MOVS     R2,#+5
   \   000000FA   0A70               STRB     R2,[R1, #+0]
   1213          
   1214          	if (ni == 8) b <<= 2;
   \                     ??create_name_22:
   \   000000FC   BAF1080F           CMP      R10,#+8
   \   00000100   00D1               BNE.N    ??create_name_23
   \   00000102   8046               MOV      R8,R0
   1215          	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
   \                     ??create_name_23:
   \   00000104   08F00C00           AND      R0,R8,#0xC
   \   00000108   0C28               CMP      R0,#+12
   \   0000010A   03D0               BEQ.N    ??create_name_24
   \   0000010C   08F00300           AND      R0,R8,#0x3
   \   00000110   0328               CMP      R0,#+3
   \   00000112   02D1               BNE.N    ??create_name_25
   1216          		cf |= NS_LFN;
   \                     ??create_name_24:
   \   00000114   45F00205           ORR      R5,R5,#0x2
   \   00000118   EDB2               UXTB     R5,R5
   1217          	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
   \                     ??create_name_25:
   \   0000011A   15F0020F           TST      R5,#0x2
   \   0000011E   0DD1               BNE.N    ??create_name_26
   1218          		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
   \   00000120   08F00300           AND      R0,R8,#0x3
   \   00000124   0128               CMP      R0,#+1
   \   00000126   02D1               BNE.N    ??create_name_27
   \   00000128   45F01005           ORR      R5,R5,#0x10
   \   0000012C   EDB2               UXTB     R5,R5
   1219          		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
   \                     ??create_name_27:
   \   0000012E   08F00C00           AND      R0,R8,#0xC
   \   00000132   0428               CMP      R0,#+4
   \   00000134   02D1               BNE.N    ??create_name_26
   \   00000136   45F00805           ORR      R5,R5,#0x8
   \   0000013A   EDB2               UXTB     R5,R5
   1220          	}
   1221          
   1222          	dj->fn[NS] = cf;	/* SFN is created */
   \                     ??create_name_26:
   \   0000013C   0098               LDR      R0,[SP, #+0]
   \   0000013E   8069               LDR      R0,[R0, #+24]
   \   00000140   C572               STRB     R5,[R0, #+11]
   1223          
   1224          	return FR_OK;
   \   00000142   0020               MOVS     R0,#+0
   \                     ??create_name_9:
   \   00000144   BDE8F28F           POP      {R1,R4-R11,PC}   ;; return
   \                     ??create_name_21:
   \   00000148   A642               CMP      R6,R4
   \   0000014A   00D0               BEQ.N    ??create_name_28
   \   0000014C   0D46               MOV      R5,R1
   \                     ??create_name_28:
   \   0000014E   B442               CMP      R4,R6
   \   00000150   CDDB               BLT.N    ??create_name_17
   \   00000152   2646               MOV      R6,R4
   \   00000154   0827               MOVS     R7,#+8
   \   00000156   4FF00B0A           MOV      R10,#+11
   \   0000015A   8046               MOV      R8,R0
   \   0000015C   ADE7               B.N      ??create_name_15
   \                     ??create_name_20:
   \   0000015E   4846               MOV      R0,R9
   \   00000160   8028               CMP      R0,#+128
   \   00000162   0BD3               BCC.N    ??create_name_29
   \   00000164   0021               MOVS     R1,#+0
   \   00000166   ........           BL       ff_convert
   \   0000016A   8146               MOV      R9,R0
   \   0000016C   18B1               CBZ      R0,??create_name_30
   \   0000016E   1748               LDR.N    R0,??create_name_4+0x4  ;; ??cvt
   \   00000170   4844               ADD      R0,R9,R0
   \   00000172   10F8809C           LDRB     R9,[R0, #-128]
   \                     ??create_name_30:
   \   00000176   45F00205           ORR      R5,R5,#0x2
   \   0000017A   EDB2               UXTB     R5,R5
   \                     ??create_name_29:
   \   0000017C   4846               MOV      R0,R9
   \   0000017E   20B1               CBZ      R0,??create_name_31
   \   00000180   4946               MOV      R1,R9
   \   00000182   1348               LDR.N    R0,??create_name_4+0x8  ;; ??cvt + 140
   \   00000184   ........           BL       chk_chr
   \   00000188   28B1               CBZ      R0,??create_name_32
   \                     ??create_name_31:
   \   0000018A   4FF05F09           MOV      R9,#+95
   \   0000018E   45F00305           ORR      R5,R5,#0x3
   \   00000192   EDB2               UXTB     R5,R5
   \   00000194   11E0               B.N      ??create_name_33
   \                     ??create_name_32:
   \   00000196   4846               MOV      R0,R9
   \   00000198   4128               CMP      R0,#+65
   \   0000019A   04D3               BCC.N    ??create_name_34
   \   0000019C   5B28               CMP      R0,#+91
   \   0000019E   02D2               BCS.N    ??create_name_34
   \   000001A0   48F00208           ORR      R8,R8,#0x2
   \   000001A4   09E0               B.N      ??create_name_33
   \                     ??create_name_34:
   \   000001A6   6128               CMP      R0,#+97
   \   000001A8   07D3               BCC.N    ??create_name_33
   \   000001AA   7B28               CMP      R0,#+123
   \   000001AC   05D2               BCS.N    ??create_name_33
   \   000001AE   48F00100           ORR      R0,R8,#0x1
   \   000001B2   5FFA80F8           UXTB     R8,R0
   \   000001B6   A9F12009           SUB      R9,R9,#+32
   \                     ??create_name_33:
   \   000001BA   0098               LDR      R0,[SP, #+0]
   \   000001BC   8069               LDR      R0,[R0, #+24]
   \   000001BE   07F80090           STRB     R9,[R7, R0]
   \   000001C2   7F1C               ADDS     R7,R7,#+1
   \   000001C4   79E7               B.N      ??create_name_15
   \   000001C6   00BF               Nop      
   \                     ??create_name_4:
   \   000001C8   ........           DC32     ??cvt + 128
   \   000001CC   ........           DC32     ??cvt
   \   000001D0   ........           DC32     ??cvt + 140
   1225          
   1226          
   1227          #else	/* Non-LFN configuration */
   1228          	BYTE b, c, d, *sfn;
   1229          	int ni, si, i;
   1230          	const char *p;
   1231          
   1232          	/* Create file name in directory form */
   1233          	sfn = dj->fn;
   1234          	mem_set(sfn, ' ', 11);
   1235          	si = i = b = 0; ni = 8;
   1236          	p = *path;
   1237          #if _FS_RPATH
   1238          	if (p[si] == '.') { /* Is this a dot entry? */
   1239          		for (;;) {
   1240          			c = p[si++];
   1241          			if (c != '.' || si >= 3) break;
   1242          			sfn[i++] = c;
   1243          		}
   1244          		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
   1245          		*path = &p[si];									/* Rerurn pointer to the next segment */
   1246          		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
   1247          		return FR_OK;
   1248          	}
   1249          #endif
   1250          	for (;;) {
   1251          		c = p[si++];
   1252          		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
   1253          		if (c == '.' || i >= ni) {
   1254          			if (ni != 8 || c != '.') return FR_INVALID_NAME;
   1255          			i = 8; ni = 11;
   1256          			b <<= 2; continue;
   1257          		}
   1258          		if (c >= 0x80) {				/* Extended char */
   1259          #ifdef _EXCVT
   1260          			c = cvt[c - 0x80];			/* Convert extend char (SBCS) */
   1261          #else
   1262          			b |= 3;						/* Eliminate NT flag if ext char is exist */
   1263          #if !_DF1S	/* ASCII only cfg */
   1264          			return FR_INVALID_NAME;
   1265          #endif
   1266          #endif
   1267          		}
   1268          		if (IsDBCS1(c)) {				/* DBC 1st byte? */
   1269          			d = p[si++];				/* Get 2nd byte */
   1270          			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
   1271          				return FR_INVALID_NAME;
   1272          			sfn[i++] = c;
   1273          			sfn[i++] = d;
   1274          		} else {						/* Single byte code */
   1275          			if (chk_chr(" \"*+,[=]|\x7F", c))	/* Reject illegal chrs for SFN */
   1276          				return FR_INVALID_NAME;
   1277          			if (IsUpper(c)) {			/* ASCII large capital? */
   1278          				b |= 2;
   1279          			} else {
   1280          				if (IsLower(c)) {		/* ASCII small capital? */
   1281          					b |= 1; c -= 0x20;
   1282          				}
   1283          			}
   1284          			sfn[i++] = c;
   1285          		}
   1286          	}
   1287          	*path = &p[si];						/* Rerurn pointer to the next segment */
   1288          	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   1289          
   1290          	if (!i) return FR_INVALID_NAME;		/* Reject null string */
   1291          	if (sfn[0] == 0xE5) sfn[0] = 0x05;	/* When first char collides with 0xE5, replace it with 0x05 */
   1292          
   1293          	if (ni == 8) b <<= 2;
   1294          	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Extension has only small capital) */
   1295          	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Filename has only small capital) */
   1296          
   1297          	sfn[NS] = c;		/* Store NT flag, File name is created */
   1298          
   1299          	return FR_OK;
   1300          #endif
   1301          }

   \                                 In section .rodata, align 4
   \                     ??cvt:
   \   00000000   809A90418E41       DC8 128, 154, 144, 65, 142, 65, 143, 128, 69, 69, 69, 73, 73, 73, 142
   \              8F8045454549
   \              49498E      
   \   0000000F   8F9092924F99       DC8 143, 144, 146, 146, 79, 153, 79, 85, 85, 89, 153, 154, 155, 156
   \              4F555559999A
   \              9B9C        
   \   0000001D   9D9E9F41494F       DC8 157, 158, 159, 65, 73, 79, 85, 165, 165, 166, 167, 168, 169, 170
   \              55A5A5A6A7A8
   \              A9AA        
   \   0000002B   ABAC21AEAFB0       DC8 171, 172, 33, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184
   \              B1B2B3B4B5B6
   \              B7B8        
   \   00000039   B9BABBBCBDBE       DC8 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197
   \              BFC0C1C2C3C4
   \              C5          
   \   00000046   C6C7C8C9CACB       DC8 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210
   \              CCCDCECFD0D1
   \              D2          
   \   00000053   D3D4D5D6D7D8       DC8 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223
   \              D9DADBDCDDDE
   \              DF          
   \   00000060   E0E1E2E3E4E5       DC8 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236
   \              E6E7E8E9EAEB
   \              EC          
   \   0000006D   EDEEEFF0F1F2       DC8 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249
   \              F3F4F5F6F7F8
   \              F9          
   \   0000007A   FAFBFCFDFEFF       DC8 250, 251, 252, 253, 254, 255
   \   00000080   222A3A3C3E3F       DC8 "\"*:<>?|\177"
   \              7C7F00      
   \   00000089   000000             DC8 0, 0, 0
   \   0000008C   2B2C3B5B3D5D       DC8 "+,;[=]"
   \              00          
   \   00000093   00                 DC8 0
   1302          
   1303          
   1304          
   1305          
   1306          /*-----------------------------------------------------------------------*/
   1307          /* Get file information from directory entry                             */
   1308          /*-----------------------------------------------------------------------*/
   1309          #if _FS_MINIMIZE <= 1

   \                                 In section .text, align 2, keep-with-next
   1310          static
   1311          void get_fileinfo (		/* No return code */
   1312          	DIR *dj,			/* Pointer to the directory object */
   1313          	FILINFO *fno	 	/* Pointer to the file information to be filled */
   1314          )
   1315          {
   \                     get_fileinfo:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0C46               MOV      R4,R1
   1316          	int i;
   1317          	BYTE c, nt, *dir;
   1318          	char *p;
   1319          
   1320          
   1321          	p = fno->fname;
   \   00000004   04F10901           ADD      R1,R4,#+9
   1322          	if (dj->sect) {
   \   00000008   0269               LDR      R2,[R0, #+16]
   \   0000000A   002A               CMP      R2,#+0
   \   0000000C   35D0               BEQ.N    ??get_fileinfo_0
   1323          		dir = dj->dir;
   \   0000000E   4269               LDR      R2,[R0, #+20]
   1324          		nt = dir[DIR_NTres];		/* NT flag */
   \   00000010   137B               LDRB     R3,[R2, #+12]
   1325          		for (i = 0; i < 8; i++) {	/* Copy name body */
   \   00000012   0025               MOVS     R5,#+0
   1326          			c = dir[i];
   \                     ??get_fileinfo_1:
   \   00000014   AE5C               LDRB     R6,[R5, R2]
   1327          			if (c == ' ') break;
   \   00000016   202E               CMP      R6,#+32
   \   00000018   08D0               BEQ.N    ??get_fileinfo_2
   1328          			if (c == 0x05) c = 0xE5;
   \   0000001A   052E               CMP      R6,#+5
   \   0000001C   00D1               BNE.N    ??get_fileinfo_3
   \   0000001E   E526               MOVS     R6,#+229
   1329          			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
   \                     ??get_fileinfo_3:
   \   00000020   13F0080F           TST      R3,#0x8
   \   00000024   ........           BL       ?Subroutine10
   1330          			*p++ = c;
   1331          		}
   \                     ??CrossCallReturnLabel_17:
   \   00000028   082D               CMP      R5,#+8
   \   0000002A   F3DB               BLT.N    ??get_fileinfo_1
   1332          		if (dir[8] != ' ') {		/* Copy name extension */
   \                     ??get_fileinfo_2:
   \   0000002C   157A               LDRB     R5,[R2, #+8]
   \   0000002E   202D               CMP      R5,#+32
   \   00000030   0CD0               BEQ.N    ??get_fileinfo_4
   1333          			*p++ = '.';
   \   00000032   2E25               MOVS     R5,#+46
   \   00000034   01F8015B           STRB     R5,[R1], #+1
   1334          			for (i = 8; i < 11; i++) {
   \   00000038   0825               MOVS     R5,#+8
   1335          				c = dir[i];
   \                     ??get_fileinfo_5:
   \   0000003A   AE5C               LDRB     R6,[R5, R2]
   1336          				if (c == ' ') break;
   \   0000003C   202E               CMP      R6,#+32
   \   0000003E   05D0               BEQ.N    ??get_fileinfo_4
   1337          				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
   \   00000040   13F0100F           TST      R3,#0x10
   \   00000044   ........           BL       ?Subroutine10
   1338          				*p++ = c;
   1339          			}
   \                     ??CrossCallReturnLabel_18:
   \   00000048   0B2D               CMP      R5,#+11
   \   0000004A   F6DB               BLT.N    ??get_fileinfo_5
   1340          		}
   1341          		fno->fattrib = dir[DIR_Attr];				/* Attribute */
   \                     ??get_fileinfo_4:
   \   0000004C   D37A               LDRB     R3,[R2, #+11]
   \   0000004E   2372               STRB     R3,[R4, #+8]
   1342          		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
   \   00000050   D37F               LDRB     R3,[R2, #+31]
   \   00000052   957F               LDRB     R5,[R2, #+30]
   \   00000054   2D04               LSLS     R5,R5,#+16
   \   00000056   45EA0363           ORR      R3,R5,R3, LSL #+24
   \   0000005A   557F               LDRB     R5,[R2, #+29]
   \   0000005C   43EA0523           ORR      R3,R3,R5, LSL #+8
   \   00000060   157F               LDRB     R5,[R2, #+28]
   \   00000062   2B43               ORRS     R3,R5,R3
   \   00000064   2360               STR      R3,[R4, #+0]
   1343          		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
   \   00000066   537E               LDRB     R3,[R2, #+25]
   \   00000068   157E               LDRB     R5,[R2, #+24]
   \   0000006A   45EA0323           ORR      R3,R5,R3, LSL #+8
   \   0000006E   A380               STRH     R3,[R4, #+4]
   1344          		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
   \   00000070   D37D               LDRB     R3,[R2, #+23]
   \   00000072   927D               LDRB     R2,[R2, #+22]
   \   00000074   42EA0322           ORR      R2,R2,R3, LSL #+8
   \   00000078   E280               STRH     R2,[R4, #+6]
   1345          	}
   1346          	*p = 0;
   \                     ??get_fileinfo_0:
   \   0000007A   0022               MOVS     R2,#+0
   \   0000007C   0A70               STRB     R2,[R1, #+0]
   1347          
   1348          #if _USE_LFN
   1349          	if (fno->lfname) {
   \   0000007E   A669               LDR      R6,[R4, #+24]
   \   00000080   DEB1               CBZ      R6,??get_fileinfo_6
   1350          		XCHAR *tp = fno->lfname;
   1351          		WCHAR w, *lfn;
   1352          
   1353          		i = 0;
   \   00000082   0025               MOVS     R5,#+0
   1354          		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
   \   00000084   0169               LDR      R1,[R0, #+16]
   \   00000086   B1B1               CBZ      R1,??get_fileinfo_7
   \   00000088   018C               LDRH     R1,[R0, #+32]
   \   0000008A   4FF6FF72           MOVW     R2,#+65535
   \   0000008E   9142               CMP      R1,R2
   \   00000090   11D0               BEQ.N    ??get_fileinfo_7
   1355          			lfn = dj->lfn;
   \   00000092   C769               LDR      R7,[R0, #+28]
   \   00000094   05E0               B.N      ??get_fileinfo_8
   1356          			while ((w = *lfn++) != 0) {			/* Get an LFN char */
   1357          #if !_LFN_UNICODE
   1358          				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
   1359          				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
   1360          				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC */
   1361          					tp[i++] = (XCHAR)(w >> 8);
   1362          #endif
   1363          				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overrun, no LFN */
   \                     ??get_fileinfo_9:
   \   00000096   E169               LDR      R1,[R4, #+28]
   \   00000098   491E               SUBS     R1,R1,#+1
   \   0000009A   8D42               CMP      R5,R1
   \   0000009C   0ADA               BGE.N    ??get_fileinfo_10
   1364          				tp[i++] = (XCHAR)w;
   \   0000009E   A855               STRB     R0,[R5, R6]
   \   000000A0   6D1C               ADDS     R5,R5,#+1
   \                     ??get_fileinfo_8:
   \   000000A2   37F8020B           LDRH     R0,[R7], #+2
   \   000000A6   0100               MOVS     R1,R0
   \   000000A8   05D0               BEQ.N    ??get_fileinfo_7
   \   000000AA   0021               MOVS     R1,#+0
   \   000000AC   ........           BL       ff_convert
   \   000000B0   0100               MOVS     R1,R0
   \   000000B2   F0D1               BNE.N    ??get_fileinfo_9
   \                     ??get_fileinfo_10:
   \   000000B4   0025               MOVS     R5,#+0
   1365          			}
   1366          		}
   1367          		tp[i] = 0;	/* Terminator */
   \                     ??get_fileinfo_7:
   \   000000B6   0020               MOVS     R0,#+0
   \   000000B8   A855               STRB     R0,[R5, R6]
   1368          	}
   1369          #endif
   1370          }
   \                     ??get_fileinfo_6:
   \   000000BA   F1BD               POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10:
   \   00000000   05D0               BEQ.N    ??Subroutine10_0
   \   00000002   412E               CMP      R6,#+65
   \   00000004   03D3               BCC.N    ??Subroutine10_0
   \   00000006   5B2E               CMP      R6,#+91
   \   00000008   01D2               BCS.N    ??Subroutine10_0
   \   0000000A   2036               ADDS     R6,R6,#+32
   \   0000000C   F6B2               UXTB     R6,R6
   \                     ??Subroutine10_0:
   \   0000000E   01F8016B           STRB     R6,[R1], #+1
   \   00000012   6D1C               ADDS     R5,R5,#+1
   \   00000014   7047               BX       LR
   1371          #endif /* _FS_MINIMIZE <= 1 */
   1372          
   1373          
   1374          
   1375          
   1376          /*-----------------------------------------------------------------------*/
   1377          /* Follow a file path                                                    */
   1378          /*-----------------------------------------------------------------------*/
   1379          

   \                                 In section .text, align 2, keep-with-next
   1380          static
   1381          FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
   1382          	DIR *dj,			/* Directory object to return last directory and found object */
   1383          	const XCHAR *path	/* Full-path string to find a file or directory */
   1384          )
   1385          {
   \                     follow_path:
   \   00000000   13B5               PUSH     {R0,R1,R4,LR}
   \   00000002   0446               MOV      R4,R0
   1386          	FRESULT res;
   1387          	BYTE *dir, last;
   1388          
   1389          
   1390          	while (!_USE_LFN && *path == ' ') path++;	/* Skip leading spaces */
   1391          #if _FS_RPATH
   1392          	if (*path == '/' || *path == '\\') { /* There is a heading separator */
   1393          		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
   1394          	} else {							/* No heading saparator */
   1395          		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
   1396          	}
   1397          #else
   1398          	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
   \   00000004   0878               LDRB     R0,[R1, #+0]
   \   00000006   2F28               CMP      R0,#+47
   \   00000008   01D0               BEQ.N    ??follow_path_0
   \   0000000A   5C28               CMP      R0,#+92
   \   0000000C   01D1               BNE.N    ??follow_path_1
   1399          		path++;
   \                     ??follow_path_0:
   \   0000000E   481C               ADDS     R0,R1,#+1
   \   00000010   0190               STR      R0,[SP, #+4]
   1400          	dj->sclust = 0;						/* Start from the root dir */
   \                     ??follow_path_1:
   \   00000012   0020               MOVS     R0,#+0
   \   00000014   A060               STR      R0,[R4, #+8]
   1401          #endif
   1402          
   1403          	if ((UINT)*path < ' ') {			/* Null path means the start directory itself */
   \   00000016   0198               LDR      R0,[SP, #+4]
   \   00000018   0078               LDRB     R0,[R0, #+0]
   \   0000001A   2028               CMP      R0,#+32
   \   0000001C   0FD2               BCS.N    ??follow_path_2
   1404          		res = dir_seek(dj, 0);
   \   0000001E   ........           BL       ?Subroutine3
   1405          		dj->dir = NULL;
   \                     ??CrossCallReturnLabel_11:
   \   00000022   0021               MOVS     R1,#+0
   \   00000024   6161               STR      R1,[R4, #+20]
   \   00000026   16BD               POP      {R1,R2,R4,PC}
   1406          
   1407          	} else {							/* Follow path */
   1408          		for (;;) {
   1409          			res = create_name(dj, &path);	/* Get a segment */
   1410          			if (res != FR_OK) break;
   1411          			res = dir_find(dj);				/* Find it */
   1412          			last = *(dj->fn+NS) & NS_LAST;
   1413          			if (res != FR_OK) {				/* Could not find the object */
   1414          				if (res == FR_NO_FILE && !last)
   1415          					res = FR_NO_PATH;
   1416          				break;
   1417          			}
   1418          			if (last) break;				/* Last segment match. Function completed. */
   1419          			dir = dj->dir;					/* There is next segment. Follow the sub directory */
   1420          			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
   1421          				res = FR_NO_PATH; break;
   1422          			}
   1423          			dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
   \                     ??follow_path_3:
   \   00000028   417D               LDRB     R1,[R0, #+21]
   \   0000002A   027D               LDRB     R2,[R0, #+20]
   \   0000002C   42EA0121           ORR      R1,R2,R1, LSL #+8
   \   00000030   C27E               LDRB     R2,[R0, #+27]
   \   00000032   807E               LDRB     R0,[R0, #+26]
   \   00000034   40EA0220           ORR      R0,R0,R2, LSL #+8
   \   00000038   40EA0140           ORR      R0,R0,R1, LSL #+16
   \   0000003C   A060               STR      R0,[R4, #+8]
   \                     ??follow_path_2:
   \   0000003E   01A9               ADD      R1,SP,#+4
   \   00000040   2046               MOV      R0,R4
   \   00000042   ........           BL       create_name
   \   00000046   0028               CMP      R0,#+0
   \   00000048   14D1               BNE.N    ??follow_path_4
   \   0000004A   2046               MOV      R0,R4
   \   0000004C   ........           BL       dir_find
   \   00000050   A169               LDR      R1,[R4, #+24]
   \   00000052   C97A               LDRB     R1,[R1, #+11]
   \   00000054   01F00401           AND      R1,R1,#0x4
   \   00000058   20B1               CBZ      R0,??follow_path_5
   \   0000005A   0428               CMP      R0,#+4
   \   0000005C   0AD1               BNE.N    ??follow_path_4
   \   0000005E   0029               CMP      R1,#+0
   \   00000060   08D1               BNE.N    ??follow_path_4
   \   00000062   06E0               B.N      ??follow_path_6
   \                     ??follow_path_5:
   \   00000064   0029               CMP      R1,#+0
   \   00000066   05D1               BNE.N    ??follow_path_4
   \   00000068   6069               LDR      R0,[R4, #+20]
   \   0000006A   C17A               LDRB     R1,[R0, #+11]
   \   0000006C   11F0100F           TST      R1,#0x10
   \   00000070   DAD1               BNE.N    ??follow_path_3
   \                     ??follow_path_6:
   \   00000072   0520               MOVS     R0,#+5
   1424          		}
   1425          	}
   1426          
   1427          	return res;
   \                     ??follow_path_4:
   \   00000074   16BD               POP      {R1,R2,R4,PC}    ;; return
   1428          }
   1429          
   1430          
   1431          
   1432          
   1433          /*-----------------------------------------------------------------------*/
   1434          /* Load boot record and check if it is an FAT boot record                */
   1435          /*-----------------------------------------------------------------------*/
   1436          

   \                                 In section .text, align 4, keep-with-next
   1437          static
   1438          BYTE check_fs (	/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */
   1439          	FATFS *fs,	/* File system object */
   1440          	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
   1441          )
   1442          {
   \                     check_fs:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0446               MOV      R4,R0
   1443          	if (disk_read(fs->drive, fs->win, sect, 1) != RES_OK)	/* Load boot record */
   \   00000004   0123               MOVS     R3,#+1
   \   00000006   0A46               MOV      R2,R1
   \   00000008   04F13001           ADD      R1,R4,#+48
   \   0000000C   6078               LDRB     R0,[R4, #+1]
   \   0000000E   ........           BL       disk_read
   \   00000012   0028               CMP      R0,#+0
   \   00000014   01D0               BEQ.N    ??check_fs_0
   1444          		return 3;
   \   00000016   0320               MOVS     R0,#+3
   \   00000018   10BD               POP      {R4,PC}
   1445          	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
   \                     ??check_fs_0:
   \   0000001A   04F22E20           ADDW     R0,R4,#+558
   \   0000001E   4078               LDRB     R0,[R0, #+1]
   \   00000020   94F82E12           LDRB     R1,[R4, #+558]
   \   00000024   41EA0020           ORR      R0,R1,R0, LSL #+8
   \   00000028   4AF65521           MOVW     R1,#+43605
   \   0000002C   8842               CMP      R0,R1
   \   0000002E   01D0               BEQ.N    ??check_fs_1
   1446          		return 2;
   \   00000030   0220               MOVS     R0,#+2
   \   00000032   10BD               POP      {R4,PC}
   1447          
   1448          	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
   \                     ??check_fs_1:
   \   00000034   04F16601           ADD      R1,R4,#+102
   \   00000038   0B48               LDR.N    R0,??check_fs_2  ;; 0x544146
   \   0000003A   8A78               LDRB     R2,[R1, #+2]
   \   0000003C   4B78               LDRB     R3,[R1, #+1]
   \   0000003E   1B02               LSLS     R3,R3,#+8
   \   00000040   43EA0242           ORR      R2,R3,R2, LSL #+16
   \   00000044   94F86630           LDRB     R3,[R4, #+102]
   \   00000048   1A43               ORRS     R2,R3,R2
   \   0000004A   8242               CMP      R2,R0
   \   0000004C   01D1               BNE.N    ??check_fs_3
   1449          		return 0;
   \                     ??check_fs_4:
   \   0000004E   0020               MOVS     R0,#+0
   \   00000050   10BD               POP      {R4,PC}
   1450          	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
   \                     ??check_fs_3:
   \   00000052   8A7F               LDRB     R2,[R1, #+30]
   \   00000054   4B7F               LDRB     R3,[R1, #+29]
   \   00000056   1B02               LSLS     R3,R3,#+8
   \   00000058   43EA0242           ORR      R2,R3,R2, LSL #+16
   \   0000005C   097F               LDRB     R1,[R1, #+28]
   \   0000005E   1143               ORRS     R1,R1,R2
   \   00000060   8142               CMP      R1,R0
   \   00000062   F4D0               BEQ.N    ??check_fs_4
   1451          		return 0;
   1452          
   1453          	return 1;
   \   00000064   0120               MOVS     R0,#+1
   \   00000066   10BD               POP      {R4,PC}          ;; return
   \                     ??check_fs_2:
   \   00000068   46415400           DC32     0x544146
   1454          }
   1455          
   1456          
   1457          
   1458          
   1459          /*-----------------------------------------------------------------------*/
   1460          /* Make sure that the file system is valid                               */
   1461          /*-----------------------------------------------------------------------*/
   1462          
   1463          

   \                                 In section .text, align 4, keep-with-next
   1464          FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occured */
   1465          	const XCHAR **path,	/* Pointer to pointer to the path name (drive number) */
   1466          	FATFS **rfs,		/* Pointer to pointer to the found file system object */
   1467          	BYTE chk_wp			/* !=0: Check media write protection for write access */
   1468          )
   1469          {
   \                     chk_mounted:
   \   00000000   2DE9F041           PUSH     {R4-R8,LR}
   \   00000004   1446               MOV      R4,R2
   1470          	BYTE fmt, *tbl;
   1471          	UINT vol;
   1472          	DSTATUS stat;
   1473          	DWORD bsect, fsize, tsect, mclst;
   1474          	const XCHAR *p = *path;
   \   00000006   0268               LDR      R2,[R0, #+0]
   1475          	FATFS *fs;
   1476          
   1477          	/* Get logical drive number from the path name */
   1478          	vol = p[0] - '0';				/* Is there a drive number? */
   \   00000008   1378               LDRB     R3,[R2, #+0]
   \   0000000A   303B               SUBS     R3,R3,#+48
   1479          	if (vol <= 9 && p[1] == ':') {	/* Found a drive number, get and strip it */
   \   0000000C   0A2B               CMP      R3,#+10
   \   0000000E   08D2               BCS.N    ??chk_mounted_0
   \   00000010   5578               LDRB     R5,[R2, #+1]
   \   00000012   3A2D               CMP      R5,#+58
   \   00000014   05D1               BNE.N    ??chk_mounted_0
   1480          		p += 2; *path = p;			/* Return pointer to the path name */
   \   00000016   921C               ADDS     R2,R2,#+2
   \   00000018   0260               STR      R2,[R0, #+0]
   1481          	} else {						/* No drive number is given */
   1482          #if _FS_RPATH
   1483          		vol = Drive;				/* Use current drive */
   1484          #else
   1485          		vol = 0;					/* Use drive 0 */
   1486          #endif
   1487          	}
   1488          
   1489          	/* Check if the logical drive is valid or not */
   1490          	if (vol >= _DRIVES) 			/* Is the drive number valid? */
   \   0000001A   002B               CMP      R3,#+0
   \   0000001C   01D0               BEQ.N    ??chk_mounted_0
   1491          		return FR_INVALID_DRIVE;
   \   0000001E   0B20               MOVS     R0,#+11
   \   00000020   05E0               B.N      ??chk_mounted_1
   1492          	*rfs = fs = FatFs[vol];			/* Returen pointer to the corresponding file system object */
   \                     ??chk_mounted_0:
   \   00000022   8E4D               LDR.N    R5,??chk_mounted_2  ;; Fsid
   \   00000024   6E68               LDR      R6,[R5, #+4]
   \   00000026   0E60               STR      R6,[R1, #+0]
   1493          	if (!fs) return FR_NOT_ENABLED;	/* Is the file system object available? */
   \   00000028   002E               CMP      R6,#+0
   \   0000002A   02D1               BNE.N    ??chk_mounted_3
   \   0000002C   0C20               MOVS     R0,#+12
   \                     ??chk_mounted_1:
   \   0000002E   BDE8F081           POP      {R4-R8,PC}
   1494          
   1495          	ENTER_FF(fs);					/* Lock file system */
   1496          
   1497          	if (fs->fs_type) {				/* If the logical drive has been mounted */
   \                     ??chk_mounted_3:
   \   00000032   3078               LDRB     R0,[R6, #+0]
   \   00000034   68B1               CBZ      R0,??chk_mounted_4
   1498          		stat = disk_status(fs->drive);
   \   00000036   7078               LDRB     R0,[R6, #+1]
   \   00000038   ........           BL       disk_status
   1499          		if (!(stat & STA_NOINIT)) {	/* and the physical drive is kept initialized (has not been changed), */
   \   0000003C   10F0010F           TST      R0,#0x1
   \   00000040   07D1               BNE.N    ??chk_mounted_4
   1500          #if !_FS_READONLY
   1501          			if (chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
   \   00000042   002C               CMP      R4,#+0
   \   00000044   01D0               BEQ.N    ??chk_mounted_5
   \   00000046   10F0040F           TST      R0,#0x4
   \                     ??chk_mounted_5:
   \   0000004A   00F00581           BEQ.W    ??chk_mounted_6
   1502          				return FR_WRITE_PROTECTED;
   \                     ??chk_mounted_7:
   \   0000004E   0A20               MOVS     R0,#+10
   \   00000050   EDE7               B.N      ??chk_mounted_1
   1503          #endif
   1504          			return FR_OK;			/* The file system object is valid */
   1505          		}
   1506          	}
   1507          
   1508          	/* The logical drive must be mounted. Following code attempts to mount the volume */
   1509          
   1510          	fs->fs_type = 0;					/* Clear the file system object */
   \                     ??chk_mounted_4:
   \   00000052   0020               MOVS     R0,#+0
   \   00000054   3070               STRB     R0,[R6, #+0]
   1511          	fs->drive = (BYTE)LD2PD(vol);		/* Bind the logical drive and a physical drive */
   \   00000056   7070               STRB     R0,[R6, #+1]
   1512          	stat = disk_initialize(fs->drive);	/* Initialize low level disk I/O layer */
   \   00000058   ........           BL       disk_initialize
   1513          	if (stat & STA_NOINIT)				/* Check if the drive is ready */
   \   0000005C   10F0010F           TST      R0,#0x1
   \   00000060   01D0               BEQ.N    ??chk_mounted_8
   1514          		return FR_NOT_READY;
   \   00000062   0320               MOVS     R0,#+3
   \   00000064   E3E7               B.N      ??chk_mounted_1
   1515          #if _MAX_SS != 512						/* Get disk sector size if needed */
   1516          	if (disk_ioctl(fs->drive, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
   1517          		return FR_NO_FILESYSTEM;
   1518          #endif
   1519          #if !_FS_READONLY
   1520          	if (chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
   \                     ??chk_mounted_8:
   \   00000066   002C               CMP      R4,#+0
   \   00000068   02D0               BEQ.N    ??chk_mounted_9
   \   0000006A   10F0040F           TST      R0,#0x4
   \   0000006E   EED1               BNE.N    ??chk_mounted_7
   1521          		return FR_WRITE_PROTECTED;
   1522          #endif
   1523          	/* Search FAT partition on the drive */
   1524          	fmt = check_fs(fs, bsect = 0);		/* Check sector 0 as an SFD format */
   \                     ??chk_mounted_9:
   \   00000070   4FF00008           MOV      R8,#+0
   \   00000074   0021               MOVS     R1,#+0
   \   00000076   3046               MOV      R0,R6
   \   00000078   ........           BL       check_fs
   \   0000007C   0446               MOV      R4,R0
   1525          	if (fmt == 1) {						/* Not an FAT boot record, it may be patitioned */
   \   0000007E   0128               CMP      R0,#+1
   \   00000080   13D1               BNE.N    ??chk_mounted_10
   1526          		/* Check a partition listed in top of the partition table */
   1527          		tbl = &fs->win[MBR_Table + LD2PT(vol) * 16];	/* Partition table */
   \   00000082   06F5F770           ADD      R0,R6,#+494
   1528          		if (tbl[4]) {									/* Is the partition existing? */
   \   00000086   0179               LDRB     R1,[R0, #+4]
   \   00000088   79B1               CBZ      R1,??chk_mounted_10
   1529          			bsect = LD_DWORD(&tbl[8]);					/* Partition offset in LBA */
   \   0000008A   C17A               LDRB     R1,[R0, #+11]
   \   0000008C   827A               LDRB     R2,[R0, #+10]
   \   0000008E   1204               LSLS     R2,R2,#+16
   \   00000090   42EA0161           ORR      R1,R2,R1, LSL #+24
   \   00000094   427A               LDRB     R2,[R0, #+9]
   \   00000096   41EA0221           ORR      R1,R1,R2, LSL #+8
   \   0000009A   007A               LDRB     R0,[R0, #+8]
   \   0000009C   40EA0108           ORR      R8,R0,R1
   1530          			fmt = check_fs(fs, bsect);					/* Check the partition */
   \   000000A0   4146               MOV      R1,R8
   \   000000A2   3046               MOV      R0,R6
   \   000000A4   ........           BL       check_fs
   \   000000A8   0446               MOV      R4,R0
   1531          		}
   1532          	}
   1533          	if (fmt == 3) return FR_DISK_ERR;
   \                     ??chk_mounted_10:
   \   000000AA   032C               CMP      R4,#+3
   \   000000AC   01D1               BNE.N    ??chk_mounted_11
   \   000000AE   0120               MOVS     R0,#+1
   \   000000B0   BDE7               B.N      ??chk_mounted_1
   1534          	if (fmt || LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))	/* No valid FAT patition is found */
   \                     ??chk_mounted_11:
   \   000000B2   002C               CMP      R4,#+0
   \   000000B4   09D1               BNE.N    ??chk_mounted_12
   \   000000B6   06F13007           ADD      R7,R6,#+48
   \   000000BA   387B               LDRB     R0,[R7, #+12]
   \   000000BC   F97A               LDRB     R1,[R7, #+11]
   \   000000BE   41EA0020           ORR      R0,R1,R0, LSL #+8
   \   000000C2   4FF40071           MOV      R1,#+512
   \   000000C6   8842               CMP      R0,R1
   \   000000C8   01D0               BEQ.N    ??chk_mounted_13
   1535          		return FR_NO_FILESYSTEM;
   \                     ??chk_mounted_12:
   \   000000CA   0D20               MOVS     R0,#+13
   \   000000CC   AFE7               B.N      ??chk_mounted_1
   1536          
   1537          	/* Initialize the file system object */
   1538          	fsize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
   \                     ??chk_mounted_13:
   \   000000CE   F87D               LDRB     R0,[R7, #+23]
   \   000000D0   B97D               LDRB     R1,[R7, #+22]
   \   000000D2   41EA0021           ORR      R1,R1,R0, LSL #+8
   1539          	if (!fsize) fsize = LD_DWORD(fs->win+BPB_FATSz32);
   \   000000D6   06F15000           ADD      R0,R6,#+80
   \   000000DA   49B9               CBNZ     R1,??chk_mounted_14
   \   000000DC   C179               LDRB     R1,[R0, #+7]
   \   000000DE   8279               LDRB     R2,[R0, #+6]
   \   000000E0   1204               LSLS     R2,R2,#+16
   \   000000E2   42EA0161           ORR      R1,R2,R1, LSL #+24
   \   000000E6   4279               LDRB     R2,[R0, #+5]
   \   000000E8   41EA0221           ORR      R1,R1,R2, LSL #+8
   \   000000EC   0279               LDRB     R2,[R0, #+4]
   \   000000EE   1143               ORRS     R1,R2,R1
   1540          	fs->sects_fat = fsize;
   \                     ??chk_mounted_14:
   \   000000F0   B161               STR      R1,[R6, #+24]
   1541          	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
   \   000000F2   3A7C               LDRB     R2,[R7, #+16]
   \   000000F4   F270               STRB     R2,[R6, #+3]
   1542          	fsize *= fs->n_fats;								/* (Number of sectors in FAT area) */
   \   000000F6   5143               MULS     R1,R1,R2
   1543          	fs->fatbase = bsect + LD_WORD(fs->win+BPB_RsvdSecCnt); /* FAT start sector (lba) */
   \   000000F8   FA7B               LDRB     R2,[R7, #+15]
   \   000000FA   BB7B               LDRB     R3,[R7, #+14]
   \   000000FC   43EA0222           ORR      R2,R3,R2, LSL #+8
   \   00000100   4244               ADD      R2,R2,R8
   \   00000102   3262               STR      R2,[R6, #+32]
   1544          	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
   \   00000104   7A7B               LDRB     R2,[R7, #+13]
   \   00000106   B270               STRB     R2,[R6, #+2]
   1545          	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Nmuber of root directory entries */
   \   00000108   BB7C               LDRB     R3,[R7, #+18]
   \   0000010A   7C7C               LDRB     R4,[R7, #+17]
   \   0000010C   44EA0323           ORR      R3,R4,R3, LSL #+8
   \   00000110   3381               STRH     R3,[R6, #+8]
   1546          	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
   \   00000112   3C7D               LDRB     R4,[R7, #+20]
   \   00000114   97F813C0           LDRB     R12,[R7, #+19]
   \   00000118   5CEA0424           ORRS     R4,R12,R4, LSL #+8
   1547          	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
   \   0000011C   0ED1               BNE.N    ??chk_mounted_15
   \   0000011E   C478               LDRB     R4,[R0, #+3]
   \   00000120   90F802C0           LDRB     R12,[R0, #+2]
   \   00000124   4FEA0C4C           LSL      R12,R12,#+16
   \   00000128   4CEA0464           ORR      R4,R12,R4, LSL #+24
   \   0000012C   90F801C0           LDRB     R12,[R0, #+1]
   \   00000130   44EA0C24           ORR      R4,R4,R12, LSL #+8
   \   00000134   96F850C0           LDRB     R12,[R6, #+80]
   \   00000138   4CEA0404           ORR      R4,R12,R4
   1548          	fs->max_clust = mclst = (tsect						/* Last cluster# + 1 (Number of clusters + 2) */
   1549          		- LD_WORD(fs->win+BPB_RsvdSecCnt) - fsize - fs->n_rootdir / (SS(fs)/32)
   1550          		) / fs->csize + 2;
   \                     ??chk_mounted_15:
   \   0000013C   1B09               LSRS     R3,R3,#+4
   \   0000013E   97F80FC0           LDRB     R12,[R7, #+15]
   \   00000142   97F80EE0           LDRB     LR,[R7, #+14]
   \   00000146   4EEA0C2C           ORR      R12,LR,R12, LSL #+8
   \   0000014A   A4EB0C04           SUB      R4,R4,R12
   \   0000014E   641A               SUBS     R4,R4,R1
   \   00000150   E41A               SUBS     R4,R4,R3
   \   00000152   B4FBF2F2           UDIV     R2,R4,R2
   \   00000156   921C               ADDS     R2,R2,#+2
   \   00000158   F261               STR      R2,[R6, #+28]
   1551          
   1552          	fmt = FS_FAT12;										/* Determine the FAT sub type */
   \   0000015A   0124               MOVS     R4,#+1
   1553          	if (mclst >= 0xFF7) fmt = FS_FAT16;					/* Number of clusters >= 0xFF5 */
   \   0000015C   40F6F77C           MOVW     R12,#+4087
   \   00000160   6245               CMP      R2,R12
   \   00000162   00D3               BCC.N    ??chk_mounted_16
   \   00000164   0224               MOVS     R4,#+2
   1554          	if (mclst >= 0xFFF7) fmt = FS_FAT32;				/* Number of clusters >= 0xFFF5 */
   \                     ??chk_mounted_16:
   \   00000166   4FF6F77C           MOVW     R12,#+65527
   \   0000016A   6245               CMP      R2,R12
   \   0000016C   01D3               BCC.N    ??chk_mounted_17
   \   0000016E   0324               MOVS     R4,#+3
   \   00000170   01E0               B.N      ??chk_mounted_18
   1555          
   1556          	if (fmt == FS_FAT32)
   \                     ??chk_mounted_17:
   \   00000172   032C               CMP      R4,#+3
   \   00000174   0FD1               BNE.N    ??chk_mounted_19
   1557          		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
   \                     ??chk_mounted_18:
   \   00000176   C27B               LDRB     R2,[R0, #+15]
   \   00000178   90F80EC0           LDRB     R12,[R0, #+14]
   \   0000017C   4FEA0C4C           LSL      R12,R12,#+16
   \   00000180   4CEA0262           ORR      R2,R12,R2, LSL #+24
   \   00000184   90F80DC0           LDRB     R12,[R0, #+13]
   \   00000188   42EA0C22           ORR      R2,R2,R12, LSL #+8
   \   0000018C   90F80CC0           LDRB     R12,[R0, #+12]
   \   00000190   4CEA0202           ORR      R2,R12,R2
   \   00000194   01E0               B.N      ??chk_mounted_20
   1558          	else
   1559          		fs->dirbase = fs->fatbase + fsize;				/* Root directory start sector (lba) */
   \                     ??chk_mounted_19:
   \   00000196   326A               LDR      R2,[R6, #+32]
   \   00000198   8A18               ADDS     R2,R1,R2
   \                     ??chk_mounted_20:
   \   0000019A   7262               STR      R2,[R6, #+36]
   1560          	fs->database = fs->fatbase + fsize + fs->n_rootdir / (SS(fs)/32);	/* Data start sector (lba) */
   \   0000019C   326A               LDR      R2,[R6, #+32]
   \   0000019E   8918               ADDS     R1,R1,R2
   \   000001A0   5918               ADDS     R1,R3,R1
   \   000001A2   B162               STR      R1,[R6, #+40]
   1561          
   1562          #if !_FS_READONLY
   1563          	/* Initialize allocation information */
   1564          	fs->free_clust = 0xFFFFFFFF;
   \   000001A4   4FF0FF31           MOV      R1,#-1
   \   000001A8   3161               STR      R1,[R6, #+16]
   1565          	fs->wflag = 0;
   \   000001AA   0021               MOVS     R1,#+0
   \   000001AC   3171               STRB     R1,[R6, #+4]
   1566          	/* Get fsinfo if needed */
   1567          	if (fmt == FS_FAT32) {
   \   000001AE   032C               CMP      R4,#+3
   \   000001B0   4BD1               BNE.N    ??chk_mounted_21
   1568          	 	fs->fsi_flag = 0;
   \   000001B2   7171               STRB     R1,[R6, #+5]
   1569          		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
   \   000001B4   417C               LDRB     R1,[R0, #+17]
   \   000001B6   007C               LDRB     R0,[R0, #+16]
   \   000001B8   40EA0120           ORR      R0,R0,R1, LSL #+8
   \   000001BC   00EB0802           ADD      R2,R0,R8
   \   000001C0   7261               STR      R2,[R6, #+20]
   1570          		if (disk_read(fs->drive, fs->win, fs->fsi_sector, 1) == RES_OK &&
   1571          			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
   1572          			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
   1573          			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
   \   000001C2   0123               MOVS     R3,#+1
   \   000001C4   06F13001           ADD      R1,R6,#+48
   \   000001C8   7078               LDRB     R0,[R6, #+1]
   \   000001CA   ........           BL       disk_read
   \   000001CE   0028               CMP      R0,#+0
   \   000001D0   3BD1               BNE.N    ??chk_mounted_21
   \   000001D2   06F50570           ADD      R0,R6,#+532
   \   000001D6   C17E               LDRB     R1,[R0, #+27]
   \   000001D8   827E               LDRB     R2,[R0, #+26]
   \   000001DA   42EA0121           ORR      R1,R2,R1, LSL #+8
   \   000001DE   4AF65522           MOVW     R2,#+43605
   \   000001E2   9142               CMP      R1,R2
   \   000001E4   31D1               BNE.N    ??chk_mounted_21
   \   000001E6   F978               LDRB     R1,[R7, #+3]
   \   000001E8   BA78               LDRB     R2,[R7, #+2]
   \   000001EA   1204               LSLS     R2,R2,#+16
   \   000001EC   42EA0161           ORR      R1,R2,R1, LSL #+24
   \   000001F0   7A78               LDRB     R2,[R7, #+1]
   \   000001F2   41EA0221           ORR      R1,R1,R2, LSL #+8
   \   000001F6   96F83020           LDRB     R2,[R6, #+48]
   \   000001FA   1143               ORRS     R1,R2,R1
   \   000001FC   184A               LDR.N    R2,??chk_mounted_2+0x4  ;; 0x41615252
   \   000001FE   9142               CMP      R1,R2
   \   00000200   23D1               BNE.N    ??chk_mounted_21
   \   00000202   C178               LDRB     R1,[R0, #+3]
   \   00000204   8278               LDRB     R2,[R0, #+2]
   \   00000206   1204               LSLS     R2,R2,#+16
   \   00000208   42EA0161           ORR      R1,R2,R1, LSL #+24
   \   0000020C   4278               LDRB     R2,[R0, #+1]
   \   0000020E   41EA0221           ORR      R1,R1,R2, LSL #+8
   \   00000212   96F81422           LDRB     R2,[R6, #+532]
   \   00000216   1143               ORRS     R1,R2,R1
   \   00000218   124A               LDR.N    R2,??chk_mounted_2+0x8  ;; 0x61417272
   \   0000021A   9142               CMP      R1,R2
   \   0000021C   15D1               BNE.N    ??chk_mounted_21
   1574          			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
   \   0000021E   C17A               LDRB     R1,[R0, #+11]
   \   00000220   827A               LDRB     R2,[R0, #+10]
   \   00000222   1204               LSLS     R2,R2,#+16
   \   00000224   42EA0161           ORR      R1,R2,R1, LSL #+24
   \   00000228   427A               LDRB     R2,[R0, #+9]
   \   0000022A   41EA0221           ORR      R1,R1,R2, LSL #+8
   \   0000022E   027A               LDRB     R2,[R0, #+8]
   \   00000230   1143               ORRS     R1,R2,R1
   \   00000232   F160               STR      R1,[R6, #+12]
   1575          			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
   \   00000234   C179               LDRB     R1,[R0, #+7]
   \   00000236   8279               LDRB     R2,[R0, #+6]
   \   00000238   1204               LSLS     R2,R2,#+16
   \   0000023A   42EA0161           ORR      R1,R2,R1, LSL #+24
   \   0000023E   4279               LDRB     R2,[R0, #+5]
   \   00000240   41EA0221           ORR      R1,R1,R2, LSL #+8
   \   00000244   0079               LDRB     R0,[R0, #+4]
   \   00000246   0843               ORRS     R0,R0,R1
   \   00000248   3061               STR      R0,[R6, #+16]
   1576          		}
   1577          	}
   1578          #endif
   1579          	fs->fs_type = fmt;		/* FAT sub-type */
   \                     ??chk_mounted_21:
   \   0000024A   3470               STRB     R4,[R6, #+0]
   1580          	fs->winsect = 0;		/* Invalidate sector cache */
   \   0000024C   0020               MOVS     R0,#+0
   \   0000024E   F062               STR      R0,[R6, #+44]
   1581          #if _FS_RPATH
   1582          	fs->cdir = 0;			/* Current directory (root dir) */
   1583          #endif
   1584          	fs->id = ++Fsid;		/* File system mount ID */
   \   00000250   2888               LDRH     R0,[R5, #+0]
   \   00000252   401C               ADDS     R0,R0,#+1
   \   00000254   2880               STRH     R0,[R5, #+0]
   \   00000256   F080               STRH     R0,[R6, #+6]
   1585          
   1586          	return FR_OK;
   \                     ??chk_mounted_6:
   \   00000258   0020               MOVS     R0,#+0
   \   0000025A   E8E6               B.N      ??chk_mounted_1
   \                     ??chk_mounted_2:
   \   0000025C   ........           DC32     Fsid
   \   00000260   52526141           DC32     0x41615252
   \   00000264   72724161           DC32     0x61417272
   1587          }
   1588          
   1589          
   1590          
   1591          
   1592          /*-----------------------------------------------------------------------*/
   1593          /* Check if the file/dir object is valid or not                          */
   1594          /*-----------------------------------------------------------------------*/
   1595          

   \                                 In section .text, align 2, keep-with-next
   1596          static
   1597          FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
   1598          	FATFS *fs,		/* Pointer to the file system object */
   1599          	WORD id			/* Member id of the target object to be checked */
   1600          )
   1601          {
   \                     validate:
   \   00000000   80B5               PUSH     {R7,LR}
   1602          	if (!fs || !fs->fs_type || fs->id != id)
   \   00000002   0028               CMP      R0,#+0
   \   00000004   05D0               BEQ.N    ??validate_0
   \   00000006   0278               LDRB     R2,[R0, #+0]
   \   00000008   002A               CMP      R2,#+0
   \   0000000A   02D0               BEQ.N    ??validate_0
   \   0000000C   C288               LDRH     R2,[R0, #+6]
   \   0000000E   8A42               CMP      R2,R1
   \   00000010   01D0               BEQ.N    ??validate_1
   1603          		return FR_INVALID_OBJECT;
   \                     ??validate_0:
   \   00000012   0920               MOVS     R0,#+9
   \   00000014   02BD               POP      {R1,PC}
   1604          
   1605          	ENTER_FF(fs);		/* Lock file system */
   1606          
   1607          	if (disk_status(fs->drive) & STA_NOINIT)
   \                     ??validate_1:
   \   00000016   4078               LDRB     R0,[R0, #+1]
   \   00000018   ........           BL       disk_status
   \   0000001C   10F0010F           TST      R0,#0x1
   \   00000020   01D0               BEQ.N    ??validate_2
   1608          		return FR_NOT_READY;
   \   00000022   0320               MOVS     R0,#+3
   \   00000024   02BD               POP      {R1,PC}
   1609          
   1610          	return FR_OK;
   \                     ??validate_2:
   \   00000026   0020               MOVS     R0,#+0
   \   00000028   02BD               POP      {R1,PC}          ;; return
   1611          }
   1612          
   1613          
   1614          
   1615          
   1616          /*--------------------------------------------------------------------------
   1617          
   1618             Public Functions
   1619          
   1620          --------------------------------------------------------------------------*/
   1621          
   1622          
   1623          
   1624          /*-----------------------------------------------------------------------*/
   1625          /* Mount/Unmount a Locical Drive                                         */
   1626          /*-----------------------------------------------------------------------*/
   1627          

   \                                 In section .text, align 4, keep-with-next
   1628          FRESULT f_mount (
   1629          	BYTE vol,		/* Logical drive number to be mounted/unmounted */
   1630          	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
   1631          )
   1632          {
   1633          	FATFS *rfs;
   1634          
   1635          
   1636          	if (vol >= _DRIVES)				/* Check if the drive number is valid */
   \                     f_mount:
   \   00000000   0028               CMP      R0,#+0
   \   00000002   01D0               BEQ.N    ??f_mount_0
   1637          		return FR_INVALID_DRIVE;
   \   00000004   0B20               MOVS     R0,#+11
   \   00000006   7047               BX       LR
   1638          	rfs = FatFs[vol];				/* Get current fs object */
   \                     ??f_mount_0:
   \   00000008   0548               LDR.N    R0,??f_mount_1   ;; Fsid
   \   0000000A   4268               LDR      R2,[R0, #+4]
   1639          
   1640          	if (rfs) {
   \   0000000C   0AB1               CBZ      R2,??f_mount_2
   1641          #if _FS_REENTRANT					/* Discard sync object of the current volume */
   1642          		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
   1643          #endif
   1644          		rfs->fs_type = 0;			/* Clear old fs object */
   \   0000000E   0023               MOVS     R3,#+0
   \   00000010   1370               STRB     R3,[R2, #+0]
   1645          	}
   1646          
   1647          	if (fs) {
   \                     ??f_mount_2:
   \   00000012   0029               CMP      R1,#+0
   \   00000014   01D0               BEQ.N    ??f_mount_3
   1648          		fs->fs_type = 0;			/* Clear new fs object */
   \   00000016   0022               MOVS     R2,#+0
   \   00000018   0A70               STRB     R2,[R1, #+0]
   1649          #if _FS_REENTRANT					/* Create sync object for the new volume */
   1650          		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
   1651          #endif
   1652          	}
   1653          	FatFs[vol] = fs;				/* Register new fs object */
   \                     ??f_mount_3:
   \   0000001A   4160               STR      R1,[R0, #+4]
   1654          
   1655          	return FR_OK;
   \   0000001C   0020               MOVS     R0,#+0
   \   0000001E   7047               BX       LR               ;; return
   \                     ??f_mount_1:
   \   00000020   ........           DC32     Fsid
   1656          }
   1657          
   1658          
   1659          
   1660          
   1661          /*-----------------------------------------------------------------------*/
   1662          /* Open or Create a File                                                 */
   1663          /*-----------------------------------------------------------------------*/
   1664          

   \                                 In section .text, align 2, keep-with-next
   1665          FRESULT f_open (
   1666          	FIL *fp,			/* Pointer to the blank file object */
   1667          	const XCHAR *path,	/* Pointer to the file name */
   1668          	BYTE mode			/* Access mode and file open mode flags */
   1669          )
   1670          {
   \                     f_open:
   \   00000000   2DE9F241           PUSH     {R1,R4-R8,LR}
   \   00000004   8DB0               SUB      SP,SP,#+52
   \   00000006   0546               MOV      R5,R0
   1671          	FRESULT res;
   1672          	DIR dj;
   1673          	NAMEBUF(sfn, lfn);
   1674          	BYTE *dir;
   1675          
   1676          
   1677          	fp->fs = NULL;		/* Clear file object */
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   2860               STR      R0,[R5, #+0]
   1678          #if !_FS_READONLY
   1679          	mode &= (FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW);
   \   0000000C   02F01F06           AND      R6,R2,#0x1F
   1680          	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & (FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)));
   \   00000010   06F01E02           AND      R2,R6,#0x1E
   \   00000014   00A9               ADD      R1,SP,#+0
   \   00000016   0DA8               ADD      R0,SP,#+52
   \   00000018   ........           BL       chk_mounted
   1681          #else
   1682          	mode &= FA_READ;
   1683          	res = chk_mounted(&path, &dj.fs, 0);
   1684          #endif
   1685          	if (res != FR_OK) LEAVE_FF(dj.fs, res);
   \   0000001C   0100               MOVS     R1,R0
   \   0000001E   22D1               BNE.N    ??f_open_0
   1686          	INITBUF(dj, sfn, lfn);
   \   00000020   ........           BL       ?Subroutine15
   1687          	res = follow_path(&dj, path);	/* Follow the file path */
   \                     ??CrossCallReturnLabel_25:
   \   00000024   0D99               LDR      R1,[SP, #+52]
   \   00000026   00A8               ADD      R0,SP,#+0
   \   00000028   ........           BL       follow_path
   1688          
   1689          #if !_FS_READONLY
   1690          	/* Create or Open a file */
   1691          	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
   \   0000002C   16F01C0F           TST      R6,#0x1C
   \   00000030   5DD0               BEQ.N    ??f_open_1
   1692          		DWORD ps, cl;
   1693          
   1694          		if (res != FR_OK) {			/* No file, create new */
   \   00000032   0100               MOVS     R1,R0
   \   00000034   0AD0               BEQ.N    ??f_open_2
   1695          			if (res == FR_NO_FILE)	/* There is no file to open, create a new entry */
   \   00000036   0428               CMP      R0,#+4
   \   00000038   02D1               BNE.N    ??f_open_3
   1696          				res = dir_register(&dj);
   \   0000003A   00A8               ADD      R0,SP,#+0
   \   0000003C   ........           BL       dir_register
   1697          			if (res != FR_OK) LEAVE_FF(dj.fs, res);
   \                     ??f_open_3:
   \   00000040   0100               MOVS     R1,R0
   \   00000042   10D1               BNE.N    ??f_open_0
   1698          			mode |= FA_CREATE_ALWAYS;
   \   00000044   46F00806           ORR      R6,R6,#0x8
   1699          			dir = dj.dir;			/* Created entry (SFN entry) */
   \   00000048   059F               LDR      R7,[SP, #+20]
   \   0000004A   3AE0               B.N      ??f_open_4
   1700          		}
   1701          		else {						/* Any object is already existing */
   1702          			if (mode & FA_CREATE_NEW)			/* Cannot create new */
   \                     ??f_open_2:
   \   0000004C   16F0040F           TST      R6,#0x4
   \   00000050   01D0               BEQ.N    ??f_open_5
   1703          				LEAVE_FF(dj.fs, FR_EXIST);
   \   00000052   0820               MOVS     R0,#+8
   \   00000054   07E0               B.N      ??f_open_0
   1704          			dir = dj.dir;
   \                     ??f_open_5:
   \   00000056   059F               LDR      R7,[SP, #+20]
   1705          			if (!dir || (dir[DIR_Attr] & (AM_RDO | AM_DIR)))	/* Cannot overwrite it (R/O or DIR) */
   \   00000058   002F               CMP      R7,#+0
   \   0000005A   03D0               BEQ.N    ??f_open_6
   \   0000005C   F87A               LDRB     R0,[R7, #+11]
   \   0000005E   30F0EE00           BICS     R0,R0,#0xEE
   \   00000062   03D0               BEQ.N    ??f_open_7
   1706          				LEAVE_FF(dj.fs, FR_DENIED);
   \                     ??f_open_6:
   \   00000064   0720               MOVS     R0,#+7
   \                     ??f_open_0:
   \   00000066   0EB0               ADD      SP,SP,#+56
   \   00000068   BDE8F081           POP      {R4-R8,PC}
   1707          			if (mode & FA_CREATE_ALWAYS) {		/* Resize it to zero on over write mode */
   \                     ??f_open_7:
   \   0000006C   16F0080F           TST      R6,#0x8
   \   00000070   4ED0               BEQ.N    ??f_open_8
   1708          				cl = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);	/* Get start cluster */
   \   00000072   787D               LDRB     R0,[R7, #+21]
   \   00000074   397D               LDRB     R1,[R7, #+20]
   \   00000076   41EA0020           ORR      R0,R1,R0, LSL #+8
   \   0000007A   F97E               LDRB     R1,[R7, #+27]
   \   0000007C   BA7E               LDRB     R2,[R7, #+26]
   \   0000007E   42EA0121           ORR      R1,R2,R1, LSL #+8
   \   00000082   41EA0044           ORR      R4,R1,R0, LSL #+16
   1709          				ST_WORD(dir+DIR_FstClusHI, 0);	/* cluster = 0 */
   \   00000086   0020               MOVS     R0,#+0
   \   00000088   3875               STRB     R0,[R7, #+20]
   \   0000008A   7875               STRB     R0,[R7, #+21]
   1710          				ST_WORD(dir+DIR_FstClusLO, 0);
   \   0000008C   B876               STRB     R0,[R7, #+26]
   \   0000008E   F876               STRB     R0,[R7, #+27]
   1711          				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
   \   00000090   3877               STRB     R0,[R7, #+28]
   \   00000092   7877               STRB     R0,[R7, #+29]
   \   00000094   B877               STRB     R0,[R7, #+30]
   \   00000096   F877               STRB     R0,[R7, #+31]
   1712          				dj.fs->wflag = 1;
   \   00000098   0098               LDR      R0,[SP, #+0]
   \   0000009A   0121               MOVS     R1,#+1
   \   0000009C   0171               STRB     R1,[R0, #+4]
   1713          				ps = dj.fs->winsect;			/* Remove the cluster chain */
   \   0000009E   0098               LDR      R0,[SP, #+0]
   \   000000A0   D0F82C80           LDR      R8,[R0, #+44]
   1714          				if (cl) {
   \   000000A4   3CB1               CBZ      R4,??f_open_9
   1715          					res = remove_chain(dj.fs, cl);
   \   000000A6   2146               MOV      R1,R4
   \   000000A8   ........           BL       remove_chain
   1716          					if (res) LEAVE_FF(dj.fs, res);
   \   000000AC   0100               MOVS     R1,R0
   \   000000AE   DAD1               BNE.N    ??f_open_0
   1717          					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
   \   000000B0   0098               LDR      R0,[SP, #+0]
   \   000000B2   611E               SUBS     R1,R4,#+1
   \   000000B4   C160               STR      R1,[R0, #+12]
   1718          				}
   1719          				res = move_window(dj.fs, ps);
   \                     ??f_open_9:
   \   000000B6   4146               MOV      R1,R8
   \   000000B8   0098               LDR      R0,[SP, #+0]
   \   000000BA   ........           BL       move_window
   1720          				if (res != FR_OK) LEAVE_FF(dj.fs, res);
   \   000000BE   0100               MOVS     R1,R0
   \   000000C0   D1D1               BNE.N    ??f_open_0
   1721          			}
   1722          		}
   1723          		if (mode & FA_CREATE_ALWAYS) {
   \                     ??f_open_4:
   \   000000C2   16F0080F           TST      R6,#0x8
   \   000000C6   23D0               BEQ.N    ??f_open_8
   1724          			dir[DIR_Attr] = 0;					/* Reset attribute */
   \   000000C8   0020               MOVS     R0,#+0
   \   000000CA   F872               STRB     R0,[R7, #+11]
   1725          			ps = get_fattime();
   \   000000CC   ........           BL       get_fattime
   \   000000D0   0146               MOV      R1,R0
   1726          			ST_DWORD(dir+DIR_CrtTime, ps);		/* Created time */
   \   000000D2   B973               STRB     R1,[R7, #+14]
   \   000000D4   0004               LSLS     R0,R0,#+16
   \   000000D6   000E               LSRS     R0,R0,#+24
   \   000000D8   F873               STRB     R0,[R7, #+15]
   \   000000DA   080C               LSRS     R0,R1,#+16
   \   000000DC   3874               STRB     R0,[R7, #+16]
   \   000000DE   080E               LSRS     R0,R1,#+24
   \   000000E0   7874               STRB     R0,[R7, #+17]
   1727          			dj.fs->wflag = 1;
   \   000000E2   0098               LDR      R0,[SP, #+0]
   \   000000E4   0121               MOVS     R1,#+1
   \   000000E6   0171               STRB     R1,[R0, #+4]
   1728          			mode |= FA__WRITTEN;				/* Set file changed flag */
   \   000000E8   46F02006           ORR      R6,R6,#0x20
   \   000000EC   10E0               B.N      ??f_open_8
   1729          		}
   1730          	}
   1731          	/* Open an existing file */
   1732          	else {
   1733          #endif /* !_FS_READONLY */
   1734          		if (res != FR_OK) LEAVE_FF(dj.fs, res);	/* Follow failed */
   \                     ??f_open_1:
   \   000000EE   0100               MOVS     R1,R0
   \   000000F0   B9D1               BNE.N    ??f_open_0
   1735          		dir = dj.dir;
   \   000000F2   059F               LDR      R7,[SP, #+20]
   1736          		if (!dir || (dir[DIR_Attr] & AM_DIR))	/* It is a directory */
   \   000000F4   002F               CMP      R7,#+0
   \   000000F6   03D0               BEQ.N    ??f_open_10
   \   000000F8   F87A               LDRB     R0,[R7, #+11]
   \   000000FA   10F0100F           TST      R0,#0x10
   \   000000FE   01D0               BEQ.N    ??f_open_11
   1737          			LEAVE_FF(dj.fs, FR_NO_FILE);
   \                     ??f_open_10:
   \   00000100   0420               MOVS     R0,#+4
   \   00000102   B0E7               B.N      ??f_open_0
   1738          #if !_FS_READONLY
   1739          		if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
   \                     ??f_open_11:
   \   00000104   16F0020F           TST      R6,#0x2
   \   00000108   02D0               BEQ.N    ??f_open_8
   \   0000010A   10F0010F           TST      R0,#0x1
   \   0000010E   A9D1               BNE.N    ??f_open_6
   1740          			LEAVE_FF(dj.fs, FR_DENIED);
   1741          	}
   1742          	fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
   \                     ??f_open_8:
   \   00000110   0098               LDR      R0,[SP, #+0]
   \   00000112   C06A               LDR      R0,[R0, #+44]
   \   00000114   E861               STR      R0,[R5, #+28]
   1743          	fp->dir_ptr = dj.dir;
   \   00000116   0598               LDR      R0,[SP, #+20]
   \   00000118   2862               STR      R0,[R5, #+32]
   1744          #endif
   1745          	fp->flag = mode;					/* File access mode */
   \   0000011A   AE71               STRB     R6,[R5, #+6]
   1746          	fp->org_clust =						/* File start cluster */
   1747          		((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
   \   0000011C   787D               LDRB     R0,[R7, #+21]
   \   0000011E   397D               LDRB     R1,[R7, #+20]
   \   00000120   41EA0020           ORR      R0,R1,R0, LSL #+8
   \   00000124   F97E               LDRB     R1,[R7, #+27]
   \   00000126   BA7E               LDRB     R2,[R7, #+26]
   \   00000128   42EA0121           ORR      R1,R2,R1, LSL #+8
   \   0000012C   41EA0040           ORR      R0,R1,R0, LSL #+16
   \   00000130   2861               STR      R0,[R5, #+16]
   1748          	fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
   \   00000132   F87F               LDRB     R0,[R7, #+31]
   \   00000134   B97F               LDRB     R1,[R7, #+30]
   \   00000136   0904               LSLS     R1,R1,#+16
   \   00000138   41EA0060           ORR      R0,R1,R0, LSL #+24
   \   0000013C   797F               LDRB     R1,[R7, #+29]
   \   0000013E   40EA0120           ORR      R0,R0,R1, LSL #+8
   \   00000142   397F               LDRB     R1,[R7, #+28]
   \   00000144   0843               ORRS     R0,R1,R0
   \   00000146   E860               STR      R0,[R5, #+12]
   1749          	fp->fptr = 0; fp->csect = 255;		/* File pointer */
   \   00000148   0020               MOVS     R0,#+0
   \   0000014A   A860               STR      R0,[R5, #+8]
   \   0000014C   FF20               MOVS     R0,#+255
   \   0000014E   E871               STRB     R0,[R5, #+7]
   1750          	fp->dsect = 0;
   \   00000150   0020               MOVS     R0,#+0
   \   00000152   A861               STR      R0,[R5, #+24]
   1751          	fp->fs = dj.fs; fp->id = dj.fs->id;	/* Owner file system object of the file */
   \   00000154   0098               LDR      R0,[SP, #+0]
   \   00000156   2860               STR      R0,[R5, #+0]
   \   00000158   0098               LDR      R0,[SP, #+0]
   \   0000015A   C088               LDRH     R0,[R0, #+6]
   \   0000015C   A880               STRH     R0,[R5, #+4]
   1752          
   1753          	LEAVE_FF(dj.fs, FR_OK);
   \   0000015E   0020               MOVS     R0,#+0
   \   00000160   81E7               B.N      ??f_open_0
   1754          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?Subroutine15:
   \   00000000   09A8               ADD      R0,SP,#+36
   \   00000002   0690               STR      R0,[SP, #+24]
   \   00000004   0148               LDR.N    R0,??Subroutine15_0  ;; LfnBuf
   \   00000006   0790               STR      R0,[SP, #+28]
   \   00000008   7047               BX       LR
   \   0000000A   00BF               Nop      
   \                     ??Subroutine15_0:
   \   0000000C   ........           DC32     LfnBuf
   1755          
   1756          
   1757          
   1758          
   1759          /*-----------------------------------------------------------------------*/
   1760          /* Read File                                                             */
   1761          /*-----------------------------------------------------------------------*/
   1762          

   \                                 In section .text, align 2, keep-with-next
   1763          FRESULT f_read (
   1764          	FIL *fp, 		/* Pointer to the file object */
   1765          	void *buff,		/* Pointer to data buffer */
   1766          	UINT btr,		/* Number of bytes to read */
   1767          	UINT *br		/* Pointer to number of bytes read */
   1768          )
   1769          {
   \                     f_read:
   \   00000000   2DE9F843           PUSH     {R3-R9,LR}
   \   00000004   0446               MOV      R4,R0
   \   00000006   1546               MOV      R5,R2
   \   00000008   ........           BL       ?Subroutine19
   1770          	FRESULT res;
   1771          	DWORD clst, sect, remain;
   1772          	UINT rcnt, cc;
   1773          	BYTE *rbuff = buff;
   1774          
   1775          
   1776          	*br = 0;	/* Initialize bytes read */
   1777          
   1778          	res = validate(fp->fs, fp->id);					/* Check validity of the object */
   \                     ??CrossCallReturnLabel_35:
   \   0000000C   ........           BL       ?Subroutine16
   1779          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \                     ??CrossCallReturnLabel_29:
   \   00000010   0100               MOVS     R1,R0
   \   00000012   09D1               BNE.N    ??f_read_0
   1780          	if (fp->flag & FA__ERROR)						/* Check abort flag */
   \   00000014   A079               LDRB     R0,[R4, #+6]
   \   00000016   10F0800F           TST      R0,#0x80
   \   0000001A   01D0               BEQ.N    ??f_read_1
   1781          		LEAVE_FF(fp->fs, FR_INT_ERR);
   \                     ??f_read_2:
   \   0000001C   0220               MOVS     R0,#+2
   \   0000001E   03E0               B.N      ??f_read_0
   1782          	if (!(fp->flag & FA_READ)) 						/* Check access mode */
   \                     ??f_read_1:
   \   00000020   10F0010F           TST      R0,#0x1
   \   00000024   02D1               BNE.N    ??f_read_3
   1783          		LEAVE_FF(fp->fs, FR_DENIED);
   \   00000026   0720               MOVS     R0,#+7
   \                     ??f_read_0:
   \   00000028   BDE8F283           POP      {R1,R4-R9,PC}
   1784          	remain = fp->fsize - fp->fptr;
   \                     ??f_read_3:
   \   0000002C   E068               LDR      R0,[R4, #+12]
   \   0000002E   A168               LDR      R1,[R4, #+8]
   \   00000030   401A               SUBS     R0,R0,R1
   1785          	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
   \   00000032   A842               CMP      R0,R5
   \   00000034   30D8               BHI.N    ??f_read_4
   \   00000036   0546               MOV      R5,R0
   \   00000038   2EE0               B.N      ??f_read_4
   1786          
   1787          	for ( ;  btr;									/* Repeat until all data transferred */
   1788          		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
   1789          		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
   1790          			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
   1791          				clst = (fp->fptr == 0) ?			/* On the top of the file? */
   1792          					fp->org_clust : get_fat(fp->fs, fp->curr_clust);
   1793          				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
   1794          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   1795          				fp->curr_clust = clst;				/* Update current cluster */
   1796          				fp->csect = 0;						/* Reset sector offset in the cluster */
   1797          			}
   1798          			sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current sector */
   1799          			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   1800          			sect += fp->csect;
   1801          			cc = btr / SS(fp->fs);					/* When remaining bytes >= sector size, */
   1802          			if (cc) {								/* Read maximum contiguous sectors directly */
   1803          				if (fp->csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   1804          					cc = fp->fs->csize - fp->csect;
   1805          				if (disk_read(fp->fs->drive, rbuff, sect, (BYTE)cc) != RES_OK)
   1806          					ABORT(fp->fs, FR_DISK_ERR);
   1807          #if !_FS_READONLY && _FS_MINIMIZE <= 2
   1808          #if _FS_TINY
   1809          				if (fp->fs->wflag && fp->fs->winsect - sect < cc)		/* Replace one of the read sectors with cached data if it contains a dirty sector */
   1810          					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
   1811          #else
   1812          				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)	/* Replace one of the read sectors with cached data if it contains a dirty sector */
   1813          					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
   1814          #endif
   1815          #endif
   1816          				fp->csect += (BYTE)cc;				/* Next sector address in the cluster */
   1817          				rcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
   1818          				continue;
   1819          			}
   1820          #if !_FS_TINY
   1821          #if !_FS_READONLY
   1822          			if (fp->flag & FA__DIRTY) {			/* Write sector I/O buffer if needed */
   \                     ??f_read_5:
   \   0000003A   A079               LDRB     R0,[R4, #+6]
   \   0000003C   10F0400F           TST      R0,#0x40
   \   00000040   05D0               BEQ.N    ??CrossCallReturnLabel_30
   1823          				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
   \   00000042   ........           BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_8:
   \   00000046   0028               CMP      R0,#+0
   \   00000048   41D1               BNE.N    ??f_read_6
   1824          					ABORT(fp->fs, FR_DISK_ERR);
   1825          				fp->flag &= ~FA__DIRTY;
   \   0000004A   ........           BL       ?Subroutine17
   1826          			}
   1827          #endif
   1828          			if (fp->dsect != sect) {			/* Fill sector buffer with file data */
   \                     ??CrossCallReturnLabel_30:
   \   0000004E   A069               LDR      R0,[R4, #+24]
   \   00000050   B042               CMP      R0,R6
   \   00000052   03D0               BEQ.N    ??f_read_7
   1829          				if (disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
   \   00000054   ........           BL       ?Subroutine1
   1830          					ABORT(fp->fs, FR_DISK_ERR);
   1831          			}
   \                     ??CrossCallReturnLabel_6:
   \   00000058   0028               CMP      R0,#+0
   \   0000005A   38D1               BNE.N    ??f_read_6
   1832          #endif
   1833          			fp->dsect = sect;
   \                     ??f_read_7:
   \   0000005C   A661               STR      R6,[R4, #+24]
   1834          			fp->csect++;							/* Next sector address in the cluster */
   \   0000005E   E079               LDRB     R0,[R4, #+7]
   \   00000060   401C               ADDS     R0,R0,#+1
   \   00000062   E071               STRB     R0,[R4, #+7]
   1835          		}
   1836          		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
   \                     ??f_read_8:
   \   00000064   A068               LDR      R0,[R4, #+8]
   \   00000066   C005               LSLS     R0,R0,#+23
   \   00000068   C00D               LSRS     R0,R0,#+23
   \   0000006A   C0F50071           RSB      R1,R0,#+512
   1837          		if (rcnt > btr) rcnt = btr;
   \   0000006E   2E46               MOV      R6,R5
   \   00000070   8D42               CMP      R5,R1
   \   00000072   00D9               BLS.N    ??f_read_9
   \   00000074   0E46               MOV      R6,R1
   1838          #if _FS_TINY
   1839          		if (move_window(fp->fs, fp->dsect))			/* Move sector window */
   1840          			ABORT(fp->fs, FR_DISK_ERR);
   1841          		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   1842          #else
   1843          		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   \                     ??f_read_9:
   \   00000076   3246               MOV      R2,R6
   \   00000078   0019               ADDS     R0,R0,R4
   \   0000007A   00F12401           ADD      R1,R0,#+36
   \   0000007E   4046               MOV      R0,R8
   \   00000080   ........           BL       mem_cpy
   \                     ??f_read_10:
   \   00000084   B044               ADD      R8,R6,R8
   \   00000086   A068               LDR      R0,[R4, #+8]
   \   00000088   3018               ADDS     R0,R6,R0
   \   0000008A   A060               STR      R0,[R4, #+8]
   \   0000008C   D9F80000           LDR      R0,[R9, #+0]
   \   00000090   3018               ADDS     R0,R6,R0
   \   00000092   C9F80000           STR      R0,[R9, #+0]
   \   00000096   AD1B               SUBS     R5,R5,R6
   \                     ??f_read_4:
   \   00000098   002D               CMP      R5,#+0
   \   0000009A   49D0               BEQ.N    ??f_read_11
   \   0000009C   A168               LDR      R1,[R4, #+8]
   \   0000009E   C805               LSLS     R0,R1,#+23
   \   000000A0   E0D1               BNE.N    ??f_read_8
   \   000000A2   2068               LDR      R0,[R4, #+0]
   \   000000A4   E279               LDRB     R2,[R4, #+7]
   \   000000A6   8378               LDRB     R3,[R0, #+2]
   \   000000A8   9A42               CMP      R2,R3
   \   000000AA   19D3               BCC.N    ??f_read_12
   \   000000AC   0029               CMP      R1,#+0
   \   000000AE   0EBF               ITEE     EQ 
   \   000000B0   2069               LDREQ    R0,[R4, #+16]
   \   000000B2   6169               LDRNE    R1,[R4, #+20]
   \   000000B4   ........           BLNE     get_fat
   \   000000B8   0228               CMP      R0,#+2
   \   000000BA   04D2               BCS.N    ??f_read_13
   \                     ??f_read_14:
   \   000000BC   A079               LDRB     R0,[R4, #+6]
   \   000000BE   40F08000           ORR      R0,R0,#0x80
   \   000000C2   A071               STRB     R0,[R4, #+6]
   \   000000C4   AAE7               B.N      ??f_read_2
   \                     ??f_read_13:
   \   000000C6   4FF0FF31           MOV      R1,#-1
   \   000000CA   8842               CMP      R0,R1
   \   000000CC   05D1               BNE.N    ??f_read_15
   \                     ??f_read_6:
   \   000000CE   A079               LDRB     R0,[R4, #+6]
   \   000000D0   40F08000           ORR      R0,R0,#0x80
   \   000000D4   A071               STRB     R0,[R4, #+6]
   \   000000D6   0120               MOVS     R0,#+1
   \   000000D8   A6E7               B.N      ??f_read_0
   \                     ??f_read_15:
   \   000000DA   6061               STR      R0,[R4, #+20]
   \   000000DC   0020               MOVS     R0,#+0
   \   000000DE   E071               STRB     R0,[R4, #+7]
   \                     ??f_read_12:
   \   000000E0   6169               LDR      R1,[R4, #+20]
   \   000000E2   ........           BL       ??Subroutine24_0
   \                     ??CrossCallReturnLabel_57:
   \   000000E6   0600               MOVS     R6,R0
   \   000000E8   E8D0               BEQ.N    ??f_read_14
   \   000000EA   E179               LDRB     R1,[R4, #+7]
   \   000000EC   0E18               ADDS     R6,R1,R0
   \   000000EE   6F0A               LSRS     R7,R5,#+9
   \   000000F0   A3D0               BEQ.N    ??f_read_5
   \   000000F2   2068               LDR      R0,[R4, #+0]
   \   000000F4   ........           BL       ?Subroutine18
   \                     ??CrossCallReturnLabel_33:
   \   000000F8   3246               MOV      R2,R6
   \   000000FA   4146               MOV      R1,R8
   \   000000FC   4078               LDRB     R0,[R0, #+1]
   \   000000FE   ........           BL       disk_read
   \   00000102   0028               CMP      R0,#+0
   \   00000104   E3D1               BNE.N    ??f_read_6
   \   00000106   A079               LDRB     R0,[R4, #+6]
   \   00000108   10F0400F           TST      R0,#0x40
   \   0000010C   0BD0               BEQ.N    ??f_read_16
   \   0000010E   A069               LDR      R0,[R4, #+24]
   \   00000110   801B               SUBS     R0,R0,R6
   \   00000112   B842               CMP      R0,R7
   \   00000114   07D2               BCS.N    ??f_read_16
   \   00000116   4FF40072           MOV      R2,#+512
   \   0000011A   04F12401           ADD      R1,R4,#+36
   \   0000011E   08EB4020           ADD      R0,R8,R0, LSL #+9
   \   00000122   ........           BL       mem_cpy
   \                     ??f_read_16:
   \   00000126   E079               LDRB     R0,[R4, #+7]
   \   00000128   3818               ADDS     R0,R7,R0
   \   0000012A   E071               STRB     R0,[R4, #+7]
   \   0000012C   7E02               LSLS     R6,R7,#+9
   \   0000012E   A9E7               B.N      ??f_read_10
   1844          #endif
   1845          	}
   1846          
   1847          	LEAVE_FF(fp->fs, FR_OK);
   \                     ??f_read_11:
   \   00000130   0020               MOVS     R0,#+0
   \   00000132   79E7               B.N      ??f_read_0
   1848          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine19:
   \   00000000   9946               MOV      R9,R3
   \   00000002   8846               MOV      R8,R1
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   C9F80000           STR      R0,[R9, #+0]
   \   0000000A   7047               BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine18:
   \   00000000   8378               LDRB     R3,[R0, #+2]
   \   00000002   7A18               ADDS     R2,R7,R1
   \   00000004   9342               CMP      R3,R2
   \   00000006   00D2               BCS.N    ??Subroutine18_0
   \   00000008   5F1A               SUBS     R7,R3,R1
   \                     ??Subroutine18_0:
   \   0000000A   FBB2               UXTB     R3,R7
   \   0000000C   7047               BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine17:
   \   00000000   A079               LDRB     R0,[R4, #+6]
   \   00000002   20F04000           BIC      R0,R0,#0x40
   \   00000006   A071               STRB     R0,[R4, #+6]
   \   00000008   7047               BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   0123               MOVS     R3,#+1
   \   00000002   A269               LDR      R2,[R4, #+24]
   \   00000004   04F12401           ADD      R1,R4,#+36
   \   00000008   2068               LDR      R0,[R4, #+0]
   \   0000000A   4078               LDRB     R0,[R0, #+1]
   \   0000000C   ........           B.W      disk_write

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine16:
   \   00000000   A188               LDRH     R1,[R4, #+4]
   \   00000002   2068               LDR      R0,[R4, #+0]
   \   00000004   ....               B.N      validate

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0123               MOVS     R3,#+1
   \   00000002   3246               MOV      R2,R6
   \   00000004   04F12401           ADD      R1,R4,#+36
   \   00000008   2068               LDR      R0,[R4, #+0]
   \   0000000A   4078               LDRB     R0,[R0, #+1]
   \   0000000C   ........           B.W      disk_read
   1849          
   1850          
   1851          
   1852          
   1853          #if !_FS_READONLY
   1854          /*-----------------------------------------------------------------------*/
   1855          /* Write File                                                            */
   1856          /*-----------------------------------------------------------------------*/
   1857          

   \                                 In section .text, align 2, keep-with-next
   1858          FRESULT f_write (
   1859          	FIL *fp,			/* Pointer to the file object */
   1860          	const void *buff,	/* Pointer to the data to be written */
   1861          	UINT btw,			/* Number of bytes to write */
   1862          	UINT *bw			/* Pointer to number of bytes written */
   1863          )
   1864          {
   \                     f_write:
   \   00000000   2DE9F843           PUSH     {R3-R9,LR}
   \   00000004   0546               MOV      R5,R0
   \   00000006   1646               MOV      R6,R2
   \   00000008   ........           BL       ?Subroutine19
   1865          	FRESULT res;
   1866          	DWORD clst, sect;
   1867          	UINT wcnt, cc;
   1868          	const BYTE *wbuff = buff;
   1869          
   1870          
   1871          	*bw = 0;	/* Initialize bytes written */
   1872          
   1873          	res = validate(fp->fs, fp->id);					/* Check validity of the object */
   \                     ??CrossCallReturnLabel_36:
   \   0000000C   A988               LDRH     R1,[R5, #+4]
   \   0000000E   2868               LDR      R0,[R5, #+0]
   \   00000010   ........           BL       validate
   1874          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   00000014   0100               MOVS     R1,R0
   \   00000016   09D1               BNE.N    ??f_write_0
   1875          	if (fp->flag & FA__ERROR)						/* Check abort flag */
   \   00000018   A879               LDRB     R0,[R5, #+6]
   \   0000001A   10F0800F           TST      R0,#0x80
   \   0000001E   01D0               BEQ.N    ??f_write_1
   1876          		LEAVE_FF(fp->fs, FR_INT_ERR);
   \                     ??f_write_2:
   \   00000020   0220               MOVS     R0,#+2
   \   00000022   03E0               B.N      ??f_write_0
   1877          	if (!(fp->flag & FA_WRITE))						/* Check access mode */
   \                     ??f_write_1:
   \   00000024   10F0020F           TST      R0,#0x2
   \   00000028   02D1               BNE.N    ??f_write_3
   1878          		LEAVE_FF(fp->fs, FR_DENIED);
   \   0000002A   0720               MOVS     R0,#+7
   \                     ??f_write_0:
   \   0000002C   BDE8F283           POP      {R1,R4-R9,PC}
   1879          	if (fp->fsize + btw < fp->fsize) btw = 0;		/* File size cannot reach 4GB */
   \                     ??f_write_3:
   \   00000030   E868               LDR      R0,[R5, #+12]
   \   00000032   3118               ADDS     R1,R6,R0
   \   00000034   8142               CMP      R1,R0
   \   00000036   3DD2               BCS.N    ??f_write_4
   1880          
   1881          	for ( ;  btw;									/* Repeat until all data transferred */
   1882          		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
   1883          		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
   1884          			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
   1885          				if (fp->fptr == 0) {				/* On the top of the file? */
   1886          					clst = fp->org_clust;			/* Follow from the origin */
   1887          					if (clst == 0)					/* When there is no cluster chain, */
   1888          						fp->org_clust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
   1889          				} else {							/* Middle or end of the file */
   1890          					clst = create_chain(fp->fs, fp->curr_clust);			/* Follow or streach cluster chain */
   1891          				}
   1892          				if (clst == 0) break;				/* Could not allocate a new cluster (disk full) */
   1893          				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   1894          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   1895          				fp->curr_clust = clst;				/* Update current cluster */
   1896          				fp->csect = 0;						/* Reset sector address in the cluster */
   1897          			}
   1898          #if _FS_TINY
   1899          			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write back data buffer prior to following direct transfer */
   1900          				ABORT(fp->fs, FR_DISK_ERR);
   1901          #else
   1902          			if (fp->flag & FA__DIRTY) {		/* Write back data buffer prior to following direct transfer */
   1903          				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
   1904          					ABORT(fp->fs, FR_DISK_ERR);
   1905          				fp->flag &= ~FA__DIRTY;
   1906          			}
   1907          #endif
   1908          			sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current sector */
   1909          			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   1910          			sect += fp->csect;
   1911          			cc = btw / SS(fp->fs);					/* When remaining bytes >= sector size, */
   1912          			if (cc) {								/* Write maximum contiguous sectors directly */
   1913          				if (fp->csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   1914          					cc = fp->fs->csize - fp->csect;
   1915          				if (disk_write(fp->fs->drive, wbuff, sect, (BYTE)cc) != RES_OK)
   1916          					ABORT(fp->fs, FR_DISK_ERR);
   1917          #if _FS_TINY
   1918          				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets dirty by the direct write */
   1919          					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
   1920          					fp->fs->wflag = 0;
   1921          				}
   1922          #else
   1923          				if (fp->dsect - sect < cc) {		/* Refill sector cache if it gets dirty by the direct write */
   1924          					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
   1925          					fp->flag &= ~FA__DIRTY;
   1926          				}
   1927          #endif
   1928          				fp->csect += (BYTE)cc;				/* Next sector address in the cluster */
   1929          				wcnt = SS(fp->fs) * cc;				/* Number of bytes transferred */
   1930          				continue;
   1931          			}
   1932          #if _FS_TINY
   1933          			if (fp->fptr >= fp->fsize) {			/* Avoid silly buffer filling at growing edge */
   1934          				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
   1935          				fp->fs->winsect = sect;
   1936          			}
   1937          #else
   1938          			if (fp->dsect != sect) {				/* Fill sector buffer with file data */
   1939          				if (fp->fptr < fp->fsize &&
   1940          					disk_read(fp->fs->drive, fp->buf, sect, 1) != RES_OK)
   1941          						ABORT(fp->fs, FR_DISK_ERR);
   1942          			}
   1943          #endif
   1944          			fp->dsect = sect;
   1945          			fp->csect++;							/* Next sector address in the cluster */
   1946          		}
   1947          		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Put partial sector into file I/O buffer */
   1948          		if (wcnt > btw) wcnt = btw;
   1949          #if _FS_TINY
   1950          		if (move_window(fp->fs, fp->dsect))			/* Move sector window */
   1951          			ABORT(fp->fs, FR_DISK_ERR);
   1952          		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   1953          		fp->fs->wflag = 1;
   1954          #else
   1955          		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   1956          		fp->flag |= FA__DIRTY;
   1957          #endif
   1958          	}
   1959          
   1960          	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
   \                     ??f_write_5:
   \   00000038   E868               LDR      R0,[R5, #+12]
   \   0000003A   A968               LDR      R1,[R5, #+8]
   \   0000003C   8842               CMP      R0,R1
   \   0000003E   00D2               BCS.N    ??f_write_6
   \   00000040   0846               MOV      R0,R1
   \                     ??f_write_6:
   \   00000042   E860               STR      R0,[R5, #+12]
   1961          	fp->flag |= FA__WRITTEN;						/* Set file changed flag */
   \   00000044   A879               LDRB     R0,[R5, #+6]
   \   00000046   40F02000           ORR      R0,R0,#0x20
   \   0000004A   A871               STRB     R0,[R5, #+6]
   1962          
   1963          	LEAVE_FF(fp->fs, FR_OK);
   \   0000004C   0020               MOVS     R0,#+0
   \   0000004E   EDE7               B.N      ??f_write_0
   \                     ??f_write_7:
   \   00000050   A869               LDR      R0,[R5, #+24]
   \   00000052   A042               CMP      R0,R4
   \   00000054   0DD0               BEQ.N    ??f_write_8
   \   00000056   A868               LDR      R0,[R5, #+8]
   \   00000058   E968               LDR      R1,[R5, #+12]
   \   0000005A   8842               CMP      R0,R1
   \   0000005C   09D2               BCS.N    ??f_write_8
   \   0000005E   0123               MOVS     R3,#+1
   \   00000060   2246               MOV      R2,R4
   \   00000062   05F12401           ADD      R1,R5,#+36
   \   00000066   2868               LDR      R0,[R5, #+0]
   \   00000068   4078               LDRB     R0,[R0, #+1]
   \   0000006A   ........           BL       disk_read
   \   0000006E   0028               CMP      R0,#+0
   \   00000070   44D1               BNE.N    ??f_write_9
   \                     ??f_write_8:
   \   00000072   AC61               STR      R4,[R5, #+24]
   \   00000074   E879               LDRB     R0,[R5, #+7]
   \   00000076   401C               ADDS     R0,R0,#+1
   \   00000078   E871               STRB     R0,[R5, #+7]
   \                     ??f_write_10:
   \   0000007A   A868               LDR      R0,[R5, #+8]
   \   0000007C   C005               LSLS     R0,R0,#+23
   \   0000007E   C00D               LSRS     R0,R0,#+23
   \   00000080   C0F50071           RSB      R1,R0,#+512
   \   00000084   3746               MOV      R7,R6
   \   00000086   8E42               CMP      R6,R1
   \   00000088   00D9               BLS.N    ??f_write_11
   \   0000008A   0F46               MOV      R7,R1
   \                     ??f_write_11:
   \   0000008C   3A46               MOV      R2,R7
   \   0000008E   4146               MOV      R1,R8
   \   00000090   4019               ADDS     R0,R0,R5
   \   00000092   2430               ADDS     R0,R0,#+36
   \   00000094   ........           BL       mem_cpy
   \   00000098   A879               LDRB     R0,[R5, #+6]
   \   0000009A   40F04000           ORR      R0,R0,#0x40
   \   0000009E   A871               STRB     R0,[R5, #+6]
   \                     ??f_write_12:
   \   000000A0   B844               ADD      R8,R7,R8
   \   000000A2   A868               LDR      R0,[R5, #+8]
   \   000000A4   3818               ADDS     R0,R7,R0
   \   000000A6   A860               STR      R0,[R5, #+8]
   \   000000A8   D9F80000           LDR      R0,[R9, #+0]
   \   000000AC   3818               ADDS     R0,R7,R0
   \   000000AE   C9F80000           STR      R0,[R9, #+0]
   \   000000B2   F61B               SUBS     R6,R6,R7
   \                     ??f_write_4:
   \   000000B4   002E               CMP      R6,#+0
   \   000000B6   BFD0               BEQ.N    ??f_write_5
   \   000000B8   A868               LDR      R0,[R5, #+8]
   \   000000BA   C105               LSLS     R1,R0,#+23
   \   000000BC   DDD1               BNE.N    ??f_write_10
   \   000000BE   2A68               LDR      R2,[R5, #+0]
   \   000000C0   E979               LDRB     R1,[R5, #+7]
   \   000000C2   9378               LDRB     R3,[R2, #+2]
   \   000000C4   9942               CMP      R1,R3
   \   000000C6   22D3               BCC.N    ??f_write_13
   \   000000C8   38B9               CBNZ     R0,??f_write_14
   \   000000CA   2869               LDR      R0,[R5, #+16]
   \   000000CC   48B9               CBNZ     R0,??f_write_15
   \   000000CE   0021               MOVS     R1,#+0
   \   000000D0   1046               MOV      R0,R2
   \   000000D2   ........           BL       create_chain
   \   000000D6   2861               STR      R0,[R5, #+16]
   \   000000D8   03E0               B.N      ??f_write_15
   \                     ??f_write_14:
   \   000000DA   6969               LDR      R1,[R5, #+20]
   \   000000DC   1046               MOV      R0,R2
   \   000000DE   ........           BL       create_chain
   \                     ??f_write_15:
   \   000000E2   0028               CMP      R0,#+0
   \   000000E4   A8D0               BEQ.N    ??f_write_5
   \   000000E6   0128               CMP      R0,#+1
   \   000000E8   04D1               BNE.N    ??f_write_16
   \                     ??f_write_17:
   \   000000EA   A879               LDRB     R0,[R5, #+6]
   \   000000EC   40F08000           ORR      R0,R0,#0x80
   \   000000F0   A871               STRB     R0,[R5, #+6]
   \   000000F2   95E7               B.N      ??f_write_2
   \                     ??f_write_16:
   \   000000F4   4FF0FF31           MOV      R1,#-1
   \   000000F8   8842               CMP      R0,R1
   \   000000FA   05D1               BNE.N    ??f_write_18
   \                     ??f_write_9:
   \   000000FC   A879               LDRB     R0,[R5, #+6]
   \   000000FE   40F08000           ORR      R0,R0,#0x80
   \   00000102   A871               STRB     R0,[R5, #+6]
   \   00000104   0120               MOVS     R0,#+1
   \   00000106   91E7               B.N      ??f_write_0
   \                     ??f_write_18:
   \   00000108   6861               STR      R0,[R5, #+20]
   \   0000010A   0020               MOVS     R0,#+0
   \   0000010C   E871               STRB     R0,[R5, #+7]
   \                     ??f_write_13:
   \   0000010E   A879               LDRB     R0,[R5, #+6]
   \   00000110   10F0400F           TST      R0,#0x40
   \   00000114   0DD0               BEQ.N    ??f_write_19
   \   00000116   0123               MOVS     R3,#+1
   \   00000118   AA69               LDR      R2,[R5, #+24]
   \   0000011A   05F12401           ADD      R1,R5,#+36
   \   0000011E   2868               LDR      R0,[R5, #+0]
   \   00000120   4078               LDRB     R0,[R0, #+1]
   \   00000122   ........           BL       disk_write
   \   00000126   0028               CMP      R0,#+0
   \   00000128   E8D1               BNE.N    ??f_write_9
   \   0000012A   A879               LDRB     R0,[R5, #+6]
   \   0000012C   20F04000           BIC      R0,R0,#0x40
   \   00000130   A871               STRB     R0,[R5, #+6]
   \                     ??f_write_19:
   \   00000132   6969               LDR      R1,[R5, #+20]
   \   00000134   2868               LDR      R0,[R5, #+0]
   \   00000136   ........           BL       clust2sect
   \   0000013A   0028               CMP      R0,#+0
   \   0000013C   D5D0               BEQ.N    ??f_write_17
   \   0000013E   E979               LDRB     R1,[R5, #+7]
   \   00000140   0C18               ADDS     R4,R1,R0
   \   00000142   770A               LSRS     R7,R6,#+9
   \   00000144   84D0               BEQ.N    ??f_write_7
   \   00000146   2868               LDR      R0,[R5, #+0]
   \   00000148   ........           BL       ?Subroutine18
   \                     ??CrossCallReturnLabel_34:
   \   0000014C   2246               MOV      R2,R4
   \   0000014E   4146               MOV      R1,R8
   \   00000150   4078               LDRB     R0,[R0, #+1]
   \   00000152   ........           BL       disk_write
   \   00000156   0028               CMP      R0,#+0
   \   00000158   D0D1               BNE.N    ??f_write_9
   \   0000015A   A869               LDR      R0,[R5, #+24]
   \   0000015C   001B               SUBS     R0,R0,R4
   \   0000015E   B842               CMP      R0,R7
   \   00000160   0BD2               BCS.N    ??f_write_20
   \   00000162   4FF40072           MOV      R2,#+512
   \   00000166   08EB4021           ADD      R1,R8,R0, LSL #+9
   \   0000016A   05F12400           ADD      R0,R5,#+36
   \   0000016E   ........           BL       mem_cpy
   \   00000172   A879               LDRB     R0,[R5, #+6]
   \   00000174   20F04000           BIC      R0,R0,#0x40
   \   00000178   A871               STRB     R0,[R5, #+6]
   \                     ??f_write_20:
   \   0000017A   E879               LDRB     R0,[R5, #+7]
   \   0000017C   3818               ADDS     R0,R7,R0
   \   0000017E   E871               STRB     R0,[R5, #+7]
   \   00000180   7F02               LSLS     R7,R7,#+9
   \   00000182   8DE7               B.N      ??f_write_12
   1964          }
   1965          
   1966          
   1967          
   1968          
   1969          /*-----------------------------------------------------------------------*/
   1970          /* Synchronize the File Object                                           */
   1971          /*-----------------------------------------------------------------------*/
   1972          

   \                                 In section .text, align 2, keep-with-next
   1973          FRESULT f_sync (
   1974          	FIL *fp		/* Pointer to the file object */
   1975          )
   1976          {
   \                     f_sync:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   ........           BL       ?Subroutine6
   1977          	FRESULT res;
   1978          	DWORD tim;
   1979          	BYTE *dir;
   1980          
   1981          
   1982          	res = validate(fp->fs, fp->id);		/* Check validity of the object */
   1983          	if (res == FR_OK) {
   \                     ??CrossCallReturnLabel_16:
   \   00000006   0100               MOVS     R1,R0
   \   00000008   45D1               BNE.N    ??f_sync_0
   1984          		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
   \   0000000A   A179               LDRB     R1,[R4, #+6]
   \   0000000C   11F0200F           TST      R1,#0x20
   \   00000010   41D0               BEQ.N    ??f_sync_0
   1985          #if !_FS_TINY	/* Write-back dirty buffer */
   1986          			if (fp->flag & FA__DIRTY) {
   \   00000012   11F0400F           TST      R1,#0x40
   \   00000016   07D0               BEQ.N    ??CrossCallReturnLabel_31
   1987          				if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
   \   00000018   ........           BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_7:
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   01D0               BEQ.N    ??f_sync_1
   1988          					LEAVE_FF(fp->fs, FR_DISK_ERR);
   \   00000020   0120               MOVS     R0,#+1
   \   00000022   32BD               POP      {R1,R4,R5,PC}
   1989          				fp->flag &= ~FA__DIRTY;
   \                     ??f_sync_1:
   \   00000024   ........           BL       ?Subroutine17
   1990          			}
   1991          #endif
   1992          			/* Update the directory entry */
   1993          			res = move_window(fp->fs, fp->dir_sect);
   \                     ??CrossCallReturnLabel_31:
   \   00000028   E169               LDR      R1,[R4, #+28]
   \   0000002A   ........           BL       ??Subroutine23_0
   1994          			if (res == FR_OK) {
   \                     ??CrossCallReturnLabel_47:
   \   0000002E   0100               MOVS     R1,R0
   \   00000030   31D1               BNE.N    ??f_sync_0
   1995          				dir = fp->dir_ptr;
   \   00000032   256A               LDR      R5,[R4, #+32]
   1996          				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
   \   00000034   E87A               LDRB     R0,[R5, #+11]
   \   00000036   40F02000           ORR      R0,R0,#0x20
   \   0000003A   E872               STRB     R0,[R5, #+11]
   1997          				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
   \   0000003C   E068               LDR      R0,[R4, #+12]
   \   0000003E   2877               STRB     R0,[R5, #+28]
   \   00000040   E068               LDR      R0,[R4, #+12]
   \   00000042   0004               LSLS     R0,R0,#+16
   \   00000044   000E               LSRS     R0,R0,#+24
   \   00000046   6877               STRB     R0,[R5, #+29]
   \   00000048   E068               LDR      R0,[R4, #+12]
   \   0000004A   000C               LSRS     R0,R0,#+16
   \   0000004C   A877               STRB     R0,[R5, #+30]
   \   0000004E   E068               LDR      R0,[R4, #+12]
   \   00000050   000E               LSRS     R0,R0,#+24
   \   00000052   E877               STRB     R0,[R5, #+31]
   1998          				ST_WORD(dir+DIR_FstClusLO, fp->org_clust);	/* Update start cluster */
   \   00000054   2069               LDR      R0,[R4, #+16]
   \   00000056   A876               STRB     R0,[R5, #+26]
   \   00000058   2069               LDR      R0,[R4, #+16]
   \   0000005A   0004               LSLS     R0,R0,#+16
   \   0000005C   000E               LSRS     R0,R0,#+24
   \   0000005E   E876               STRB     R0,[R5, #+27]
   1999          				ST_WORD(dir+DIR_FstClusHI, fp->org_clust >> 16);
   \   00000060   2069               LDR      R0,[R4, #+16]
   \   00000062   000C               LSRS     R0,R0,#+16
   \   00000064   2875               STRB     R0,[R5, #+20]
   \   00000066   2069               LDR      R0,[R4, #+16]
   \   00000068   000C               LSRS     R0,R0,#+16
   \   0000006A   000A               LSRS     R0,R0,#+8
   \   0000006C   6875               STRB     R0,[R5, #+21]
   2000          				tim = get_fattime();			/* Updated time */
   \   0000006E   ........           BL       get_fattime
   2001          				ST_DWORD(dir+DIR_WrtTime, tim);
   \   00000072   A875               STRB     R0,[R5, #+22]
   \   00000074   0104               LSLS     R1,R0,#+16
   \   00000076   090E               LSRS     R1,R1,#+24
   \   00000078   E975               STRB     R1,[R5, #+23]
   \   0000007A   010C               LSRS     R1,R0,#+16
   \   0000007C   2976               STRB     R1,[R5, #+24]
   \   0000007E   000E               LSRS     R0,R0,#+24
   \   00000080   6876               STRB     R0,[R5, #+25]
   2002          				fp->flag &= ~FA__WRITTEN;
   \   00000082   A079               LDRB     R0,[R4, #+6]
   \   00000084   20F02000           BIC      R0,R0,#0x20
   \   00000088   A071               STRB     R0,[R4, #+6]
   2003          				fp->fs->wflag = 1;
   \   0000008A   2068               LDR      R0,[R4, #+0]
   \   0000008C   0121               MOVS     R1,#+1
   \   0000008E   0171               STRB     R1,[R0, #+4]
   2004          				res = sync(fp->fs);
   \   00000090   2068               LDR      R0,[R4, #+0]
   \   00000092   ........           BL       sync
   2005          			}
   2006          		}
   2007          	}
   2008          
   2009          	LEAVE_FF(fp->fs, res);
   \                     ??f_sync_0:
   \   00000096   32BD               POP      {R1,R4,R5,PC}    ;; return
   2010          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6:
   \   00000000   0446               MOV      R4,R0
   \   00000002   A188               LDRH     R1,[R4, #+4]
   \   00000004   2068               LDR      R0,[R4, #+0]
   \   00000006   ........           B.W      validate
   2011          
   2012          #endif /* !_FS_READONLY */
   2013          
   2014          
   2015          
   2016          
   2017          /*-----------------------------------------------------------------------*/
   2018          /* Close File                                                            */
   2019          /*-----------------------------------------------------------------------*/
   2020          

   \                                 In section .text, align 2, keep-with-next
   2021          FRESULT f_close (
   2022          	FIL *fp		/* Pointer to the file object to be closed */
   2023          )
   2024          {
   \                     f_close:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0446               MOV      R4,R0
   2025          	FRESULT res;
   2026          
   2027          
   2028          #if _FS_READONLY
   2029          	res = validate(fp->fs, fp->id);
   2030          	if (res == FR_OK) fp->fs = NULL;
   2031          	LEAVE_FF(fp->fs, res);
   2032          #else
   2033          	res = f_sync(fp);
   \   00000004   ........           BL       f_sync
   2034          	if (res == FR_OK) fp->fs = NULL;
   \   00000008   0100               MOVS     R1,R0
   \   0000000A   01D1               BNE.N    ??f_close_0
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   2160               STR      R1,[R4, #+0]
   2035          	return res;
   \                     ??f_close_0:
   \   00000010   10BD               POP      {R4,PC}          ;; return
   2036          #endif
   2037          }
   2038          
   2039          
   2040          
   2041          
   2042          /*-----------------------------------------------------------------------*/
   2043          /* Change Current Drive/Directory                                        */
   2044          /*-----------------------------------------------------------------------*/
   2045          
   2046          #if _FS_RPATH
   2047          
   2048          FRESULT f_chdrive (
   2049          	BYTE drv		/* Drive number */
   2050          )
   2051          {
   2052          	if (drv >= _DRIVES) return FR_INVALID_DRIVE;
   2053          
   2054          	Drive = drv;
   2055          
   2056          	return FR_OK;
   2057          }
   2058          
   2059          
   2060          
   2061          
   2062          FRESULT f_chdir (
   2063          	const XCHAR *path	/* Pointer to the directory path */
   2064          )
   2065          {
   2066          	FRESULT res;
   2067          	DIR dj;
   2068          	NAMEBUF(sfn, lfn);
   2069          	BYTE *dir;
   2070          
   2071          
   2072          	res = chk_mounted(&path, &dj.fs, 0);
   2073          	if (res == FR_OK) {
   2074          		INITBUF(dj, sfn, lfn);
   2075          		res = follow_path(&dj, path);		/* Follow the file path */
   2076          		if (res == FR_OK) {					/* Follow completed */
   2077          			dir = dj.dir;					/* Pointer to the entry */
   2078          			if (!dir) {
   2079          				dj.fs->cdir = 0;			/* No entry (root dir) */
   2080          			} else {
   2081          				if (dir[DIR_Attr] & AM_DIR)	/* Reached to the dir */
   2082          					dj.fs->cdir = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
   2083          				else
   2084          					res = FR_NO_PATH;		/* Could not reach the dir (it is a file) */
   2085          			}
   2086          		}
   2087          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   2088          	}
   2089          
   2090          	LEAVE_FF(dj.fs, res);
   2091          }
   2092          
   2093          #endif
   2094          
   2095          
   2096          
   2097          #if _FS_MINIMIZE <= 2
   2098          /*-----------------------------------------------------------------------*/
   2099          /* Seek File R/W Pointer                                                 */
   2100          /*-----------------------------------------------------------------------*/
   2101          

   \                                 In section .text, align 2, keep-with-next
   2102          FRESULT f_lseek (
   2103          	FIL *fp,		/* Pointer to the file object */
   2104          	DWORD ofs		/* File pointer from top of file */
   2105          )
   2106          {
   \                     f_lseek:
   \   00000000   2DE9F041           PUSH     {R4-R8,LR}
   \   00000004   0446               MOV      R4,R0
   \   00000006   0F46               MOV      R7,R1
   2107          	FRESULT res;
   2108          	DWORD clst, bcs, nsect, ifptr;
   2109          
   2110          
   2111          	res = validate(fp->fs, fp->id);		/* Check validity of the object */
   \   00000008   ........           BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_28:
   \   0000000C   5FEA0008           MOVS     R8,R0
   2112          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   00000010   01D0               BEQ.N    ??f_lseek_0
   \                     ??f_lseek_1:
   \   00000012   4046               MOV      R0,R8
   \   00000014   04E0               B.N      ??f_lseek_2
   2113          	if (fp->flag & FA__ERROR)			/* Check abort flag */
   \                     ??f_lseek_0:
   \   00000016   A079               LDRB     R0,[R4, #+6]
   \   00000018   10F0800F           TST      R0,#0x80
   \   0000001C   02D0               BEQ.N    ??f_lseek_3
   2114          		LEAVE_FF(fp->fs, FR_INT_ERR);
   \                     ??f_lseek_4:
   \   0000001E   0220               MOVS     R0,#+2
   \                     ??f_lseek_2:
   \   00000020   BDE8F081           POP      {R4-R8,PC}
   2115          	if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
   2116          #if !_FS_READONLY
   2117          		 && !(fp->flag & FA_WRITE)
   2118          #endif
   2119          		) ofs = fp->fsize;
   \                     ??f_lseek_3:
   \   00000024   E168               LDR      R1,[R4, #+12]
   \   00000026   B942               CMP      R1,R7
   \   00000028   03D2               BCS.N    ??f_lseek_5
   \   0000002A   10F0020F           TST      R0,#0x2
   \   0000002E   00D1               BNE.N    ??f_lseek_5
   \   00000030   0F46               MOV      R7,R1
   2120          
   2121          	ifptr = fp->fptr;
   \                     ??f_lseek_5:
   \   00000032   A168               LDR      R1,[R4, #+8]
   2122          	fp->fptr = nsect = 0; fp->csect = 255;
   \   00000034   0026               MOVS     R6,#+0
   \   00000036   A660               STR      R6,[R4, #+8]
   \   00000038   FF20               MOVS     R0,#+255
   \   0000003A   E071               STRB     R0,[R4, #+7]
   2123          	if (ofs > 0) {
   \   0000003C   002F               CMP      R7,#+0
   \   0000003E   59D0               BEQ.N    ??f_lseek_6
   2124          		bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
   \   00000040   2068               LDR      R0,[R4, #+0]
   \   00000042   8278               LDRB     R2,[R0, #+2]
   \   00000044   5502               LSLS     R5,R2,#+9
   2125          		if (ifptr > 0 &&
   2126          			(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
   \   00000046   71B1               CBZ      R1,??f_lseek_7
   \   00000048   491E               SUBS     R1,R1,#+1
   \   0000004A   B1FBF5F2           UDIV     R2,R1,R5
   \   0000004E   7B1E               SUBS     R3,R7,#+1
   \   00000050   B3FBF5F3           UDIV     R3,R3,R5
   \   00000054   9342               CMP      R3,R2
   \   00000056   06D3               BCC.N    ??f_lseek_7
   2127          			fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
   \   00000058   681E               SUBS     R0,R5,#+1
   \   0000005A   C043               MVNS     R0,R0
   \   0000005C   0840               ANDS     R0,R0,R1
   \   0000005E   A060               STR      R0,[R4, #+8]
   2128          			ofs -= fp->fptr;
   \   00000060   3F1A               SUBS     R7,R7,R0
   2129          			clst = fp->curr_clust;
   \   00000062   6169               LDR      R1,[R4, #+20]
   \   00000064   17E0               B.N      ??f_lseek_8
   2130          		} else {									/* When seek to back cluster, */
   2131          			clst = fp->org_clust;					/* start from the first cluster */
   \                     ??f_lseek_7:
   \   00000066   2169               LDR      R1,[R4, #+16]
   2132          #if !_FS_READONLY
   2133          			if (clst == 0) {						/* If no cluster chain, create a new chain */
   \   00000068   A1B9               CBNZ     R1,??f_lseek_9
   2134          				clst = create_chain(fp->fs, 0);
   \   0000006A   ........           BL       create_chain
   \   0000006E   0146               MOV      R1,R0
   2135          				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   \   00000070   0129               CMP      R1,#+1
   \   00000072   04D1               BNE.N    ??f_lseek_10
   \                     ??f_lseek_11:
   \   00000074   A079               LDRB     R0,[R4, #+6]
   \   00000076   40F08000           ORR      R0,R0,#0x80
   \   0000007A   A071               STRB     R0,[R4, #+6]
   \   0000007C   CFE7               B.N      ??f_lseek_4
   2136          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \                     ??f_lseek_10:
   \   0000007E   4FF0FF30           MOV      R0,#-1
   \   00000082   8142               CMP      R1,R0
   \   00000084   05D1               BNE.N    ??f_lseek_12
   \                     ??f_lseek_13:
   \   00000086   A079               LDRB     R0,[R4, #+6]
   \   00000088   40F08000           ORR      R0,R0,#0x80
   \   0000008C   A071               STRB     R0,[R4, #+6]
   \   0000008E   0120               MOVS     R0,#+1
   \   00000090   C6E7               B.N      ??f_lseek_2
   2137          				fp->org_clust = clst;
   \                     ??f_lseek_12:
   \   00000092   2161               STR      R1,[R4, #+16]
   2138          			}
   2139          #endif
   2140          			fp->curr_clust = clst;
   \                     ??f_lseek_9:
   \   00000094   6161               STR      R1,[R4, #+20]
   2141          		}
   2142          		if (clst != 0) {
   \                     ??f_lseek_8:
   \   00000096   91B9               CBNZ     R1,??f_lseek_14
   \   00000098   2CE0               B.N      ??f_lseek_6
   2143          			while (ofs > bcs) {						/* Cluster following loop */
   2144          #if !_FS_READONLY
   2145          				if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
   2146          					clst = create_chain(fp->fs, clst);	/* Force streached if in write mode */
   2147          					if (clst == 0) {				/* When disk gets full, clip file size */
   2148          						ofs = bcs; break;
   2149          					}
   2150          				} else
   2151          #endif
   2152          					clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
   \                     ??f_lseek_15:
   \   0000009A   ........           BL       get_fat
   \   0000009E   0146               MOV      R1,R0
   2153          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \                     ??f_lseek_16:
   \   000000A0   4FF0FF30           MOV      R0,#-1
   \   000000A4   8142               CMP      R1,R0
   \   000000A6   EED0               BEQ.N    ??f_lseek_13
   2154          				if (clst <= 1 || clst >= fp->fs->max_clust) ABORT(fp->fs, FR_INT_ERR);
   \   000000A8   0229               CMP      R1,#+2
   \   000000AA   E3D3               BCC.N    ??f_lseek_11
   \   000000AC   2068               LDR      R0,[R4, #+0]
   \   000000AE   C069               LDR      R0,[R0, #+28]
   \   000000B0   8142               CMP      R1,R0
   \   000000B2   DFD2               BCS.N    ??f_lseek_11
   2155          				fp->curr_clust = clst;
   \   000000B4   6161               STR      R1,[R4, #+20]
   2156          				fp->fptr += bcs;
   \   000000B6   A068               LDR      R0,[R4, #+8]
   \   000000B8   2818               ADDS     R0,R5,R0
   \   000000BA   A060               STR      R0,[R4, #+8]
   2157          				ofs -= bcs;
   \   000000BC   7F1B               SUBS     R7,R7,R5
   \                     ??f_lseek_14:
   \   000000BE   BD42               CMP      R5,R7
   \   000000C0   09D2               BCS.N    ??f_lseek_17
   \   000000C2   2068               LDR      R0,[R4, #+0]
   \   000000C4   A279               LDRB     R2,[R4, #+6]
   \   000000C6   12F0020F           TST      R2,#0x2
   \   000000CA   E6D0               BEQ.N    ??f_lseek_15
   \   000000CC   ........           BL       create_chain
   \   000000D0   0100               MOVS     R1,R0
   \   000000D2   E5D1               BNE.N    ??f_lseek_16
   \   000000D4   2F46               MOV      R7,R5
   2158          			}
   2159          			fp->fptr += ofs;
   \                     ??f_lseek_17:
   \   000000D6   A068               LDR      R0,[R4, #+8]
   \   000000D8   3818               ADDS     R0,R7,R0
   \   000000DA   A060               STR      R0,[R4, #+8]
   2160          			fp->csect = (BYTE)(ofs / SS(fp->fs));	/* Sector offset in the cluster */
   \   000000DC   780A               LSRS     R0,R7,#+9
   \   000000DE   E071               STRB     R0,[R4, #+7]
   2161          			if (ofs % SS(fp->fs)) {
   \   000000E0   F805               LSLS     R0,R7,#+23
   \   000000E2   07D0               BEQ.N    ??f_lseek_6
   2162          				nsect = clust2sect(fp->fs, clst);	/* Current sector */
   \   000000E4   ........           BL       ??Subroutine24_0
   \                     ??CrossCallReturnLabel_56:
   \   000000E8   0600               MOVS     R6,R0
   2163          				if (!nsect) ABORT(fp->fs, FR_INT_ERR);
   \   000000EA   C3D0               BEQ.N    ??f_lseek_11
   2164          				nsect += fp->csect;
   \   000000EC   E079               LDRB     R0,[R4, #+7]
   \   000000EE   8619               ADDS     R6,R0,R6
   2165          				fp->csect++;
   \   000000F0   401C               ADDS     R0,R0,#+1
   \   000000F2   E071               STRB     R0,[R4, #+7]
   2166          			}
   2167          		}
   2168          	}
   2169          	if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {
   \                     ??f_lseek_6:
   \   000000F4   A068               LDR      R0,[R4, #+8]
   \   000000F6   C005               LSLS     R0,R0,#+23
   \   000000F8   16D0               BEQ.N    ??f_lseek_18
   \   000000FA   A269               LDR      R2,[R4, #+24]
   \   000000FC   9642               CMP      R6,R2
   \   000000FE   13D0               BEQ.N    ??f_lseek_18
   2170          #if !_FS_TINY
   2171          #if !_FS_READONLY
   2172          		if (fp->flag & FA__DIRTY) {			/* Write-back dirty buffer if needed */
   \   00000100   A079               LDRB     R0,[R4, #+6]
   \   00000102   10F0400F           TST      R0,#0x40
   \   00000106   0AD0               BEQ.N    ??CrossCallReturnLabel_32
   2173          			if (disk_write(fp->fs->drive, fp->buf, fp->dsect, 1) != RES_OK)
   \   00000108   0123               MOVS     R3,#+1
   \   0000010A   04F12401           ADD      R1,R4,#+36
   \   0000010E   2068               LDR      R0,[R4, #+0]
   \   00000110   4078               LDRB     R0,[R0, #+1]
   \   00000112   ........           BL       disk_write
   \   00000116   0028               CMP      R0,#+0
   \   00000118   B5D1               BNE.N    ??f_lseek_13
   2174          				ABORT(fp->fs, FR_DISK_ERR);
   2175          			fp->flag &= ~FA__DIRTY;
   \   0000011A   ........           BL       ?Subroutine17
   2176          		}
   2177          #endif
   2178          		if (disk_read(fp->fs->drive, fp->buf, nsect, 1) != RES_OK)
   \                     ??CrossCallReturnLabel_32:
   \   0000011E   ........           BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_5:
   \   00000122   0028               CMP      R0,#+0
   \   00000124   AFD1               BNE.N    ??f_lseek_13
   2179          			ABORT(fp->fs, FR_DISK_ERR);
   2180          #endif
   2181          		fp->dsect = nsect;
   \   00000126   A661               STR      R6,[R4, #+24]
   2182          	}
   2183          #if !_FS_READONLY
   2184          	if (fp->fptr > fp->fsize) {			/* Set changed flag if the file size is extended */
   \                     ??f_lseek_18:
   \   00000128   A068               LDR      R0,[R4, #+8]
   \   0000012A   E168               LDR      R1,[R4, #+12]
   \   0000012C   8142               CMP      R1,R0
   \   0000012E   04D2               BCS.N    ??f_lseek_19
   2185          		fp->fsize = fp->fptr;
   \   00000130   E060               STR      R0,[R4, #+12]
   2186          		fp->flag |= FA__WRITTEN;
   \   00000132   A079               LDRB     R0,[R4, #+6]
   \   00000134   40F02000           ORR      R0,R0,#0x20
   \   00000138   A071               STRB     R0,[R4, #+6]
   \                     ??f_lseek_19:
   \   0000013A   6AE7               B.N      ??f_lseek_1
   2187          	}
   2188          #endif
   2189          
   2190          	LEAVE_FF(fp->fs, res);
   2191          }
   2192          
   2193          
   2194          
   2195          
   2196          #if _FS_MINIMIZE <= 1
   2197          /*-----------------------------------------------------------------------*/
   2198          /* Create a Directroy Object                                             */
   2199          /*-----------------------------------------------------------------------*/
   2200          

   \                                 In section .text, align 2, keep-with-next
   2201          FRESULT f_opendir (
   2202          	DIR *dj,			/* Pointer to directory object to create */
   2203          	const XCHAR *path	/* Pointer to the directory path */
   2204          )
   2205          {
   \                     f_opendir:
   \   00000000   12B5               PUSH     {R1,R4,LR}
   \   00000002   83B0               SUB      SP,SP,#+12
   \   00000004   0446               MOV      R4,R0
   2206          	FRESULT res;
   2207          	NAMEBUF(sfn, lfn);
   2208          	BYTE *dir;
   2209          
   2210          
   2211          	res = chk_mounted(&path, &dj->fs, 0);
   \   00000006   0022               MOVS     R2,#+0
   \   00000008   2146               MOV      R1,R4
   \   0000000A   03A8               ADD      R0,SP,#+12
   \   0000000C   ........           BL       chk_mounted
   2212          	if (res == FR_OK) {
   \   00000010   0100               MOVS     R1,R0
   \   00000012   24D1               BNE.N    ??f_opendir_0
   2213          		INITBUF((*dj), sfn, lfn);
   \   00000014   ........           BL       ?Subroutine14
   2214          		res = follow_path(dj, path);			/* Follow the path to the directory */
   \                     ??CrossCallReturnLabel_23:
   \   00000018   0399               LDR      R1,[SP, #+12]
   \   0000001A   2046               MOV      R0,R4
   \   0000001C   ........           BL       follow_path
   2215          		if (res == FR_OK) {						/* Follow completed */
   \   00000020   0100               MOVS     R1,R0
   \   00000022   19D1               BNE.N    ??CrossCallReturnLabel_10
   2216          			dir = dj->dir;
   \   00000024   6169               LDR      R1,[R4, #+20]
   2217          			if (dir) {							/* It is not the root dir */
   \   00000026   81B1               CBZ      R1,??f_opendir_1
   2218          				if (dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
   \   00000028   CA7A               LDRB     R2,[R1, #+11]
   \   0000002A   12F0100F           TST      R2,#0x10
   \   0000002E   0BD0               BEQ.N    ??f_opendir_2
   2219          					dj->sclust = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
   \   00000030   4A7D               LDRB     R2,[R1, #+21]
   \   00000032   0B7D               LDRB     R3,[R1, #+20]
   \   00000034   43EA0222           ORR      R2,R3,R2, LSL #+8
   \   00000038   CB7E               LDRB     R3,[R1, #+27]
   \   0000003A   897E               LDRB     R1,[R1, #+26]
   \   0000003C   41EA0321           ORR      R1,R1,R3, LSL #+8
   \   00000040   41EA0241           ORR      R1,R1,R2, LSL #+16
   \   00000044   A160               STR      R1,[R4, #+8]
   \   00000046   00E0               B.N      ??f_opendir_1
   2220          				} else {						/* The object is not a directory */
   2221          					res = FR_NO_PATH;
   \                     ??f_opendir_2:
   \   00000048   0520               MOVS     R0,#+5
   2222          				}
   2223          			}
   2224          			if (res == FR_OK) {
   \                     ??f_opendir_1:
   \   0000004A   0100               MOVS     R1,R0
   \   0000004C   04D1               BNE.N    ??CrossCallReturnLabel_10
   2225          				dj->id = dj->fs->id;
   \   0000004E   2068               LDR      R0,[R4, #+0]
   \   00000050   C088               LDRH     R0,[R0, #+6]
   \   00000052   A080               STRH     R0,[R4, #+4]
   2226          				res = dir_seek(dj, 0);			/* Rewind dir */
   \   00000054   ........           BL       ?Subroutine3
   2227          			}
   2228          		}
   2229          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   \                     ??CrossCallReturnLabel_10:
   \   00000058   0428               CMP      R0,#+4
   \   0000005A   00D1               BNE.N    ??f_opendir_0
   \   0000005C   0520               MOVS     R0,#+5
   2230          	}
   2231          
   2232          	LEAVE_FF(dj->fs, res);
   \                     ??f_opendir_0:
   \   0000005E   04B0               ADD      SP,SP,#+16
   \   00000060   10BD               POP      {R4,PC}          ;; return
   2233          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?Subroutine14:
   \   00000000   00A8               ADD      R0,SP,#+0
   \   00000002   A061               STR      R0,[R4, #+24]
   \   00000004   0148               LDR.N    R0,??Subroutine14_0  ;; LfnBuf
   \   00000006   E061               STR      R0,[R4, #+28]
   \   00000008   7047               BX       LR
   \   0000000A   00BF               Nop      
   \                     ??Subroutine14_0:
   \   0000000C   ........           DC32     LfnBuf
   2234          
   2235          
   2236          
   2237          
   2238          /*-----------------------------------------------------------------------*/
   2239          /* Read Directory Entry in Sequense                                      */
   2240          /*-----------------------------------------------------------------------*/
   2241          

   \                                 In section .text, align 2, keep-with-next
   2242          FRESULT f_readdir (
   2243          	DIR *dj,			/* Pointer to the open directory object */
   2244          	FILINFO *fno		/* Pointer to file information to return */
   2245          )
   2246          {
   \                     f_readdir:
   \   00000000   3EB5               PUSH     {R1-R5,LR}
   \   00000002   0446               MOV      R4,R0
   \   00000004   0D46               MOV      R5,R1
   2247          	FRESULT res;
   2248          	NAMEBUF(sfn, lfn);
   2249          
   2250          
   2251          	res = validate(dj->fs, dj->id);			/* Check validity of the object */
   \   00000006   ........           BL       ?Subroutine16
   2252          	if (res == FR_OK) {
   \                     ??CrossCallReturnLabel_27:
   \   0000000A   0028               CMP      R0,#+0
   \   0000000C   19D1               BNE.N    ??f_readdir_0
   2253          		INITBUF((*dj), sfn, lfn);
   \   0000000E   ........           BL       ?Subroutine14
   2254          		if (!fno) {
   \                     ??CrossCallReturnLabel_24:
   \   00000012   15B9               CBNZ     R5,??f_readdir_1
   2255          			res = dir_seek(dj, 0);
   \   00000014   ........           BL       ?Subroutine3
   2256          		} else {
   \                     ??CrossCallReturnLabel_9:
   \   00000018   3EBD               POP      {R1-R5,PC}
   2257          			res = dir_read(dj);
   \                     ??f_readdir_1:
   \   0000001A   2046               MOV      R0,R4
   \   0000001C   ........           BL       dir_read
   2258          			if (res == FR_NO_FILE) {
   \   00000020   0428               CMP      R0,#+4
   \   00000022   02D1               BNE.N    ??f_readdir_2
   2259          				dj->sect = 0;
   \   00000024   0020               MOVS     R0,#+0
   \   00000026   2061               STR      R0,[R4, #+16]
   2260          				res = FR_OK;
   \   00000028   01E0               B.N      ??f_readdir_3
   2261          			}
   2262          			if (res == FR_OK) {				/* A valid entry is found */
   \                     ??f_readdir_2:
   \   0000002A   0028               CMP      R0,#+0
   \   0000002C   09D1               BNE.N    ??f_readdir_0
   2263          				get_fileinfo(dj, fno);		/* Get the object information */
   \                     ??f_readdir_3:
   \   0000002E   2946               MOV      R1,R5
   \   00000030   2046               MOV      R0,R4
   \   00000032   ........           BL       get_fileinfo
   2264          				res = dir_next(dj, False);	/* Increment index for next */
   \   00000036   ........           BL       ?Subroutine0
   2265          				if (res == FR_NO_FILE) {
   \                     ??CrossCallReturnLabel_0:
   \   0000003A   0428               CMP      R0,#+4
   \   0000003C   01D1               BNE.N    ??f_readdir_0
   2266          					dj->sect = 0;
   \   0000003E   0020               MOVS     R0,#+0
   \   00000040   2061               STR      R0,[R4, #+16]
   2267          					res = FR_OK;
   2268          				}
   2269          			}
   2270          		}
   2271          	}
   2272          
   2273          	LEAVE_FF(dj->fs, res);
   \                     ??f_readdir_0:
   \   00000042   3EBD               POP      {R1-R5,PC}       ;; return
   2274          }
   2275          
   2276          
   2277          
   2278          #if _FS_MINIMIZE == 0
   2279          /*-----------------------------------------------------------------------*/
   2280          /* Get File Status                                                       */
   2281          /*-----------------------------------------------------------------------*/
   2282          

   \                                 In section .text, align 2, keep-with-next
   2283          FRESULT f_stat (
   2284          	const XCHAR *path,	/* Pointer to the file path */
   2285          	FILINFO *fno		/* Pointer to file information to return */
   2286          )
   2287          {
   \                     f_stat:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   8CB0               SUB      SP,SP,#+48
   \   00000004   0C46               MOV      R4,R1
   2288          	FRESULT res;
   2289          	DIR dj;
   2290          	NAMEBUF(sfn, lfn);
   2291          
   2292          
   2293          	res = chk_mounted(&path, &dj.fs, 0);
   \   00000006   0022               MOVS     R2,#+0
   \   00000008   03A9               ADD      R1,SP,#+12
   \   0000000A   0CA8               ADD      R0,SP,#+48
   \   0000000C   ........           BL       chk_mounted
   \   00000010   0500               MOVS     R5,R0
   2294          	if (res == FR_OK) {
   \   00000012   0BD1               BNE.N    ??f_stat_0
   2295          		INITBUF(dj, sfn, lfn);
   \   00000014   ........           BL       ?Subroutine13
   2296          		res = follow_path(&dj, path);	/* Follow the file path */
   \                     ??CrossCallReturnLabel_22:
   \   00000018   0500               MOVS     R5,R0
   2297          		if (res == FR_OK) {				/* Follwo completed */
   \   0000001A   07D1               BNE.N    ??f_stat_0
   2298          			if (dj.dir)	/* Found an object */
   \   0000001C   0898               LDR      R0,[SP, #+32]
   \   0000001E   20B1               CBZ      R0,??f_stat_1
   2299          				get_fileinfo(&dj, fno);
   \   00000020   2146               MOV      R1,R4
   \   00000022   03A8               ADD      R0,SP,#+12
   \   00000024   ........           BL       get_fileinfo
   \   00000028   00E0               B.N      ??f_stat_0
   2300          			else		/* It is root dir */
   2301          				res = FR_INVALID_NAME;
   \                     ??f_stat_1:
   \   0000002A   0625               MOVS     R5,#+6
   2302          		}
   2303          	}
   2304          
   2305          	LEAVE_FF(dj.fs, res);
   \                     ??f_stat_0:
   \   0000002C   2846               MOV      R0,R5
   \   0000002E   0DB0               ADD      SP,SP,#+52
   \   00000030   30BD               POP      {R4,R5,PC}       ;; return
   2306          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?Subroutine13:
   \   00000000   00A8               ADD      R0,SP,#+0
   \   00000002   0990               STR      R0,[SP, #+36]
   \   00000004   0248               LDR.N    R0,??Subroutine13_0  ;; LfnBuf
   \   00000006   0A90               STR      R0,[SP, #+40]
   \   00000008   0C99               LDR      R1,[SP, #+48]
   \   0000000A   03A8               ADD      R0,SP,#+12
   \   0000000C   ........           B.W      follow_path
   \                     ??Subroutine13_0:
   \   00000010   ........           DC32     LfnBuf
   2307          
   2308          
   2309          
   2310          #if !_FS_READONLY
   2311          /*-----------------------------------------------------------------------*/
   2312          /* Get Number of Free Clusters                                           */
   2313          /*-----------------------------------------------------------------------*/
   2314          

   \                                 In section .text, align 2, keep-with-next
   2315          FRESULT f_getfree (
   2316          	const XCHAR *path,	/* Pointer to the logical drive number (root dir) */
   2317          	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
   2318          	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
   2319          )
   2320          {
   \                     f_getfree:
   \   00000000   2DE9F147           PUSH     {R0,R4-R10,LR}
   \   00000004   81B0               SUB      SP,SP,#+4
   \   00000006   8946               MOV      R9,R1
   \   00000008   1646               MOV      R6,R2
   2321          	FRESULT res;
   2322          	DWORD n, clst, sect, stat;
   2323          	UINT i;
   2324          	BYTE fat, *p;
   2325          
   2326          
   2327          	/* Get drive number */
   2328          	res = chk_mounted(&path, fatfs, 0);
   \   0000000A   0022               MOVS     R2,#+0
   \   0000000C   3146               MOV      R1,R6
   \   0000000E   01A8               ADD      R0,SP,#+4
   \   00000010   ........           BL       chk_mounted
   2329          	if (res != FR_OK) LEAVE_FF(*fatfs, res);
   \   00000014   0100               MOVS     R1,R0
   \   00000016   22D1               BNE.N    ??f_getfree_0
   2330          
   2331          	/* If number of free cluster is valid, return it without cluster scan. */
   2332          	if ((*fatfs)->free_clust <= (*fatfs)->max_clust - 2) {
   \   00000018   3068               LDR      R0,[R6, #+0]
   \   0000001A   C169               LDR      R1,[R0, #+28]
   \   0000001C   891E               SUBS     R1,R1,#+2
   \   0000001E   0269               LDR      R2,[R0, #+16]
   \   00000020   9142               CMP      R1,R2
   \   00000022   02D3               BCC.N    ??f_getfree_1
   2333          		*nclst = (*fatfs)->free_clust;
   \   00000024   C9F80020           STR      R2,[R9, #+0]
   2334          		LEAVE_FF(*fatfs, FR_OK);
   \   00000028   54E0               B.N      ??f_getfree_2
   2335          	}
   2336          
   2337          	/* Get number of free clusters */
   2338          	fat = (*fatfs)->fs_type;
   \                     ??f_getfree_1:
   \   0000002A   0778               LDRB     R7,[R0, #+0]
   2339          	n = 0;
   \   0000002C   0024               MOVS     R4,#+0
   2340          	if (fat == FS_FAT12) {
   \   0000002E   012F               CMP      R7,#+1
   \   00000030   17D1               BNE.N    ??f_getfree_3
   2341          		clst = 2;
   \   00000032   0225               MOVS     R5,#+2
   \   00000034   06E0               B.N      ??f_getfree_4
   2342          		do {
   2343          			stat = get_fat(*fatfs, clst);
   2344          			if (stat == 0xFFFFFFFF) LEAVE_FF(*fatfs, FR_DISK_ERR);
   2345          			if (stat == 1) LEAVE_FF(*fatfs, FR_INT_ERR);
   2346          			if (stat == 0) n++;
   \                     ??f_getfree_5:
   \   00000036   00B9               CBNZ     R0,??f_getfree_6
   \   00000038   641C               ADDS     R4,R4,#+1
   2347          		} while (++clst < (*fatfs)->max_clust);
   \                     ??f_getfree_6:
   \   0000003A   6D1C               ADDS     R5,R5,#+1
   \   0000003C   3068               LDR      R0,[R6, #+0]
   \   0000003E   C069               LDR      R0,[R0, #+28]
   \   00000040   8542               CMP      R5,R0
   \   00000042   3FD2               BCS.N    ??f_getfree_7
   \                     ??f_getfree_4:
   \   00000044   2946               MOV      R1,R5
   \   00000046   3068               LDR      R0,[R6, #+0]
   \   00000048   ........           BL       get_fat
   \   0000004C   4FF0FF31           MOV      R1,#-1
   \   00000050   8842               CMP      R0,R1
   \   00000052   01D1               BNE.N    ??f_getfree_8
   \   00000054   0120               MOVS     R0,#+1
   \   00000056   02E0               B.N      ??f_getfree_0
   \                     ??f_getfree_8:
   \   00000058   0128               CMP      R0,#+1
   \   0000005A   ECD1               BNE.N    ??f_getfree_5
   \   0000005C   0220               MOVS     R0,#+2
   \                     ??f_getfree_0:
   \   0000005E   BDE8F687           POP      {R1,R2,R4-R10,PC}
   2348          	} else {
   2349          		clst = (*fatfs)->max_clust;
   \                     ??f_getfree_3:
   \   00000062   C569               LDR      R5,[R0, #+28]
   2350          		sect = (*fatfs)->fatbase;
   \   00000064   D0F82080           LDR      R8,[R0, #+32]
   2351          		i = 0; p = 0;
   \   00000068   00E0               B.N      ??f_getfree_9
   2352          		do {
   2353          			if (!i) {
   \                     ??f_getfree_10:
   \   0000006A   59B9               CBNZ     R1,??f_getfree_11
   2354          				res = move_window(*fatfs, sect++);
   \                     ??f_getfree_9:
   \   0000006C   4146               MOV      R1,R8
   \   0000006E   3068               LDR      R0,[R6, #+0]
   \   00000070   ........           BL       move_window
   \   00000074   08F10108           ADD      R8,R8,#+1
   2355          				if (res != FR_OK)
   \   00000078   0100               MOVS     R1,R0
   \   0000007A   F0D1               BNE.N    ??f_getfree_0
   2356          					LEAVE_FF(*fatfs, res);
   2357          				p = (*fatfs)->win;
   \   0000007C   3068               LDR      R0,[R6, #+0]
   \   0000007E   3030               ADDS     R0,R0,#+48
   2358          				i = SS(*fatfs);
   \   00000080   4FF40071           MOV      R1,#+512
   2359          			}
   2360          			if (fat == FS_FAT16) {
   \                     ??f_getfree_11:
   \   00000084   4378               LDRB     R3,[R0, #+1]
   \   00000086   621C               ADDS     R2,R4,#+1
   \   00000088   90F800C0           LDRB     R12,[R0, #+0]
   \   0000008C   022F               CMP      R7,#+2
   \   0000008E   06D1               BNE.N    ??f_getfree_12
   2361          				if (LD_WORD(p) == 0) n++;
   \   00000090   5CEA0323           ORRS     R3,R12,R3, LSL #+8
   \   00000094   00D1               BNE.N    ??f_getfree_13
   \   00000096   1446               MOV      R4,R2
   2362          				p += 2; i -= 2;
   \                     ??f_getfree_13:
   \   00000098   801C               ADDS     R0,R0,#+2
   \   0000009A   891E               SUBS     R1,R1,#+2
   \   0000009C   10E0               B.N      ??f_getfree_14
   2363          			} else {
   2364          				if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
   \                     ??f_getfree_12:
   \   0000009E   90F803E0           LDRB     LR,[R0, #+3]
   \   000000A2   90F802A0           LDRB     R10,[R0, #+2]
   \   000000A6   4FEA0A4A           LSL      R10,R10,#+16
   \   000000AA   4AEA0E6E           ORR      LR,R10,LR, LSL #+24
   \   000000AE   4EEA0323           ORR      R3,LR,R3, LSL #+8
   \   000000B2   4CEA0303           ORR      R3,R12,R3
   \   000000B6   1B01               LSLS     R3,R3,#+4
   \   000000B8   00D1               BNE.N    ??f_getfree_15
   \   000000BA   1446               MOV      R4,R2
   2365          				p += 4; i -= 4;
   \                     ??f_getfree_15:
   \   000000BC   001D               ADDS     R0,R0,#+4
   \   000000BE   091F               SUBS     R1,R1,#+4
   2366          			}
   2367          		} while (--clst);
   \                     ??f_getfree_14:
   \   000000C0   6D1E               SUBS     R5,R5,#+1
   \   000000C2   D2D1               BNE.N    ??f_getfree_10
   2368          	}
   2369          	(*fatfs)->free_clust = n;
   \                     ??f_getfree_7:
   \   000000C4   3068               LDR      R0,[R6, #+0]
   \   000000C6   0461               STR      R4,[R0, #+16]
   2370          	if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
   \   000000C8   032F               CMP      R7,#+3
   \   000000CA   01D1               BNE.N    ??f_getfree_16
   \   000000CC   0121               MOVS     R1,#+1
   \   000000CE   4171               STRB     R1,[R0, #+5]
   2371          	*nclst = n;
   \                     ??f_getfree_16:
   \   000000D0   C9F80040           STR      R4,[R9, #+0]
   2372          
   2373          	LEAVE_FF(*fatfs, FR_OK);
   \                     ??f_getfree_2:
   \   000000D4   0020               MOVS     R0,#+0
   \                     ??f_getfree_17:
   \   000000D6   C2E7               B.N      ??f_getfree_0
   2374          }
   2375          
   2376          
   2377          
   2378          
   2379          /*-----------------------------------------------------------------------*/
   2380          /* Truncate File                                                         */
   2381          /*-----------------------------------------------------------------------*/
   2382          

   \                                 In section .text, align 2, keep-with-next
   2383          FRESULT f_truncate (
   2384          	FIL *fp		/* Pointer to the file object */
   2385          )
   2386          {
   \                     f_truncate:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   ........           BL       ?Subroutine6
   2387          	FRESULT res;
   2388          	DWORD ncl;
   2389          
   2390          
   2391          	res = validate(fp->fs, fp->id);		/* Check validity of the object */
   \                     ??CrossCallReturnLabel_15:
   \   00000006   0500               MOVS     R5,R0
   2392          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   00000008   01D0               BEQ.N    ??f_truncate_0
   \                     ??f_truncate_1:
   \   0000000A   2846               MOV      R0,R5
   \   0000000C   70BD               POP      {R4-R6,PC}       ;; return
   2393          	if (fp->flag & FA__ERROR)			/* Check abort flag */
   \                     ??f_truncate_0:
   \   0000000E   A079               LDRB     R0,[R4, #+6]
   \   00000010   10F0800F           TST      R0,#0x80
   \   00000014   01D0               BEQ.N    ??f_truncate_2
   2394          		LEAVE_FF(fp->fs, FR_INT_ERR);
   \   00000016   0220               MOVS     R0,#+2
   \   00000018   70BD               POP      {R4-R6,PC}
   2395          	if (!(fp->flag & FA_WRITE))			/* Check access mode */
   \                     ??f_truncate_2:
   \   0000001A   10F0020F           TST      R0,#0x2
   \   0000001E   01D1               BNE.N    ??f_truncate_3
   2396          		LEAVE_FF(fp->fs, FR_DENIED);
   \   00000020   0720               MOVS     R0,#+7
   \   00000022   70BD               POP      {R4-R6,PC}
   2397          
   2398          	if (fp->fsize > fp->fptr) {
   \                     ??f_truncate_3:
   \   00000024   A168               LDR      R1,[R4, #+8]
   \   00000026   E268               LDR      R2,[R4, #+12]
   \   00000028   9142               CMP      R1,R2
   \   0000002A   EED2               BCS.N    ??f_truncate_1
   2399          		fp->fsize = fp->fptr;	/* Set file size to current R/W point */
   \   0000002C   E160               STR      R1,[R4, #+12]
   2400          		fp->flag |= FA__WRITTEN;
   \   0000002E   40F02000           ORR      R0,R0,#0x20
   \   00000032   A071               STRB     R0,[R4, #+6]
   2401          		if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
   \   00000034   2068               LDR      R0,[R4, #+0]
   \   00000036   31B9               CBNZ     R1,??f_truncate_4
   2402          			res = remove_chain(fp->fs, fp->org_clust);
   \   00000038   2169               LDR      R1,[R4, #+16]
   \   0000003A   ........           BL       remove_chain
   \   0000003E   0546               MOV      R5,R0
   2403          			fp->org_clust = 0;
   \   00000040   0020               MOVS     R0,#+0
   \   00000042   2061               STR      R0,[R4, #+16]
   \   00000044   1DE0               B.N      ??f_truncate_5
   2404          		} else {				/* When truncate a part of the file, remove remaining clusters */
   2405          			ncl = get_fat(fp->fs, fp->curr_clust);
   \                     ??f_truncate_4:
   \   00000046   6169               LDR      R1,[R4, #+20]
   \   00000048   ........           BL       get_fat
   \   0000004C   0646               MOV      R6,R0
   2406          			res = FR_OK;
   2407          			if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
   \   0000004E   4FF0FF30           MOV      R0,#-1
   \   00000052   8642               CMP      R6,R0
   \   00000054   01D1               BNE.N    ??f_truncate_6
   \   00000056   0125               MOVS     R5,#+1
   \   00000058   15E0               B.N      ??f_truncate_7
   2408          			if (ncl == 1) res = FR_INT_ERR;
   \                     ??f_truncate_6:
   \   0000005A   012E               CMP      R6,#+1
   \   0000005C   01D1               BNE.N    ??f_truncate_8
   \   0000005E   0225               MOVS     R5,#+2
   \   00000060   11E0               B.N      ??f_truncate_7
   \                     ??f_truncate_8:
   \   00000062   2068               LDR      R0,[R4, #+0]
   \   00000064   C169               LDR      R1,[R0, #+28]
   \   00000066   8E42               CMP      R6,R1
   \   00000068   CFD2               BCS.N    ??f_truncate_1
   2409          			if (res == FR_OK && ncl < fp->fs->max_clust) {
   2410          				res = put_fat(fp->fs, fp->curr_clust, 0x0FFFFFFF);
   \   0000006A   6FF07042           MVN      R2,#-268435456
   \   0000006E   6169               LDR      R1,[R4, #+20]
   \   00000070   ........           BL       put_fat
   \   00000074   0500               MOVS     R5,R0
   2411          				if (res == FR_OK) res = remove_chain(fp->fs, ncl);
   \   00000076   04D1               BNE.N    ??f_truncate_5
   \   00000078   3146               MOV      R1,R6
   \   0000007A   2068               LDR      R0,[R4, #+0]
   \   0000007C   ........           BL       remove_chain
   \   00000080   0546               MOV      R5,R0
   2412          			}
   2413          		}
   2414          	}
   2415          	if (res != FR_OK) fp->flag |= FA__ERROR;
   \                     ??f_truncate_5:
   \   00000082   002D               CMP      R5,#+0
   \   00000084   C1D0               BEQ.N    ??f_truncate_1
   \                     ??f_truncate_7:
   \   00000086   A079               LDRB     R0,[R4, #+6]
   \   00000088   40F08000           ORR      R0,R0,#0x80
   \   0000008C   A071               STRB     R0,[R4, #+6]
   \   0000008E   BCE7               B.N      ??f_truncate_1
   2416          
   2417          	LEAVE_FF(fp->fs, res);
   2418          }
   2419          
   2420          
   2421          
   2422          
   2423          /*-----------------------------------------------------------------------*/
   2424          /* Delete a File or Directory                                            */
   2425          /*-----------------------------------------------------------------------*/
   2426          

   \                                 In section .text, align 2, keep-with-next
   2427          FRESULT f_unlink (
   2428          	const XCHAR *path		/* Pointer to the file or directory path */
   2429          )
   2430          {
   \                     f_unlink:
   \   00000000   11B5               PUSH     {R0,R4,LR}
   \   00000002   95B0               SUB      SP,SP,#+84
   2431          	FRESULT res;
   2432          	DIR dj, sdj;
   2433          	NAMEBUF(sfn, lfn);
   2434          	BYTE *dir;
   2435          	DWORD dclst;
   2436          
   2437          
   2438          	res = chk_mounted(&path, &dj.fs, 1);
   \   00000004   0122               MOVS     R2,#+1
   \   00000006   00A9               ADD      R1,SP,#+0
   \   00000008   15A8               ADD      R0,SP,#+84
   \   0000000A   ........           BL       chk_mounted
   2439          	if (res != FR_OK) LEAVE_FF(dj.fs, res);
   \   0000000E   0100               MOVS     R1,R0
   \   00000010   0BD1               BNE.N    ??f_unlink_0
   2440          
   2441          	INITBUF(dj, sfn, lfn);
   \                     ??f_unlink_1:
   \   00000012   ........           BL       ?Subroutine15
   2442          	res = follow_path(&dj, path);			/* Follow the file path */
   \                     ??CrossCallReturnLabel_26:
   \   00000016   1599               LDR      R1,[SP, #+84]
   \   00000018   00A8               ADD      R0,SP,#+0
   \   0000001A   ........           BL       follow_path
   2443          	if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   2444          		res = FR_INVALID_NAME;
   2445          	if (res != FR_OK) LEAVE_FF(dj.fs, res); /* Follow failed */
   \   0000001E   0100               MOVS     R1,R0
   \   00000020   03D1               BNE.N    ??f_unlink_0
   2446          
   2447          	dir = dj.dir;
   \   00000022   0598               LDR      R0,[SP, #+20]
   2448          	if (!dir)								/* Is it the root directory? */
   \   00000024   0028               CMP      R0,#+0
   \   00000026   02D1               BNE.N    ??f_unlink_2
   2449          		LEAVE_FF(dj.fs, FR_INVALID_NAME);
   \   00000028   0620               MOVS     R0,#+6
   \                     ??f_unlink_0:
   \   0000002A   16B0               ADD      SP,SP,#+88
   \   0000002C   10BD               POP      {R4,PC}
   2450          	if (dir[DIR_Attr] & AM_RDO)				/* Is it a R/O object? */
   \                     ??f_unlink_2:
   \   0000002E   C17A               LDRB     R1,[R0, #+11]
   \   00000030   11F0010F           TST      R1,#0x1
   \   00000034   01D0               BEQ.N    ??f_unlink_3
   2451          		LEAVE_FF(dj.fs, FR_DENIED);
   \                     ??f_unlink_4:
   \   00000036   0720               MOVS     R0,#+7
   \   00000038   F7E7               B.N      ??f_unlink_0
   2452          	dclst = ((DWORD)LD_WORD(dir+DIR_FstClusHI) << 16) | LD_WORD(dir+DIR_FstClusLO);
   \                     ??f_unlink_3:
   \   0000003A   427D               LDRB     R2,[R0, #+21]
   \   0000003C   037D               LDRB     R3,[R0, #+20]
   \   0000003E   43EA0222           ORR      R2,R3,R2, LSL #+8
   \   00000042   C37E               LDRB     R3,[R0, #+27]
   \   00000044   807E               LDRB     R0,[R0, #+26]
   \   00000046   40EA0320           ORR      R0,R0,R3, LSL #+8
   \   0000004A   40EA0244           ORR      R4,R0,R2, LSL #+16
   2453          
   2454          	if (dir[DIR_Attr] & AM_DIR) {			/* It is a sub-directory */
   \   0000004E   11F0100F           TST      R1,#0x10
   \   00000052   16D0               BEQ.N    ??f_unlink_5
   2455          		if (dclst < 2) LEAVE_FF(dj.fs, FR_INT_ERR);
   \   00000054   022C               CMP      R4,#+2
   \   00000056   01D2               BCS.N    ??f_unlink_6
   \   00000058   0220               MOVS     R0,#+2
   \   0000005A   E6E7               B.N      ??f_unlink_0
   2456          		mem_cpy(&sdj, &dj, sizeof(DIR));	/* Check if the sub-dir is empty or not */
   \                     ??f_unlink_6:
   \   0000005C   2422               MOVS     R2,#+36
   \   0000005E   00A9               ADD      R1,SP,#+0
   \   00000060   0CA8               ADD      R0,SP,#+48
   \   00000062   ........           BL       mem_cpy
   2457          		sdj.sclust = dclst;
   \   00000066   0E94               STR      R4,[SP, #+56]
   2458          		res = dir_seek(&sdj, 2);
   \   00000068   0221               MOVS     R1,#+2
   \   0000006A   0CA8               ADD      R0,SP,#+48
   \   0000006C   ........           BL       dir_seek
   2459          		if (res != FR_OK) LEAVE_FF(dj.fs, res);
   \   00000070   0100               MOVS     R1,R0
   \   00000072   DAD1               BNE.N    ??f_unlink_0
   2460          		res = dir_read(&sdj);
   \   00000074   0CA8               ADD      R0,SP,#+48
   \   00000076   ........           BL       dir_read
   2461          		if (res == FR_OK) res = FR_DENIED;	/* Not empty sub-dir */
   \   0000007A   0100               MOVS     R1,R0
   \   0000007C   DBD0               BEQ.N    ??f_unlink_4
   2462          		if (res != FR_NO_FILE) LEAVE_FF(dj.fs, res);
   \   0000007E   0428               CMP      R0,#+4
   \   00000080   D3D1               BNE.N    ??f_unlink_0
   2463          	}
   2464          
   2465          	res = dir_remove(&dj);					/* Remove directory entry */
   \                     ??f_unlink_5:
   \   00000082   00A8               ADD      R0,SP,#+0
   \   00000084   ........           BL       dir_remove
   2466          	if (res == FR_OK) {
   \   00000088   0100               MOVS     R1,R0
   \   0000008A   CED1               BNE.N    ??f_unlink_0
   2467          		if (dclst)
   \   0000008C   002C               CMP      R4,#+0
   \   0000008E   03D0               BEQ.N    ??f_unlink_7
   2468          			res = remove_chain(dj.fs, dclst);	/* Remove the cluster chain */
   \   00000090   2146               MOV      R1,R4
   \   00000092   0098               LDR      R0,[SP, #+0]
   \   00000094   ........           BL       remove_chain
   2469          		if (res == FR_OK) res = sync(dj.fs);
   \                     ??f_unlink_7:
   \   00000098   0100               MOVS     R1,R0
   \   0000009A   C6D1               BNE.N    ??f_unlink_0
   \   0000009C   0098               LDR      R0,[SP, #+0]
   \   0000009E   ........           BL       sync
   \   000000A2   C2E7               B.N      ??f_unlink_0
   2470          	}
   2471          
   2472          	LEAVE_FF(dj.fs, res);
   2473          }
   2474          
   2475          
   2476          
   2477          
   2478          /*-----------------------------------------------------------------------*/
   2479          /* Create a Directory                                                    */
   2480          /*-----------------------------------------------------------------------*/
   2481          

   \                                 In section .text, align 4, keep-with-next
   2482          FRESULT f_mkdir (
   2483          	const XCHAR *path		/* Pointer to the directory path */
   2484          )
   2485          {
   \                     f_mkdir:
   \   00000000   2DE9F14F           PUSH     {R0,R4-R11,LR}
   \   00000004   8EB0               SUB      SP,SP,#+56
   2486          	FRESULT res;
   2487          	DIR dj;
   2488          	NAMEBUF(sfn, lfn);
   2489          	BYTE *dir, n;
   2490          	DWORD dsect, dclst, pclst, tim;
   2491          
   2492          
   2493          	res = chk_mounted(&path, &dj.fs, 1);
   \   00000006   0122               MOVS     R2,#+1
   \   00000008   01A9               ADD      R1,SP,#+4
   \   0000000A   0EA8               ADD      R0,SP,#+56
   \   0000000C   ........           BL       chk_mounted
   \   00000010   0746               MOV      R7,R0
   2494          	if (res != FR_OK) LEAVE_FF(dj.fs, res);
   \   00000012   18B1               CBZ      R0,??f_mkdir_0
   \                     ??f_mkdir_1:
   \   00000014   3846               MOV      R0,R7
   \   00000016   0FB0               ADD      SP,SP,#+60
   \   00000018   BDE8F08F           POP      {R4-R11,PC}      ;; return
   2495          
   2496          	INITBUF(dj, sfn, lfn);
   \                     ??f_mkdir_0:
   \   0000001C   0AA8               ADD      R0,SP,#+40
   \   0000001E   0790               STR      R0,[SP, #+28]
   \   00000020   5448               LDR.N    R0,??f_mkdir_2   ;; LfnBuf
   \   00000022   0890               STR      R0,[SP, #+32]
   2497          	res = follow_path(&dj, path);			/* Follow the file path */
   \   00000024   0E99               LDR      R1,[SP, #+56]
   \   00000026   01A8               ADD      R0,SP,#+4
   \   00000028   ........           BL       follow_path
   \   0000002C   0746               MOV      R7,R0
   2498          	if (res == FR_OK) res = FR_EXIST;		/* Any file or directory is already existing */
   \   0000002E   08B9               CBNZ     R0,??f_mkdir_3
   \   00000030   0827               MOVS     R7,#+8
   \   00000032   EFE7               B.N      ??f_mkdir_1
   2499          	if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
   2500          		res = FR_INVALID_NAME;
   2501          	if (res != FR_NO_FILE)					/* Any error occured */
   \                     ??f_mkdir_3:
   \   00000034   0428               CMP      R0,#+4
   \   00000036   EDD1               BNE.N    ??f_mkdir_1
   2502          		LEAVE_FF(dj.fs, res);
   2503          
   2504          	dclst = create_chain(dj.fs, 0);			/* Allocate a new cluster for new directory table */
   \   00000038   0021               MOVS     R1,#+0
   \   0000003A   0198               LDR      R0,[SP, #+4]
   \   0000003C   ........           BL       create_chain
   \   00000040   0400               MOVS     R4,R0
   2505          	res = FR_OK;
   2506          	if (dclst == 0) res = FR_DENIED;
   \   00000042   53D1               BNE.N    ??f_mkdir_4
   \   00000044   0727               MOVS     R7,#+7
   2507          	if (dclst == 1) res = FR_INT_ERR;
   2508          	if (dclst == 0xFFFFFFFF) res = FR_DISK_ERR;
   2509          	if (res == FR_OK)
   \                     ??f_mkdir_5:
   \   00000046   002F               CMP      R7,#+0
   \   00000048   04D1               BNE.N    ??f_mkdir_6
   2510          		res = move_window(dj.fs, 0);
   \                     ??f_mkdir_7:
   \   0000004A   0021               MOVS     R1,#+0
   \   0000004C   0198               LDR      R0,[SP, #+4]
   \   0000004E   ........           BL       move_window
   \   00000052   0746               MOV      R7,R0
   2511          	if (res != FR_OK) LEAVE_FF(dj.fs, res);
   \                     ??f_mkdir_6:
   \   00000054   002F               CMP      R7,#+0
   \   00000056   DDD1               BNE.N    ??f_mkdir_1
   2512          	dsect = clust2sect(dj.fs, dclst);
   \   00000058   2146               MOV      R1,R4
   \   0000005A   0198               LDR      R0,[SP, #+4]
   \   0000005C   ........           BL       clust2sect
   \   00000060   8046               MOV      R8,R0
   2513          
   2514          	dir = dj.fs->win;						/* Initialize the new directory table */
   \   00000062   0198               LDR      R0,[SP, #+4]
   \   00000064   00F13005           ADD      R5,R0,#+48
   2515          	mem_set(dir, 0, SS(dj.fs));
   \   00000068   ........           BL       ?Subroutine5
   2516          	mem_set(dir+DIR_Name, ' ', 8+3);		/* Create "." entry */
   \                     ??CrossCallReturnLabel_62:
   \   0000006C   0B22               MOVS     R2,#+11
   \   0000006E   2021               MOVS     R1,#+32
   \   00000070   2846               MOV      R0,R5
   \   00000072   ........           BL       mem_set
   2517          	dir[DIR_Name] = '.';
   \   00000076   2E20               MOVS     R0,#+46
   \   00000078   2870               STRB     R0,[R5, #+0]
   2518          	dir[DIR_Attr] = AM_DIR;
   \   0000007A   1020               MOVS     R0,#+16
   \   0000007C   E872               STRB     R0,[R5, #+11]
   2519          	tim = get_fattime();
   \   0000007E   ........           BL       get_fattime
   \   00000082   0646               MOV      R6,R0
   2520          	ST_DWORD(dir+DIR_WrtTime, tim);
   \   00000084   AE75               STRB     R6,[R5, #+22]
   \   00000086   0004               LSLS     R0,R0,#+16
   \   00000088   000E               LSRS     R0,R0,#+24
   \   0000008A   8DF80100           STRB     R0,[SP, #+1]
   \   0000008E   ........           BL       ?Subroutine20
   2521          	ST_WORD(dir+DIR_FstClusLO, dclst);
   \                     ??CrossCallReturnLabel_37:
   \   00000092   2004               LSLS     R0,R4,#+16
   \   00000094   000E               LSRS     R0,R0,#+24
   \   00000096   8DF80000           STRB     R0,[SP, #+0]
   \   0000009A   E876               STRB     R0,[R5, #+27]
   2522          	ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
   \   0000009C   4FEA144A           LSR      R10,R4,#+16
   \   000000A0   85F814A0           STRB     R10,[R5, #+20]
   \   000000A4   4FEA1A2B           LSR      R11,R10,#+8
   \   000000A8   85F815B0           STRB     R11,[R5, #+21]
   2523          	mem_cpy(dir+32, dir, 32); 			/* Create ".." entry */
   \   000000AC   2022               MOVS     R2,#+32
   \   000000AE   2946               MOV      R1,R5
   \   000000B0   05F12000           ADD      R0,R5,#+32
   \   000000B4   ........           BL       mem_cpy
   2524          	dir[33] = '.';
   \   000000B8   2E20               MOVS     R0,#+46
   \   000000BA   85F82100           STRB     R0,[R5, #+33]
   2525          	pclst = dj.sclust;
   \   000000BE   0398               LDR      R0,[SP, #+12]
   2526          	if (dj.fs->fs_type == FS_FAT32 && pclst == dj.fs->dirbase)
   \   000000C0   0199               LDR      R1,[SP, #+4]
   \   000000C2   0978               LDRB     R1,[R1, #+0]
   \   000000C4   0329               CMP      R1,#+3
   \   000000C6   04D1               BNE.N    ??f_mkdir_8
   \   000000C8   0199               LDR      R1,[SP, #+4]
   \   000000CA   496A               LDR      R1,[R1, #+36]
   \   000000CC   8842               CMP      R0,R1
   \   000000CE   00D1               BNE.N    ??f_mkdir_8
   2527          		pclst = 0;
   \   000000D0   0020               MOVS     R0,#+0
   2528          	ST_WORD(dir+32+DIR_FstClusLO, pclst);
   \                     ??f_mkdir_8:
   \   000000D2   05F12101           ADD      R1,R5,#+33
   \   000000D6   4876               STRB     R0,[R1, #+25]
   \   000000D8   0204               LSLS     R2,R0,#+16
   \   000000DA   120E               LSRS     R2,R2,#+24
   \   000000DC   8A76               STRB     R2,[R1, #+26]
   2529          	ST_WORD(dir+32+DIR_FstClusHI, pclst >> 16);
   \   000000DE   000C               LSRS     R0,R0,#+16
   \   000000E0   C874               STRB     R0,[R1, #+19]
   \   000000E2   000A               LSRS     R0,R0,#+8
   \   000000E4   0875               STRB     R0,[R1, #+20]
   2530          	for (n = 0; n < dj.fs->csize; n++) {	/* Write dot entries and clear left sectors */
   \   000000E6   4FF00009           MOV      R9,#+0
   \   000000EA   1EE0               B.N      ??f_mkdir_9
   \                     ??f_mkdir_4:
   \   000000EC   012C               CMP      R4,#+1
   \   000000EE   01D1               BNE.N    ??f_mkdir_10
   \   000000F0   0227               MOVS     R7,#+2
   \   000000F2   A8E7               B.N      ??f_mkdir_5
   \                     ??f_mkdir_10:
   \   000000F4   4FF0FF30           MOV      R0,#-1
   \   000000F8   8442               CMP      R4,R0
   \   000000FA   A6D1               BNE.N    ??f_mkdir_7
   \   000000FC   0127               MOVS     R7,#+1
   \                     ??f_mkdir_11:
   \   000000FE   89E7               B.N      ??f_mkdir_1
   2531          		dj.fs->winsect = dsect++;
   \                     ??f_mkdir_12:
   \   00000100   0198               LDR      R0,[SP, #+4]
   \   00000102   C0F82C80           STR      R8,[R0, #+44]
   \   00000106   08F10108           ADD      R8,R8,#+1
   2532          		dj.fs->wflag = 1;
   \   0000010A   0198               LDR      R0,[SP, #+4]
   \   0000010C   0121               MOVS     R1,#+1
   \   0000010E   0171               STRB     R1,[R0, #+4]
   2533          		res = move_window(dj.fs, 0);
   \   00000110   0021               MOVS     R1,#+0
   \   00000112   0198               LDR      R0,[SP, #+4]
   \   00000114   ........           BL       move_window
   \   00000118   0746               MOV      R7,R0
   2534          		if (res) LEAVE_FF(dj.fs, res);
   \   0000011A   0028               CMP      R0,#+0
   \   0000011C   EFD1               BNE.N    ??f_mkdir_11
   2535          		mem_set(dir, 0, SS(dj.fs));
   \   0000011E   ........           BL       ?Subroutine5
   2536          	}
   \                     ??CrossCallReturnLabel_61:
   \   00000122   09F10100           ADD      R0,R9,#+1
   \   00000126   5FFA80F9           UXTB     R9,R0
   \                     ??f_mkdir_9:
   \   0000012A   0199               LDR      R1,[SP, #+4]
   \   0000012C   8978               LDRB     R1,[R1, #+2]
   \   0000012E   8945               CMP      R9,R1
   \   00000130   E6D3               BCC.N    ??f_mkdir_12
   2537          
   2538          	res = dir_register(&dj);
   \   00000132   01A8               ADD      R0,SP,#+4
   \   00000134   ........           BL       dir_register
   \   00000138   0746               MOV      R7,R0
   2539          	if (res != FR_OK) {
   \   0000013A   20B1               CBZ      R0,??f_mkdir_13
   2540          		remove_chain(dj.fs, dclst);
   \   0000013C   2146               MOV      R1,R4
   \   0000013E   0198               LDR      R0,[SP, #+4]
   \   00000140   ........           BL       remove_chain
   \   00000144   66E7               B.N      ??f_mkdir_1
   2541          	} else {
   2542          		dir = dj.dir;
   \                     ??f_mkdir_13:
   \   00000146   069D               LDR      R5,[SP, #+24]
   2543          		dir[DIR_Attr] = AM_DIR;					/* Attribute */
   \   00000148   1020               MOVS     R0,#+16
   \   0000014A   E872               STRB     R0,[R5, #+11]
   2544          		ST_DWORD(dir+DIR_WrtTime, tim);			/* Crated time */
   \   0000014C   AE75               STRB     R6,[R5, #+22]
   \   0000014E   9DF80100           LDRB     R0,[SP, #+1]
   \   00000152   ........           BL       ?Subroutine20
   2545          		ST_WORD(dir+DIR_FstClusLO, dclst);		/* Table start cluster */
   \                     ??CrossCallReturnLabel_38:
   \   00000156   9DF80000           LDRB     R0,[SP, #+0]
   \   0000015A   E876               STRB     R0,[R5, #+27]
   2546          		ST_WORD(dir+DIR_FstClusHI, dclst >> 16);
   \   0000015C   85F814A0           STRB     R10,[R5, #+20]
   \   00000160   85F815B0           STRB     R11,[R5, #+21]
   2547          		dj.fs->wflag = 1;
   \   00000164   0198               LDR      R0,[SP, #+4]
   \   00000166   0121               MOVS     R1,#+1
   \   00000168   0171               STRB     R1,[R0, #+4]
   2548          		res = sync(dj.fs);
   \   0000016A   0198               LDR      R0,[SP, #+4]
   \   0000016C   ........           BL       sync
   \   00000170   0746               MOV      R7,R0
   \   00000172   4FE7               B.N      ??f_mkdir_1
   \                     ??f_mkdir_2:
   \   00000174   ........           DC32     LfnBuf
   2549          	}
   2550          
   2551          	LEAVE_FF(dj.fs, res);
   2552          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine20:
   \   00000000   E875               STRB     R0,[R5, #+23]
   \   00000002   300C               LSRS     R0,R6,#+16
   \   00000004   2876               STRB     R0,[R5, #+24]
   \   00000006   300E               LSRS     R0,R6,#+24
   \   00000008   6876               STRB     R0,[R5, #+25]
   \   0000000A   AC76               STRB     R4,[R5, #+26]
   \   0000000C   7047               BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ?Subroutine5:
   \   00000000   4FF40072           MOV      R2,#+512
   \   00000004                      REQUIRE ??Subroutine25_0
   \   00000004                      ;; // Fall through to label ??Subroutine25_0
   2553          
   2554          
   2555          
   2556          
   2557          /*-----------------------------------------------------------------------*/
   2558          /* Change File Attribute                                                 */
   2559          /*-----------------------------------------------------------------------*/
   2560          

   \                                 In section .text, align 2, keep-with-next
   2561          FRESULT f_chmod (
   2562          	const XCHAR *path,	/* Pointer to the file path */
   2563          	BYTE value,			/* Attribute bits */
   2564          	BYTE mask			/* Attribute mask to change */
   2565          )
   2566          {
   \                     f_chmod:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   8CB0               SUB      SP,SP,#+48
   \   00000004   0C46               MOV      R4,R1
   \   00000006   1546               MOV      R5,R2
   2567          	FRESULT res;
   2568          	DIR dj;
   2569          	NAMEBUF(sfn, lfn);
   2570          	BYTE *dir;
   2571          
   2572          
   2573          	res = chk_mounted(&path, &dj.fs, 1);
   \   00000008   0122               MOVS     R2,#+1
   \   0000000A   03A9               ADD      R1,SP,#+12
   \   0000000C   0CA8               ADD      R0,SP,#+48
   \   0000000E   ........           BL       chk_mounted
   2574          	if (res == FR_OK) {
   \   00000012   0028               CMP      R0,#+0
   \   00000014   13D1               BNE.N    ??CrossCallReturnLabel_20
   2575          		INITBUF(dj, sfn, lfn);
   \   00000016   ........           BL       ?Subroutine13
   2576          		res = follow_path(&dj, path);		/* Follow the file path */
   2577          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   2578          			res = FR_INVALID_NAME;
   2579          		if (res == FR_OK) {
   \                     ??CrossCallReturnLabel_21:
   \   0000001A   0028               CMP      R0,#+0
   \   0000001C   0FD1               BNE.N    ??CrossCallReturnLabel_20
   2580          			dir = dj.dir;
   \   0000001E   0898               LDR      R0,[SP, #+32]
   2581          			if (!dir) {						/* Is it a root directory? */
   \   00000020   0028               CMP      R0,#+0
   \   00000022   01D1               BNE.N    ??f_chmod_0
   2582          				res = FR_INVALID_NAME;
   \   00000024   0620               MOVS     R0,#+6
   \   00000026   0AE0               B.N      ??CrossCallReturnLabel_20
   2583          			} else {						/* File or sub directory */
   2584          				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
   \                     ??f_chmod_0:
   \   00000028   05F02705           AND      R5,R5,#0x27
   2585          				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
   \   0000002C   05EA0401           AND      R1,R5,R4
   \   00000030   C27A               LDRB     R2,[R0, #+11]
   \   00000032   EB43               MVNS     R3,R5
   \   00000034   1A40               ANDS     R2,R3,R2
   \   00000036   1143               ORRS     R1,R2,R1
   \   00000038   C172               STRB     R1,[R0, #+11]
   2586          				dj.fs->wflag = 1;
   \   0000003A   ........           BL       ?Subroutine12
   2587          				res = sync(dj.fs);
   2588          			}
   2589          		}
   2590          	}
   2591          
   2592          	LEAVE_FF(dj.fs, res);
   \                     ??CrossCallReturnLabel_20:
   \   0000003E   0DB0               ADD      SP,SP,#+52
   \   00000040   30BD               POP      {R4,R5,PC}       ;; return
   2593          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12:
   \   00000000   0398               LDR      R0,[SP, #+12]
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   0171               STRB     R1,[R0, #+4]
   \   00000006   0398               LDR      R0,[SP, #+12]
   \   00000008   ........           B.W      sync
   2594          
   2595          
   2596          
   2597          
   2598          /*-----------------------------------------------------------------------*/
   2599          /* Change Timestamp                                                      */
   2600          /*-----------------------------------------------------------------------*/
   2601          

   \                                 In section .text, align 4, keep-with-next
   2602          FRESULT f_utime (
   2603          	const XCHAR *path,	/* Pointer to the file/directory name */
   2604          	const FILINFO *fno	/* Pointer to the timestamp to be set */
   2605          )
   2606          {
   \                     f_utime:
   \   00000000   11B5               PUSH     {R0,R4,LR}
   \   00000002   8DB0               SUB      SP,SP,#+52
   \   00000004   0C46               MOV      R4,R1
   2607          	FRESULT res;
   2608          	DIR dj;
   2609          	NAMEBUF(sfn, lfn);
   2610          	BYTE *dir;
   2611          
   2612          
   2613          	res = chk_mounted(&path, &dj.fs, 1);
   \   00000006   0122               MOVS     R2,#+1
   \   00000008   03A9               ADD      R1,SP,#+12
   \   0000000A   0DA8               ADD      R0,SP,#+52
   \   0000000C   ........           BL       chk_mounted
   2614          	if (res == FR_OK) {
   \   00000010   0028               CMP      R0,#+0
   \   00000012   1AD1               BNE.N    ??CrossCallReturnLabel_19
   2615          		INITBUF(dj, sfn, lfn);
   \   00000014   00A8               ADD      R0,SP,#+0
   \   00000016   0990               STR      R0,[SP, #+36]
   \   00000018   0D48               LDR.N    R0,??f_utime_0   ;; LfnBuf
   \   0000001A   0A90               STR      R0,[SP, #+40]
   2616          		res = follow_path(&dj, path);	/* Follow the file path */
   \   0000001C   0D99               LDR      R1,[SP, #+52]
   \   0000001E   03A8               ADD      R0,SP,#+12
   \   00000020   ........           BL       follow_path
   2617          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   2618          			res = FR_INVALID_NAME;
   2619          		if (res == FR_OK) {
   \   00000024   0028               CMP      R0,#+0
   \   00000026   10D1               BNE.N    ??CrossCallReturnLabel_19
   2620          			dir = dj.dir;
   \   00000028   0898               LDR      R0,[SP, #+32]
   2621          			if (!dir) {				/* Root directory */
   \   0000002A   0028               CMP      R0,#+0
   \   0000002C   01D1               BNE.N    ??f_utime_1
   2622          				res = FR_INVALID_NAME;
   \   0000002E   0620               MOVS     R0,#+6
   \   00000030   0BE0               B.N      ??CrossCallReturnLabel_19
   2623          			} else {				/* File or sub-directory */
   2624          				ST_WORD(dir+DIR_WrtTime, fno->ftime);
   \                     ??f_utime_1:
   \   00000032   E188               LDRH     R1,[R4, #+6]
   \   00000034   8175               STRB     R1,[R0, #+22]
   \   00000036   E188               LDRH     R1,[R4, #+6]
   \   00000038   090A               LSRS     R1,R1,#+8
   \   0000003A   C175               STRB     R1,[R0, #+23]
   2625          				ST_WORD(dir+DIR_WrtDate, fno->fdate);
   \   0000003C   A188               LDRH     R1,[R4, #+4]
   \   0000003E   0176               STRB     R1,[R0, #+24]
   \   00000040   A188               LDRH     R1,[R4, #+4]
   \   00000042   090A               LSRS     R1,R1,#+8
   \   00000044   4176               STRB     R1,[R0, #+25]
   2626          				dj.fs->wflag = 1;
   \   00000046   ........           BL       ?Subroutine12
   2627          				res = sync(dj.fs);
   2628          			}
   2629          		}
   2630          	}
   2631          
   2632          	LEAVE_FF(dj.fs, res);
   \                     ??CrossCallReturnLabel_19:
   \   0000004A   0EB0               ADD      SP,SP,#+56
   \   0000004C   10BD               POP      {R4,PC}          ;; return
   \   0000004E   00BF               Nop      
   \                     ??f_utime_0:
   \   00000050   ........           DC32     LfnBuf
   2633          }
   2634          
   2635          
   2636          
   2637          
   2638          /*-----------------------------------------------------------------------*/
   2639          /* Rename File/Directory                                                 */
   2640          /*-----------------------------------------------------------------------*/
   2641          

   \                                 In section .text, align 4, keep-with-next
   2642          FRESULT f_rename (
   2643          	const XCHAR *path_old,	/* Pointer to the old name */
   2644          	const XCHAR *path_new	/* Pointer to the new name */
   2645          )
   2646          {
   \                     f_rename:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   9CB0               SUB      SP,SP,#+112
   \   00000004   0C46               MOV      R4,R1
   2647          	FRESULT res;
   2648          	DIR dj_old, dj_new;
   2649          	NAMEBUF(sfn, lfn);
   2650          	BYTE buf[21], *dir;
   2651          	DWORD dw;
   2652          
   2653          
   2654          	INITBUF(dj_old, sfn, lfn);
   \   00000006   18A8               ADD      R0,SP,#+96
   \   00000008   0F90               STR      R0,[SP, #+60]
   \   0000000A   4348               LDR.N    R0,??f_rename_0  ;; LfnBuf
   \   0000000C   1090               STR      R0,[SP, #+64]
   2655          	res = chk_mounted(&path_old, &dj_old.fs, 1);
   \   0000000E   0122               MOVS     R2,#+1
   \   00000010   09A9               ADD      R1,SP,#+36
   \   00000012   1CA8               ADD      R0,SP,#+112
   \   00000014   ........           BL       chk_mounted
   \   00000018   0500               MOVS     R5,R0
   2656          	if (res == FR_OK) {
   \   0000001A   06D1               BNE.N    ??f_rename_1
   2657          		dj_new.fs = dj_old.fs;
   \   0000001C   0998               LDR      R0,[SP, #+36]
   \   0000001E   0090               STR      R0,[SP, #+0]
   2658          		res = follow_path(&dj_old, path_old);	/* Check old object */
   \   00000020   1C99               LDR      R1,[SP, #+112]
   \   00000022   09A8               ADD      R0,SP,#+36
   \   00000024   ........           BL       follow_path
   \   00000028   0546               MOV      R5,R0
   2659          		if (_FS_RPATH && res == FR_OK && (dj_old.fn[NS] & NS_DOT))
   2660          			res = FR_INVALID_NAME;
   2661          	}
   2662          	if (res != FR_OK) LEAVE_FF(dj_old.fs, res);	/* The old object is not found */
   \                     ??f_rename_1:
   \   0000002A   2800               MOVS     R0,R5
   \   0000002C   01D0               BEQ.N    ??f_rename_2
   \                     ??f_rename_3:
   \   0000002E   2846               MOV      R0,R5
   \   00000030   03E0               B.N      ??f_rename_4
   2663          
   2664          	if (!dj_old.dir) LEAVE_FF(dj_old.fs, FR_NO_FILE);	/* Is root dir? */
   \                     ??f_rename_2:
   \   00000032   0E98               LDR      R0,[SP, #+56]
   \   00000034   0028               CMP      R0,#+0
   \   00000036   02D1               BNE.N    ??f_rename_5
   \   00000038   0420               MOVS     R0,#+4
   \                     ??f_rename_4:
   \   0000003A   1DB0               ADD      SP,SP,#+116
   \   0000003C   30BD               POP      {R4,R5,PC}
   2665          	mem_cpy(buf, dj_old.dir+DIR_Attr, 21);		/* Save the object information */
   \                     ??f_rename_5:
   \   0000003E   1522               MOVS     R2,#+21
   \   00000040   00F10B01           ADD      R1,R0,#+11
   \   00000044   12A8               ADD      R0,SP,#+72
   \   00000046   ........           BL       mem_cpy
   2666          
   2667          	mem_cpy(&dj_new, &dj_old, sizeof(DIR));
   \   0000004A   2422               MOVS     R2,#+36
   \   0000004C   09A9               ADD      R1,SP,#+36
   \   0000004E   00A8               ADD      R0,SP,#+0
   \   00000050   ........           BL       mem_cpy
   2668          	res = follow_path(&dj_new, path_new);		/* Check new object */
   \   00000054   2146               MOV      R1,R4
   \   00000056   00A8               ADD      R0,SP,#+0
   \   00000058   ........           BL       follow_path
   \   0000005C   0500               MOVS     R5,R0
   2669          	if (res == FR_OK) res = FR_EXIST;			/* The new object name is already existing */
   \   0000005E   01D1               BNE.N    ??f_rename_6
   \   00000060   0825               MOVS     R5,#+8
   \   00000062   E4E7               B.N      ??f_rename_3
   2670          	if (res == FR_NO_FILE) { 					/* Is it a valid path and no name collision? */
   \                     ??f_rename_6:
   \   00000064   0428               CMP      R0,#+4
   \   00000066   E2D1               BNE.N    ??f_rename_3
   2671          		res = dir_register(&dj_new);			/* Register the new object */
   \   00000068   00A8               ADD      R0,SP,#+0
   \   0000006A   ........           BL       dir_register
   \   0000006E   0500               MOVS     R5,R0
   2672          		if (res == FR_OK) {
   \   00000070   DDD1               BNE.N    ??f_rename_3
   2673          			dir = dj_new.dir;					/* Copy object information into new entry */
   \   00000072   059C               LDR      R4,[SP, #+20]
   2674          			mem_cpy(dir+13, buf+2, 19);
   \   00000074   1322               MOVS     R2,#+19
   \   00000076   0DF14A01           ADD      R1,SP,#+74
   \   0000007A   04F10D00           ADD      R0,R4,#+13
   \   0000007E   ........           BL       mem_cpy
   2675          			dir[DIR_Attr] = buf[0] | AM_ARC;
   \   00000082   9DF84800           LDRB     R0,[SP, #+72]
   \   00000086   40F02000           ORR      R0,R0,#0x20
   \   0000008A   E072               STRB     R0,[R4, #+11]
   2676          			dj_old.fs->wflag = 1;
   \   0000008C   0998               LDR      R0,[SP, #+36]
   \   0000008E   0121               MOVS     R1,#+1
   \   00000090   0171               STRB     R1,[R0, #+4]
   2677          			if (dir[DIR_Attr] & AM_DIR) {		/* Update .. entry in the directory if needed */
   \   00000092   E07A               LDRB     R0,[R4, #+11]
   \   00000094   10F0100F           TST      R0,#0x10
   \   00000098   31D0               BEQ.N    ??f_rename_7
   2678          				dw = clust2sect(dj_new.fs, (DWORD)LD_WORD(dir+DIR_FstClusHI) | LD_WORD(dir+DIR_FstClusLO));
   \   0000009A   607D               LDRB     R0,[R4, #+21]
   \   0000009C   217D               LDRB     R1,[R4, #+20]
   \   0000009E   41EA0020           ORR      R0,R1,R0, LSL #+8
   \   000000A2   E17E               LDRB     R1,[R4, #+27]
   \   000000A4   A27E               LDRB     R2,[R4, #+26]
   \   000000A6   42EA0121           ORR      R1,R2,R1, LSL #+8
   \   000000AA   0143               ORRS     R1,R1,R0
   \   000000AC   0098               LDR      R0,[SP, #+0]
   \   000000AE   ........           BL       clust2sect
   2679          				if (!dw) {
   \   000000B2   0028               CMP      R0,#+0
   \   000000B4   01D1               BNE.N    ??f_rename_8
   2680          					res = FR_INT_ERR;
   \   000000B6   0225               MOVS     R5,#+2
   \   000000B8   21E0               B.N      ??f_rename_7
   2681          				} else {
   2682          					res = move_window(dj_new.fs, dw);
   \                     ??f_rename_8:
   \   000000BA   0146               MOV      R1,R0
   \   000000BC   0098               LDR      R0,[SP, #+0]
   \   000000BE   ........           BL       move_window
   \   000000C2   0546               MOV      R5,R0
   2683          					dir = dj_new.fs->win+32;
   \   000000C4   0098               LDR      R0,[SP, #+0]
   \   000000C6   00F15004           ADD      R4,R0,#+80
   2684          					if (res == FR_OK && dir[1] == '.') {
   \   000000CA   2800               MOVS     R0,R5
   \   000000CC   17D1               BNE.N    ??f_rename_7
   \   000000CE   6078               LDRB     R0,[R4, #+1]
   \   000000D0   2E28               CMP      R0,#+46
   \   000000D2   14D1               BNE.N    ??f_rename_7
   2685          						dw = (dj_new.fs->fs_type == FS_FAT32 && dj_new.sclust == dj_new.fs->dirbase) ? 0 : dj_new.sclust;
   \   000000D4   0298               LDR      R0,[SP, #+8]
   \   000000D6   0099               LDR      R1,[SP, #+0]
   \   000000D8   0978               LDRB     R1,[R1, #+0]
   \   000000DA   0329               CMP      R1,#+3
   \   000000DC   04D1               BNE.N    ??f_rename_9
   \   000000DE   0099               LDR      R1,[SP, #+0]
   \   000000E0   496A               LDR      R1,[R1, #+36]
   \   000000E2   8842               CMP      R0,R1
   \   000000E4   00D1               BNE.N    ??f_rename_9
   \   000000E6   0020               MOVS     R0,#+0
   2686          						ST_WORD(dir+DIR_FstClusLO, dw);
   \                     ??f_rename_9:
   \   000000E8   A076               STRB     R0,[R4, #+26]
   \   000000EA   0104               LSLS     R1,R0,#+16
   \   000000EC   090E               LSRS     R1,R1,#+24
   \   000000EE   E176               STRB     R1,[R4, #+27]
   2687          						ST_WORD(dir+DIR_FstClusHI, dw >> 16);
   \   000000F0   000C               LSRS     R0,R0,#+16
   \   000000F2   2075               STRB     R0,[R4, #+20]
   \   000000F4   000A               LSRS     R0,R0,#+8
   \   000000F6   6075               STRB     R0,[R4, #+21]
   2688          						dj_new.fs->wflag = 1;
   \   000000F8   0098               LDR      R0,[SP, #+0]
   \   000000FA   0121               MOVS     R1,#+1
   \   000000FC   0171               STRB     R1,[R0, #+4]
   2689          					}
   2690          				}
   2691          			}
   2692          			if (res == FR_OK) {
   \                     ??f_rename_7:
   \   000000FE   2800               MOVS     R0,R5
   \   00000100   95D1               BNE.N    ??f_rename_3
   2693          				res = dir_remove(&dj_old);			/* Remove old entry */
   \   00000102   09A8               ADD      R0,SP,#+36
   \   00000104   ........           BL       dir_remove
   \   00000108   0500               MOVS     R5,R0
   2694          				if (res == FR_OK)
   \   0000010A   90D1               BNE.N    ??f_rename_3
   2695          					res = sync(dj_old.fs);
   \   0000010C   0998               LDR      R0,[SP, #+36]
   \   0000010E   ........           BL       sync
   \   00000112   0546               MOV      R5,R0
   \   00000114   8BE7               B.N      ??f_rename_3
   \   00000116   00BF               Nop      
   \                     ??f_rename_0:
   \   00000118   ........           DC32     LfnBuf
   2696          			}
   2697          		}
   2698          	}
   2699          
   2700          	LEAVE_FF(dj_old.fs, res);
   2701          }
   2702          
   2703          #endif /* !_FS_READONLY */
   2704          #endif /* _FS_MINIMIZE == 0 */
   2705          #endif /* _FS_MINIMIZE <= 1 */
   2706          #endif /* _FS_MINIMIZE <= 2 */
   2707          
   2708          
   2709          
   2710          /*-----------------------------------------------------------------------*/
   2711          /* Forward data to the stream directly (Available on only _FS_TINY cfg)  */
   2712          /*-----------------------------------------------------------------------*/
   2713          #if _USE_FORWARD && _FS_TINY
   2714          
   2715          FRESULT f_forward (
   2716          	FIL *fp, 						/* Pointer to the file object */
   2717          	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
   2718          	UINT btr,						/* Number of bytes to forward */
   2719          	UINT *bf						/* Pointer to number of bytes forwarded */
   2720          )
   2721          {
   2722          	FRESULT res;
   2723          	DWORD remain, clst, sect;
   2724          	UINT rcnt;
   2725          
   2726          
   2727          	*bf = 0;
   2728          
   2729          	res = validate(fp->fs, fp->id);					/* Check validity of the object */
   2730          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   2731          	if (fp->flag & FA__ERROR)						/* Check error flag */
   2732          		LEAVE_FF(fp->fs, FR_INT_ERR);
   2733          	if (!(fp->flag & FA_READ))						/* Check access mode */
   2734          		LEAVE_FF(fp->fs, FR_DENIED);
   2735          
   2736          	remain = fp->fsize - fp->fptr;
   2737          	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
   2738          
   2739          	for ( ;  btr && (*func)(NULL, 0);				/* Repeat until all data transferred or stream becomes busy */
   2740          		fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
   2741          		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
   2742          			if (fp->csect >= fp->fs->csize) {		/* On the cluster boundary? */
   2743          				clst = (fp->fptr == 0) ?			/* On the top of the file? */
   2744          					fp->org_clust : get_fat(fp->fs, fp->curr_clust);
   2745          				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
   2746          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2747          				fp->curr_clust = clst;				/* Update current cluster */
   2748          				fp->csect = 0;						/* Reset sector address in the cluster */
   2749          			}
   2750          			fp->csect++;							/* Next sector address in the cluster */
   2751          		}
   2752          		sect = clust2sect(fp->fs, fp->curr_clust);	/* Get current data sector */
   2753          		if (!sect) ABORT(fp->fs, FR_INT_ERR);
   2754          		sect += fp->csect - 1;
   2755          		if (move_window(fp->fs, sect))				/* Move sector window */
   2756          			ABORT(fp->fs, FR_DISK_ERR);
   2757          		fp->dsect = sect;
   2758          		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
   2759          		if (rcnt > btr) rcnt = btr;
   2760          		rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
   2761          		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
   2762          	}
   2763          
   2764          	LEAVE_FF(fp->fs, FR_OK);
   2765          }
   2766          #endif /* _USE_FORWARD */
   2767          
   2768          
   2769          
   2770          #if _USE_MKFS && !_FS_READONLY
   2771          /*-----------------------------------------------------------------------*/
   2772          /* Create File System on the Drive                                       */
   2773          /*-----------------------------------------------------------------------*/
   2774          #define N_ROOTDIR	512			/* Multiple of 32 and <= 2048 */
   2775          #define N_FATS		1			/* 1 or 2 */
   2776          #define MAX_SECTOR	131072000UL	/* Maximum partition size */
   2777          #define MIN_SECTOR	2000UL		/* Minimum partition size */
   2778          
   2779          
   2780          FRESULT f_mkfs (
   2781          	BYTE drv,			/* Logical drive number */
   2782          	BYTE partition,		/* Partitioning rule 0:FDISK, 1:SFD */
   2783          	WORD allocsize		/* Allocation unit size [bytes] */
   2784          )
   2785          {
   2786          	static const DWORD sstbl[] = { 2048000, 1024000, 512000, 256000, 128000, 64000, 32000, 16000, 8000, 4000,   0 };
   2787          	static const WORD cstbl[] =  {   32768,   16384,   8192,   4096,   2048, 16384,  8192,  4096, 2048, 1024, 512 };
   2788          	BYTE fmt, m, *tbl;
   2789          	DWORD b_part, b_fat, b_dir, b_data;		/* Area offset (LBA) */
   2790          	DWORD n_part, n_rsv, n_fat, n_dir;		/* Area size */
   2791          	DWORD n_clst, d, n;
   2792          	WORD as;
   2793          	FATFS *fs;
   2794          	DSTATUS stat;
   2795          
   2796          
   2797          	/* Check validity of the parameters */
   2798          	if (drv >= _DRIVES) return FR_INVALID_DRIVE;
   2799          	if (partition >= 2) return FR_MKFS_ABORTED;
   2800          
   2801          	/* Check mounted drive and clear work area */
   2802          	fs = FatFs[drv];
   2803          	if (!fs) return FR_NOT_ENABLED;
   2804          	fs->fs_type = 0;
   2805          	drv = LD2PD(drv);
   2806          
   2807          	/* Get disk statics */
   2808          	stat = disk_initialize(drv);
   2809          	if (stat & STA_NOINIT) return FR_NOT_READY;
   2810          	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   2811          #if _MAX_SS != 512						/* Get disk sector size */
   2812          	if (disk_ioctl(drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
   2813          		|| SS(fs) > _MAX_SS)
   2814          		return FR_MKFS_ABORTED;
   2815          #endif
   2816          	if (disk_ioctl(drv, GET_SECTOR_COUNT, &n_part) != RES_OK || n_part < MIN_SECTOR)
   2817          		return FR_MKFS_ABORTED;
   2818          	if (n_part > MAX_SECTOR) n_part = MAX_SECTOR;
   2819          	b_part = (!partition) ? 63 : 0;		/* Boot sector */
   2820          	n_part -= b_part;
   2821          	for (d = 512; d <= 32768U && d != allocsize; d <<= 1) ;	/* Check validity of the allocation unit size */
   2822          	if (d != allocsize) allocsize = 0;
   2823          	if (!allocsize) {					/* Auto selection of cluster size */
   2824          		d = n_part;
   2825          		for (as = SS(fs); as > 512U; as >>= 1) d >>= 1;
   2826          		for (n = 0; d < sstbl[n]; n++) ;
   2827          		allocsize = cstbl[n];
   2828          	}
   2829          	if (allocsize < SS(fs)) allocsize = SS(fs);
   2830          
   2831          	allocsize /= SS(fs);		/* Number of sectors per cluster */
   2832          
   2833          	/* Pre-compute number of clusters and FAT type */
   2834          	n_clst = n_part / allocsize;
   2835          	fmt = FS_FAT12;
   2836          	if (n_clst >= 0xFF5) fmt = FS_FAT16;
   2837          	if (n_clst >= 0xFFF5) fmt = FS_FAT32;
   2838          
   2839          	/* Determine offset and size of FAT structure */
   2840          	switch (fmt) {
   2841          	case FS_FAT12:
   2842          		n_fat = ((n_clst * 3 + 1) / 2 + 3 + SS(fs) - 1) / SS(fs);
   2843          		n_rsv = 1 + partition;
   2844          		n_dir = N_ROOTDIR * 32 / SS(fs);
   2845          		break;
   2846          	case FS_FAT16:
   2847          		n_fat = ((n_clst * 2) + 4 + SS(fs) - 1) / SS(fs);
   2848          		n_rsv = 1 + partition;
   2849          		n_dir = N_ROOTDIR * 32 / SS(fs);
   2850          		break;
   2851          	default:
   2852          		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
   2853          		n_rsv = 33 - partition;
   2854          		n_dir = 0;
   2855          	}
   2856          	b_fat = b_part + n_rsv;			/* FATs start sector */
   2857          	b_dir = b_fat + n_fat * N_FATS;	/* Directory start sector */
   2858          	b_data = b_dir + n_dir;			/* Data start sector */
   2859          
   2860          	/* Align data start sector to erase block boundary (for flash memory media) */
   2861          	if (disk_ioctl(drv, GET_BLOCK_SIZE, &n) != RES_OK) return FR_MKFS_ABORTED;
   2862          	n = (b_data + n - 1) & ~(n - 1);
   2863          	n_fat += (n - b_data) / N_FATS;
   2864          	/* b_dir and b_data are no longer used below */
   2865          
   2866          	/* Determine number of cluster and final check of validity of the FAT type */
   2867          	n_clst = (n_part - n_rsv - n_fat * N_FATS - n_dir) / allocsize;
   2868          	if (   (fmt == FS_FAT16 && n_clst < 0xFF5)
   2869          		|| (fmt == FS_FAT32 && n_clst < 0xFFF5))
   2870          		return FR_MKFS_ABORTED;
   2871          
   2872          	/* Create partition table if needed */
   2873          	if (!partition) {
   2874          		DWORD n_disk = b_part + n_part;
   2875          
   2876          		mem_set(fs->win, 0, SS(fs));
   2877          		tbl = fs->win+MBR_Table;
   2878          		ST_DWORD(tbl, 0x00010180);		/* Partition start in CHS */
   2879          		if (n_disk < 63UL * 255 * 1024) {	/* Partition end in CHS */
   2880          			n_disk = n_disk / 63 / 255;
   2881          			tbl[7] = (BYTE)n_disk;
   2882          			tbl[6] = (BYTE)((n_disk >> 2) | 63);
   2883          		} else {
   2884          			ST_WORD(&tbl[6], 0xFFFF);
   2885          		}
   2886          		tbl[5] = 254;
   2887          		if (fmt != FS_FAT32)			/* System ID */
   2888          			tbl[4] = (n_part < 0x10000) ? 0x04 : 0x06;
   2889          		else
   2890          			tbl[4] = 0x0c;
   2891          		ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
   2892          		ST_DWORD(tbl+12, n_part);		/* Partition size in LBA */
   2893          		ST_WORD(tbl+64, 0xAA55);		/* Signature */
   2894          		if (disk_write(drv, fs->win, 0, 1) != RES_OK)
   2895          			return FR_DISK_ERR;
   2896          		partition = 0xF8;
   2897          	} else {
   2898          		partition = 0xF0;
   2899          	}
   2900          
   2901          	/* Create boot record */
   2902          	tbl = fs->win;								/* Clear buffer */
   2903          	mem_set(tbl, 0, SS(fs));
   2904          	ST_DWORD(tbl+BS_jmpBoot, 0x90FEEB);			/* Boot code (jmp $, nop) */
   2905          	ST_WORD(tbl+BPB_BytsPerSec, SS(fs));		/* Sector size */
   2906          	tbl[BPB_SecPerClus] = (BYTE)allocsize;		/* Sectors per cluster */
   2907          	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);			/* Reserved sectors */
   2908          	tbl[BPB_NumFATs] = N_FATS;					/* Number of FATs */
   2909          	ST_WORD(tbl+BPB_RootEntCnt, SS(fs) / 32 * n_dir); /* Number of rootdir entries */
   2910          	if (n_part < 0x10000) {						/* Number of total sectors */
   2911          		ST_WORD(tbl+BPB_TotSec16, n_part);
   2912          	} else {
   2913          		ST_DWORD(tbl+BPB_TotSec32, n_part);
   2914          	}
   2915          	tbl[BPB_Media] = partition;					/* Media descripter */
   2916          	ST_WORD(tbl+BPB_SecPerTrk, 63);				/* Number of sectors per track */
   2917          	ST_WORD(tbl+BPB_NumHeads, 255);				/* Number of heads */
   2918          	ST_DWORD(tbl+BPB_HiddSec, b_part);			/* Hidden sectors */
   2919          	n = get_fattime();							/* Use current time as a VSN */
   2920          	if (fmt != FS_FAT32) {
   2921          		ST_DWORD(tbl+BS_VolID, n);				/* Volume serial number */
   2922          		ST_WORD(tbl+BPB_FATSz16, n_fat);		/* Number of secters per FAT */
   2923          		tbl[BS_DrvNum] = 0x80;					/* Drive number */
   2924          		tbl[BS_BootSig] = 0x29;					/* Extended boot signature */
   2925          		mem_cpy(tbl+BS_VolLab, "NO NAME    FAT     ", 19);	/* Volume lavel, FAT signature */
   2926          	} else {
   2927          		ST_DWORD(tbl+BS_VolID32, n);			/* Volume serial number */
   2928          		ST_DWORD(tbl+BPB_FATSz32, n_fat);		/* Number of secters per FAT */
   2929          		ST_DWORD(tbl+BPB_RootClus, 2);			/* Root directory cluster (2) */
   2930          		ST_WORD(tbl+BPB_FSInfo, 1);				/* FSInfo record offset (bs+1) */
   2931          		ST_WORD(tbl+BPB_BkBootSec, 6);			/* Backup boot record offset (bs+6) */
   2932          		tbl[BS_DrvNum32] = 0x80;				/* Drive number */
   2933          		tbl[BS_BootSig32] = 0x29;				/* Extended boot signature */
   2934          		mem_cpy(tbl+BS_VolLab32, "NO NAME    FAT32   ", 19);	/* Volume lavel, FAT signature */
   2935          	}
   2936          	ST_WORD(tbl+BS_55AA, 0xAA55);				/* Signature */
   2937          	if (SS(fs) > 512U) {
   2938          		ST_WORD(tbl+SS(fs)-2, 0xAA55);
   2939          	}
   2940          	if (disk_write(drv, tbl, b_part+0, 1) != RES_OK)
   2941          		return FR_DISK_ERR;
   2942          	if (fmt == FS_FAT32)
   2943          		disk_write(drv, tbl, b_part+6, 1);
   2944          
   2945          	/* Initialize FAT area */
   2946          	for (m = 0; m < N_FATS; m++) {
   2947          		mem_set(tbl, 0, SS(fs));		/* 1st sector of the FAT  */
   2948          		if (fmt != FS_FAT32) {
   2949          			n = (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
   2950          			n |= partition;
   2951          			ST_DWORD(tbl, n);				/* Reserve cluster #0-1 (FAT12/16) */
   2952          		} else {
   2953          			ST_DWORD(tbl+0, 0xFFFFFFF8);	/* Reserve cluster #0-1 (FAT32) */
   2954          			ST_DWORD(tbl+4, 0xFFFFFFFF);
   2955          			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
   2956          		}
   2957          		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
   2958          			return FR_DISK_ERR;
   2959          		mem_set(tbl, 0, SS(fs));		/* Following FAT entries are filled by zero */
   2960          		for (n = 1; n < n_fat; n++) {
   2961          			if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
   2962          				return FR_DISK_ERR;
   2963          		}
   2964          	}
   2965          
   2966          	/* Initialize Root directory */
   2967          	m = (BYTE)((fmt == FS_FAT32) ? allocsize : n_dir);
   2968          	do {
   2969          		if (disk_write(drv, tbl, b_fat++, 1) != RES_OK)
   2970          			return FR_DISK_ERR;
   2971          	} while (--m);
   2972          
   2973          	/* Create FSInfo record if needed */
   2974          	if (fmt == FS_FAT32) {
   2975          		ST_WORD(tbl+BS_55AA, 0xAA55);
   2976          		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
   2977          		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
   2978          		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);
   2979          		ST_DWORD(tbl+FSI_Nxt_Free, 0xFFFFFFFF);
   2980          		disk_write(drv, tbl, b_part+1, 1);
   2981          		disk_write(drv, tbl, b_part+7, 1);
   2982          	}
   2983          
   2984          	return (disk_ioctl(drv, CTRL_SYNC, (void*)NULL) == RES_OK) ? FR_OK : FR_DISK_ERR;
   2985          }
   2986          
   2987          #endif /* _USE_MKFS && !_FS_READONLY */
   2988          
   2989          
   2990          
   2991          
   2992          #if _USE_STRFUNC
   2993          /*-----------------------------------------------------------------------*/
   2994          /* Get a string from the file                                            */
   2995          /*-----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   2996          char* f_gets (
   2997          	char* buff,	/* Pointer to the string buffer to read */
   2998          	int len,	/* Size of string buffer */
   2999          	FIL* fil	/* Pointer to the file object */
   3000          )
   3001          {
   \                     f_gets:
   \   00000000   2DE9F041           PUSH     {R4-R8,LR}
   \   00000004   82B0               SUB      SP,SP,#+8
   \   00000006   0446               MOV      R4,R0
   \   00000008   0D46               MOV      R5,R1
   \   0000000A   9046               MOV      R8,R2
   3002          	int i = 0;
   \   0000000C   0027               MOVS     R7,#+0
   3003          	char *p = buff;
   \   0000000E   2646               MOV      R6,R4
   3004          	UINT rc;
   3005          
   3006          
   3007          	while (i < len - 1) {			/* Read bytes until buffer gets filled */
   \                     ??f_gets_0:
   \   00000010   681E               SUBS     R0,R5,#+1
   \   00000012   8742               CMP      R7,R0
   \   00000014   0DDA               BGE.N    ??f_gets_1
   3008          		f_read(fil, p, 1, &rc);
   \   00000016   00AB               ADD      R3,SP,#+0
   \   00000018   0122               MOVS     R2,#+1
   \   0000001A   3146               MOV      R1,R6
   \   0000001C   4046               MOV      R0,R8
   \   0000001E   ........           BL       f_read
   3009          		if (rc != 1) break;			/* Break when no data to read */
   \   00000022   0098               LDR      R0,[SP, #+0]
   \   00000024   0128               CMP      R0,#+1
   \   00000026   04D1               BNE.N    ??f_gets_1
   3010          #if _USE_STRFUNC >= 2
   3011          		if (*p == '\r') continue;	/* Strip '\r' */
   3012          #endif
   3013          		i++;
   \   00000028   7F1C               ADDS     R7,R7,#+1
   3014          		if (*p++ == '\n') break;	/* Break when reached end of line */
   \   0000002A   16F8010B           LDRB     R0,[R6], #+1
   \   0000002E   0A28               CMP      R0,#+10
   \   00000030   EED1               BNE.N    ??f_gets_0
   3015          	}
   3016          	*p = 0;
   \                     ??f_gets_1:
   \   00000032   0020               MOVS     R0,#+0
   \   00000034   3070               STRB     R0,[R6, #+0]
   3017          	return i ? buff : NULL;			/* When no data read (eof or error), return with error. */
   \   00000036   07B1               CBZ      R7,??f_gets_2
   \   00000038   2046               MOV      R0,R4
   \                     ??f_gets_2:
   \   0000003A   BDE8F681           POP      {R1,R2,R4-R8,PC}  ;; return
   3018          }
   3019          
   3020          
   3021          
   3022          #if !_FS_READONLY
   3023          #include <stdarg.h>
   3024          /*-----------------------------------------------------------------------*/
   3025          /* Put a character to the file                                           */
   3026          /*-----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   3027          int f_putc (
   3028          	int chr,	/* A character to be output */
   3029          	FIL* fil	/* Ponter to the file object */
   3030          )
   3031          {
   \                     f_putc:
   \   00000000   1CB5               PUSH     {R2-R4,LR}
   \   00000002   0446               MOV      R4,R0
   \   00000004   0800               MOVS     R0,R1
   3032          	UINT bw;
   3033          	char c;
   3034          
   3035          
   3036          #if _USE_STRFUNC >= 2
   3037          	if (chr == '\n') f_putc ('\r', fil);	/* LF -> CRLF conversion */
   3038          #endif
   3039          	if (!fil) {	/* Special value may be used to switch the destination to any other device */
   \   00000006   09D0               BEQ.N    ??f_putc_0
   3040          	/*	put_console(chr);	*/
   3041          		return chr;
   3042          	}
   3043          	c = (char)chr;
   \   00000008   01A9               ADD      R1,SP,#+4
   \   0000000A   0C70               STRB     R4,[R1, #+0]
   3044          	f_write(fil, &c, 1, &bw);	/* Write a byte to the file */
   \   0000000C   00AB               ADD      R3,SP,#+0
   \   0000000E   0122               MOVS     R2,#+1
   \   00000010   ........           BL       f_write
   3045          	return bw ? chr : EOF;		/* Return the result */
   \   00000014   0098               LDR      R0,[SP, #+0]
   \   00000016   08B9               CBNZ     R0,??f_putc_0
   \   00000018   4FF0FF34           MOV      R4,#-1
   \                     ??f_putc_0:
   \   0000001C   2046               MOV      R0,R4
   \   0000001E   16BD               POP      {R1,R2,R4,PC}    ;; return
   3046          }
   3047          
   3048          
   3049          
   3050          
   3051          /*-----------------------------------------------------------------------*/
   3052          /* Put a string to the file                                              */
   3053          /*-----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   3054          int f_puts (
   3055          	const char* str,	/* Pointer to the string to be output */
   3056          	FIL* fil			/* Pointer to the file object */
   3057          )
   3058          {
   \                     f_puts:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0546               MOV      R5,R0
   \   00000004   0C46               MOV      R4,R1
   3059          	int n;
   3060          
   3061          
   3062          	for (n = 0; *str; str++, n++) {
   \   00000006   0026               MOVS     R6,#+0
   \   00000008   00E0               B.N      ??f_puts_0
   \                     ??f_puts_1:
   \   0000000A   761C               ADDS     R6,R6,#+1
   \                     ??f_puts_0:
   \   0000000C   2878               LDRB     R0,[R5, #+0]
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   0AD0               BEQ.N    ??f_puts_2
   3063          		if (f_putc(*str, fil) == EOF) return EOF;
   \   00000012   2146               MOV      R1,R4
   \   00000014   15F8010B           LDRB     R0,[R5], #+1
   \   00000018   ........           BL       f_putc
   \   0000001C   4FF0FF31           MOV      R1,#-1
   \   00000020   8842               CMP      R0,R1
   \   00000022   F2D1               BNE.N    ??f_puts_1
   \   00000024   0846               MOV      R0,R1
   \   00000026   70BD               POP      {R4-R6,PC}
   3064          	}
   3065          	return n;
   \                     ??f_puts_2:
   \   00000028   3046               MOV      R0,R6
   \   0000002A   70BD               POP      {R4-R6,PC}       ;; return
   3066          }
   3067          
   3068          
   3069          
   3070          
   3071          /*-----------------------------------------------------------------------*/
   3072          /* Put a formatted string to the file                                    */
   3073          /*-----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   3074          int f_printf (
   3075          	FIL* fil,			/* Pointer to the file object */
   3076          	const char* str,	/* Pointer to the format string */
   3077          	...					/* Optional arguments... */
   3078          )
   3079          {
   \                     f_printf:
   \   00000000   0CB4               PUSH     {R2,R3}
   \   00000002   2DE9F043           PUSH     {R4-R9,LR}
   \   00000006   85B0               SUB      SP,SP,#+20
   \   00000008   0546               MOV      R5,R0
   \   0000000A   0E46               MOV      R6,R1
   3080          	va_list arp;
   3081          	UCHAR c, f, r;
   3082          	ULONG val;
   3083          	char s[16];
   3084          	int i, w, res, cc;
   3085          
   3086          
   3087          	va_start(arp, str);
   \   0000000C   0DF13008           ADD      R8,SP,#+48
   3088          
   3089          	for (cc = res = 0; cc != EOF; res += cc) {
   \   00000010   0024               MOVS     R4,#+0
   \   00000012   00AF               ADD      R7,SP,#+0
   3090          		c = *str++;
   \                     ??f_printf_0:
   \   00000014   16F8010B           LDRB     R0,[R6], #+1
   3091          		if (c == 0) break;			/* End of string */
   \   00000018   0100               MOVS     R1,R0
   \   0000001A   41D0               BEQ.N    ??f_printf_1
   3092          		if (c != '%') {				/* Non escape cahracter */
   \   0000001C   2528               CMP      R0,#+37
   \   0000001E   08D0               BEQ.N    ??f_printf_2
   3093          			cc = f_putc(c, fil);
   \                     ??f_printf_3:
   \   00000020   2946               MOV      R1,R5
   \   00000022   ........           BL       f_putc
   3094          			if (cc != EOF) cc = 1;
   \   00000026   4FF0FF31           MOV      R1,#-1
   \   0000002A   8842               CMP      R0,R1
   \   0000002C   75D0               BEQ.N    ??f_printf_4
   \   0000002E   0120               MOVS     R0,#+1
   \   00000030   73E0               B.N      ??f_printf_4
   3095          			continue;
   3096          		}
   3097          		w = f = 0;
   \                     ??f_printf_2:
   \   00000032   0021               MOVS     R1,#+0
   \   00000034   0023               MOVS     R3,#+0
   3098          		c = *str++;
   \   00000036   16F8010B           LDRB     R0,[R6], #+1
   3099          		if (c == '0') {				/* Flag: '0' padding */
   \   0000003A   3028               CMP      R0,#+48
   \   0000003C   08D1               BNE.N    ??f_printf_5
   3100          			f = 1; c = *str++;
   \   0000003E   0121               MOVS     R1,#+1
   \   00000040   04E0               B.N      ??f_printf_6
   3101          		}
   3102          		while (c >= '0' && c <= '9') {	/* Precision */
   3103          			w = w * 10 + (c - '0');
   \                     ??f_printf_7:
   \   00000042   0A22               MOVS     R2,#+10
   \   00000044   03FB0200           MLA      R0,R3,R2,R0
   \   00000048   A0F13003           SUB      R3,R0,#+48
   3104          			c = *str++;
   \                     ??f_printf_6:
   \   0000004C   16F8010B           LDRB     R0,[R6], #+1
   3105          		}
   \                     ??f_printf_5:
   \   00000050   3028               CMP      R0,#+48
   \   00000052   01D3               BCC.N    ??f_printf_8
   \   00000054   3A28               CMP      R0,#+58
   \   00000056   F4D3               BCC.N    ??f_printf_7
   3106          		if (c == 'l') {				/* Prefix: Size is long int */
   \                     ??f_printf_8:
   \   00000058   6C28               CMP      R0,#+108
   \   0000005A   03D1               BNE.N    ??f_printf_9
   3107          			f |= 2; c = *str++;
   \   0000005C   41F00201           ORR      R1,R1,#0x2
   \   00000060   16F8010B           LDRB     R0,[R6], #+1
   3108          		}
   3109          		if (c == 's') {				/* Type is string */
   \                     ??f_printf_9:
   \   00000064   7328               CMP      R0,#+115
   \   00000066   05D1               BNE.N    ??f_printf_10
   3110          			cc = f_puts(va_arg(arp, char*), fil);
   \   00000068   58F8040B           LDR      R0,[R8], #+4
   \   0000006C   2946               MOV      R1,R5
   \   0000006E   ........           BL       f_puts
   3111          			continue;
   \   00000072   52E0               B.N      ??f_printf_4
   3112          		}
   3113          		if (c == 'c') {				/* Type is character */
   \                     ??f_printf_10:
   \   00000074   6328               CMP      R0,#+99
   \   00000076   02D1               BNE.N    ??f_printf_11
   3114          			cc = f_putc(va_arg(arp, int), fil);
   \   00000078   58F8040B           LDR      R0,[R8], #+4
   \   0000007C   D0E7               B.N      ??f_printf_3
   3115          			if (cc != EOF) cc = 1;
   3116          			continue;
   3117          		}
   3118          		r = 0;
   \                     ??f_printf_11:
   \   0000007E   4FF0000C           MOV      R12,#+0
   3119          		if (c == 'd') r = 10;		/* Type is signed decimal */
   \   00000082   6428               CMP      R0,#+100
   \   00000084   01D1               BNE.N    ??f_printf_12
   \   00000086   4FF00A0C           MOV      R12,#+10
   3120          		if (c == 'u') r = 10;		/* Type is unsigned decimal */
   \                     ??f_printf_12:
   \   0000008A   7528               CMP      R0,#+117
   \   0000008C   01D1               BNE.N    ??f_printf_13
   \   0000008E   4FF00A0C           MOV      R12,#+10
   3121          		if (c == 'X') r = 16;		/* Type is unsigned hexdecimal */
   \                     ??f_printf_13:
   \   00000092   5828               CMP      R0,#+88
   \   00000094   02D1               BNE.N    ??f_printf_14
   \   00000096   4FF0100C           MOV      R12,#+16
   \   0000009A   02E0               B.N      ??f_printf_15
   3122          		if (r == 0) break;			/* Unknown type */
   \                     ??f_printf_14:
   \   0000009C   BCF1000F           CMP      R12,#+0
   \                     ??f_printf_1:
   \   000000A0   43D0               BEQ.N    ??f_printf_16
   3123          		if (f & 2) {				/* Get the value */
   \                     ??f_printf_15:
   \   000000A2   58F804EB           LDR      LR,[R8], #+4
   3124          			val = (ULONG)va_arg(arp, long);
   3125          		} else {
   3126          			val = (c == 'd') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int);
   3127          		}
   3128          		/* Put numeral string */
   3129          		if (c == 'd') {
   \   000000A6   6428               CMP      R0,#+100
   \   000000A8   07D1               BNE.N    ??f_printf_17
   3130          			if (val & 0x80000000) {
   \   000000AA   1EF0004F           TST      LR,#0x80000000
   \   000000AE   04D0               BEQ.N    ??f_printf_17
   3131          				val = 0 - val;
   \   000000B0   CEF1000E           RSB      LR,LR,#+0
   3132          				f |= 4;
   \   000000B4   41F00401           ORR      R1,R1,#0x4
   \   000000B8   C9B2               UXTB     R1,R1
   3133          			}
   3134          		}
   3135          		i = sizeof(s) - 1; s[i] = 0;
   \                     ??f_printf_17:
   \   000000BA   0F22               MOVS     R2,#+15
   \   000000BC   0020               MOVS     R0,#+0
   \   000000BE   F873               STRB     R0,[R7, #+15]
   3136          		do {
   3137          			c = (UCHAR)(val % r + '0');
   \                     ??f_printf_18:
   \   000000C0   BEFBFCF9           UDIV     R9,LR,R12
   \   000000C4   09FB1CE0           MLS      R0,R9,R12,LR
   \   000000C8   3030               ADDS     R0,R0,#+48
   \   000000CA   C0B2               UXTB     R0,R0
   3138          			if (c > '9') c += 7;
   \   000000CC   3A28               CMP      R0,#+58
   \   000000CE   01D3               BCC.N    ??f_printf_19
   \   000000D0   C01D               ADDS     R0,R0,#+7
   \   000000D2   C0B2               UXTB     R0,R0
   3139          			s[--i] = c;
   \                     ??f_printf_19:
   \   000000D4   521E               SUBS     R2,R2,#+1
   \   000000D6   D055               STRB     R0,[R2, R7]
   3140          			val /= r;
   \   000000D8   CE46               MOV      LR,R9
   3141          		} while (i && val);
   \   000000DA   08D0               BEQ.N    ??f_printf_20
   \   000000DC   BEF1000F           CMP      LR,#+0
   \   000000E0   EED1               BNE.N    ??f_printf_18
   \   000000E2   11F0040F           TST      R1,#0x4
   \   000000E6   02D0               BEQ.N    ??f_printf_20
   3142          		if (i && (f & 4)) s[--i] = '-';
   \   000000E8   521E               SUBS     R2,R2,#+1
   \   000000EA   2D20               MOVS     R0,#+45
   \   000000EC   D055               STRB     R0,[R2, R7]
   3143          		w = sizeof(s) - 1 - w;
   \                     ??f_printf_20:
   \   000000EE   C3F10F03           RSB      R3,R3,#+15
   \   000000F2   02E0               B.N      ??f_printf_21
   3144          		while (i && i > w) s[--i] = (f & 1) ? '0' : ' ';
   \                     ??f_printf_22:
   \   000000F4   2020               MOVS     R0,#+32
   \                     ??f_printf_23:
   \   000000F6   0CF80700           STRB     R0,[R12, R7]
   \                     ??f_printf_21:
   \   000000FA   4AB1               CBZ      R2,??f_printf_24
   \   000000FC   9342               CMP      R3,R2
   \   000000FE   07DA               BGE.N    ??f_printf_24
   \   00000100   A2F1010C           SUB      R12,R2,#+1
   \   00000104   6246               MOV      R2,R12
   \   00000106   11F0010F           TST      R1,#0x1
   \   0000010A   F3D0               BEQ.N    ??f_printf_22
   \   0000010C   3020               MOVS     R0,#+48
   \   0000010E   F2E7               B.N      ??f_printf_23
   3145          		cc = f_puts(&s[i], fil);
   \                     ??f_printf_24:
   \   00000110   2946               MOV      R1,R5
   \   00000112   00A8               ADD      R0,SP,#+0
   \   00000114   1018               ADDS     R0,R2,R0
   \   00000116   ........           BL       f_puts
   3146          	}
   \                     ??f_printf_4:
   \   0000011A   0419               ADDS     R4,R0,R4
   \   0000011C   4FF0FF31           MOV      R1,#-1
   \   00000120   8842               CMP      R0,R1
   \   00000122   7FF477AF           BNE.W    ??f_printf_0
   \   00000126   0846               MOV      R0,R1
   \   00000128   00E0               B.N      ??f_printf_25
   \                     ??f_printf_16:
   \   0000012A   2046               MOV      R0,R4
   \                     ??f_printf_25:
   \   0000012C   05B0               ADD      SP,SP,#+20
   \   0000012E   BDE8F003           POP      {R4-R9}
   \   00000132   5DF80CFB           LDR      PC,[SP], #+12    ;; return
   3147          
   3148          	va_end(arp);
   3149          	return (cc == EOF) ? cc : res;
   3150          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     LfnOfs
   3151          
   3152          #endif /* !_FS_READONLY */
   3153          #endif /* _USE_STRFUNC */

   Maximum stack usage in bytes:

     Function     .cstack
     --------     -------
     check_fs          8
     chk_chr           0
     chk_mounted      24
     clust2sect        0
     create_chain     24
     create_name      40
     dir_find         40
     dir_next         24
     dir_read         32
     dir_register     48
     dir_remove       16
     dir_seek         16
     f_chmod          64
     f_close           8
     f_getfree        40
     f_gets           32
     f_lseek          24
     f_mkdir          96
     f_mount           0
     f_open           80
     f_opendir        24
     f_printf         56
     f_putc           16
     f_puts           16
     f_read           32
     f_readdir        24
     f_rename        128
     f_stat           64
     f_sync           16
     f_truncate       16
     f_unlink         96
     f_utime          64
     f_write          32
     follow_path      16
     gen_numname      24
     get_fat          24
     get_fileinfo     24
     mem_cpy           0
     mem_set           0
     move_window      24
     put_fat          24
     remove_chain     24
     sum_sfn           0
     sync             16
     validate          8


   Section sizes:

     Function/Label   Bytes
     --------------   -----
     Fsid                8
     FatFs
     LfnBuf            512
     mem_cpy            20
     mem_set            16
     chk_chr            16
     move_window        88
     ?Subroutine4       14
     sync              176
     get_fat           198
     ?Subroutine8        4
     ??Subroutine21_0    4
     put_fat           218
     ?Subroutine9        4
     ??Subroutine22_0    4
     remove_chain       94
     create_chain      156
     clust2sect         24
     dir_seek          134
     dir_next          228
     ??Subroutine23_0    4
     ?Subroutine11       4
     ??Subroutine24_0    6
     LfnOfs             16
     gen_numname       108
     sum_sfn            28
     dir_find          302
     ?Subroutine7        4
     ?Subroutine0        6
     dir_read          236
     dir_register      434
     ?Subroutine3        8
     ??Subroutine25_0    8
     dir_remove         70
     create_name       468
     cvt               148
     get_fileinfo      188
     ?Subroutine10      22
     follow_path       118
     check_fs          108
     chk_mounted       616
     validate           42
     f_mount            36
     f_open            354
     ?Subroutine15      16
     f_read            308
     ?Subroutine19      12
     ?Subroutine18      14
     ?Subroutine17      10
     ?Subroutine2       16
     ?Subroutine16       6
     ?Subroutine1       16
     f_write           388
     f_sync            152
     ?Subroutine6       10
     f_close            18
     f_lseek           316
     f_opendir          98
     ?Subroutine14      16
     f_readdir          68
     f_stat             50
     ?Subroutine13      20
     f_getfree         216
     f_truncate        144
     f_unlink          164
     f_mkdir           376
     ?Subroutine20      14
     ?Subroutine5        4
     f_chmod            66
     ?Subroutine12      12
     f_utime            84
     f_rename          284
     f_gets             62
     f_putc             32
     f_puts             44
     f_printf          310
     ??DataTable2        4

 
   520 bytes in section .bss
   164 bytes in section .rodata
 7 918 bytes in section .text
 
 7 918 bytes of CODE  memory
   164 bytes of CONST memory
   520 bytes of DATA  memory

Errors: none
Warnings: 1
