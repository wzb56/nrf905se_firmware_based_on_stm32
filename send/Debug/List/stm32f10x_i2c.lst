###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     21/May/2011  19:21:01 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Documents and Settings\253642xvvn\桌面\IAR\2.4G_send\ #
#                    FWLib\library\src\stm32f10x_i2c.c                        #
#    Command line =  "C:\Documents and Settings\253642xvvn\桌面\IAR\2.4G_send #
#                    \FWLib\library\src\stm32f10x_i2c.c" -lC "C:\Documents    #
#                    and Settings\253642xvvn\桌面\IAR\2.4G_send\Demo\project\ #
#                    test\Debug\List\" -lb "C:\Documents and                  #
#                    Settings\253642xvvn\桌面\IAR\2.4G_send\Demo\project\test #
#                    \Debug\List\" -o "C:\Documents and                       #
#                    Settings\253642xvvn\桌面\IAR\2.4G_send\Demo\project\test #
#                    \Debug\Obj\" --no_cse --no_unroll --no_inline            #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "D:\Program Files\IAR        #
#                    Systems\Embedded Workbench 5.4\arm\INC\DLib_Config_Full. #
#                    h" -I "C:\Documents and Settings\253642xvvn\桌面\IAR\2.4 #
#                    G_send\Demo\project\test\FWLib\library\inc\" -I          #
#                    "C:\Documents and Settings\253642xvvn\桌面\IAR\2.4G_send #
#                    \Demo\project\test\board\" -I "C:\Documents and          #
#                    Settings\253642xvvn\桌面\IAR\2.4G_send\Demo\project\test #
#                    \app\" -I "D:\Program Files\IAR Systems\Embedded         #
#                    Workbench 5.4\arm\INC\" -Ol                              #
#    List file    =  C:\Documents and Settings\253642xvvn\桌面\IAR\2.4G_send\ #
#                    Demo\project\test\Debug\List\stm32f10x_i2c.lst           #
#    Object file  =  C:\Documents and Settings\253642xvvn\桌面\IAR\2.4G_send\ #
#                    Demo\project\test\Debug\Obj\stm32f10x_i2c.o              #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\253642xvvn\桌面\IAR\2.4G_send\FWLib\library\src\stm32f10x_i2c.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : stm32f10x_i2c.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.0.1
      5          * Date               : 06/13/2008
      6          * Description        : This file provides all the I2C firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          
     16          /* Includes ------------------------------------------------------------------*/
     17          #include "stm32f10x_i2c.h"
     18          #include "stm32f10x_rcc.h"
     19          	 
     20          /* Private typedef -----------------------------------------------------------*/
     21          /* Private define ------------------------------------------------------------*/
     22          /* I2C SPE mask */
     23          #define CR1_PE_Set              ((u16)0x0001)
     24          #define CR1_PE_Reset            ((u16)0xFFFE)
     25          
     26          /* I2C START mask */
     27          #define CR1_START_Set           ((u16)0x0100)
     28          #define CR1_START_Reset         ((u16)0xFEFF)
     29          
     30          /* I2C STOP mask */
     31          #define CR1_STOP_Set            ((u16)0x0200)
     32          #define CR1_STOP_Reset          ((u16)0xFDFF)
     33          
     34          /* I2C ACK mask */
     35          #define CR1_ACK_Set             ((u16)0x0400)
     36          #define CR1_ACK_Reset           ((u16)0xFBFF)
     37          
     38          /* I2C ENGC mask */
     39          #define CR1_ENGC_Set            ((u16)0x0040)
     40          #define CR1_ENGC_Reset          ((u16)0xFFBF)
     41          
     42          /* I2C SWRST mask */
     43          #define CR1_SWRST_Set           ((u16)0x8000)
     44          #define CR1_SWRST_Reset         ((u16)0x7FFF)
     45          
     46          /* I2C PEC mask */
     47          #define CR1_PEC_Set             ((u16)0x1000)
     48          #define CR1_PEC_Reset           ((u16)0xEFFF)
     49          
     50          /* I2C ENPEC mask */
     51          #define CR1_ENPEC_Set           ((u16)0x0020)
     52          #define CR1_ENPEC_Reset         ((u16)0xFFDF)
     53          
     54          /* I2C ENARP mask */
     55          #define CR1_ENARP_Set           ((u16)0x0010)
     56          #define CR1_ENARP_Reset         ((u16)0xFFEF)
     57          
     58          /* I2C NOSTRETCH mask */
     59          #define CR1_NOSTRETCH_Set       ((u16)0x0080)
     60          #define CR1_NOSTRETCH_Reset     ((u16)0xFF7F)
     61          
     62          /* I2C registers Masks */
     63          #define CR1_CLEAR_Mask          ((u16)0xFBF5)
     64          
     65          /* I2C DMAEN mask */
     66          #define CR2_DMAEN_Set           ((u16)0x0800)
     67          #define CR2_DMAEN_Reset         ((u16)0xF7FF)
     68          
     69          /* I2C LAST mask */
     70          #define CR2_LAST_Set            ((u16)0x1000)
     71          #define CR2_LAST_Reset          ((u16)0xEFFF)
     72          
     73          /* I2C FREQ mask */
     74          #define CR2_FREQ_Reset          ((u16)0xFFC0)
     75          
     76          /* I2C ADD0 mask */
     77          #define OAR1_ADD0_Set           ((u16)0x0001)
     78          #define OAR1_ADD0_Reset         ((u16)0xFFFE)
     79          
     80          /* I2C ENDUAL mask */
     81          #define OAR2_ENDUAL_Set         ((u16)0x0001)
     82          #define OAR2_ENDUAL_Reset       ((u16)0xFFFE)
     83          
     84          /* I2C ADD2 mask */
     85          #define OAR2_ADD2_Reset         ((u16)0xFF01)
     86          
     87          /* I2C F/S mask */
     88          #define CCR_FS_Set              ((u16)0x8000)
     89          
     90          /* I2C CCR mask */
     91          #define CCR_CCR_Set             ((u16)0x0FFF)
     92          
     93          /* I2C FLAG mask */
     94          #define FLAG_Mask               ((u32)0x00FFFFFF)
     95          
     96          /* Private macro -------------------------------------------------------------*/
     97          /* Private variables ---------------------------------------------------------*/
     98          /* Private function prototypes -----------------------------------------------*/
     99          /* Private functions ---------------------------------------------------------*/
    100          
    101          /*******************************************************************************
    102          * Function Name  : I2C_DeInit
    103          * Description    : Deinitializes the I2Cx peripheral registers to their default
    104          *                  reset values.
    105          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    106          * Output         : None
    107          * Return         : None
    108          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    109          void I2C_DeInit(I2C_TypeDef* I2Cx)
    110          {
   \                     I2C_DeInit:
   \   00000000   80B5               PUSH     {R7,LR}
    111            /* Check the parameters */
    112            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    113          
    114            switch (*(u32*)&I2Cx)
   \   00000002   0F49               LDR.N    R1,??I2C_DeInit_0  ;; 0x40005400
   \   00000004   401A               SUBS     R0,R0,R1
   \   00000006   04D0               BEQ.N    ??I2C_DeInit_1
   \   00000008   4FF48061           MOV      R1,#+1024
   \   0000000C   401A               SUBS     R0,R0,R1
   \   0000000E   0BD0               BEQ.N    ??I2C_DeInit_2
   \   00000010   15E0               B.N      ??I2C_DeInit_3
    115            {
    116              case I2C1_BASE:
    117                /* Enable I2C1 reset state */
    118                RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
   \                     ??I2C_DeInit_1:
   \   00000012   0121               MOVS     R1,#+1
   \   00000014   5FF40010           MOVS     R0,#+2097152
   \   00000018   ........           BL       RCC_APB1PeriphResetCmd
    119                /* Release I2C1 from reset state */
    120                RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
   \   0000001C   0021               MOVS     R1,#+0
   \   0000001E   5FF40010           MOVS     R0,#+2097152
   \   00000022   ........           BL       RCC_APB1PeriphResetCmd
   \   00000026   0AE0               B.N      ??I2C_DeInit_4
    121                break;
    122          
    123              case I2C2_BASE:
    124                /* Enable I2C2 reset state */
    125                RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
   \                     ??I2C_DeInit_2:
   \   00000028   0121               MOVS     R1,#+1
   \   0000002A   5FF48000           MOVS     R0,#+4194304
   \   0000002E   ........           BL       RCC_APB1PeriphResetCmd
    126                /* Release I2C2 from reset state */
    127                RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
   \   00000032   0021               MOVS     R1,#+0
   \   00000034   5FF48000           MOVS     R0,#+4194304
   \   00000038   ........           BL       RCC_APB1PeriphResetCmd
   \   0000003C   FFE7               B.N      ??I2C_DeInit_4
    128                break;
    129          
    130              default:
    131                break;
    132            }
    133          }
   \                     ??I2C_DeInit_3:
   \                     ??I2C_DeInit_4:
   \   0000003E   01BD               POP      {R0,PC}          ;; return
   \                     ??I2C_DeInit_0:
   \   00000040   00540040           DC32     0x40005400
    134          
    135          /*******************************************************************************
    136          * Function Name  : I2C_Init
    137          * Description    : Initializes the I2Cx peripheral according to the specified 
    138          *                  parameters in the I2C_InitStruct.
    139          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    140          *                  - I2C_InitStruct: pointer to a I2C_InitTypeDef structure that
    141          *                    contains the configuration information for the specified
    142          *                    I2C peripheral.
    143          * Output         : None
    144          * Return         : None
    145          ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    146          void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
    147          {
   \                     I2C_Init:
   \   00000000   2DE9F043           PUSH     {R4-R9,LR}
   \   00000004   85B0               SUB      SP,SP,#+20
   \   00000006   0500               MOVS     R5,R0
   \   00000008   0C00               MOVS     R4,R1
    148            u16 tmpreg = 0, freqrange = 0;
   \   0000000A   5FF00009           MOVS     R9,#+0
   \   0000000E   0026               MOVS     R6,#+0
    149            u16 result = 0x04;
   \   00000010   0427               MOVS     R7,#+4
    150            u32 pclk1 = 8000000;
   \   00000012   DFF8D880           LDR.W    R8,??I2C_Init_0  ;; 0x7a1200
    151            RCC_ClocksTypeDef  rcc_clocks;
    152          
    153            /* Check the parameters */
    154            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    155            assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
    156            assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
    157            assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
    158            assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
    159            assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
    160            assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
    161          
    162          /*---------------------------- I2Cx CR2 Configuration ------------------------*/
    163            /* Get the I2Cx CR2 value */
    164            tmpreg = I2Cx->CR2;
   \   00000016   A888               LDRH     R0,[R5, #+4]
   \   00000018   8146               MOV      R9,R0
    165            /* Clear frequency FREQ[5:0] bits */
    166            tmpreg &= CR2_FREQ_Reset;
   \   0000001A   4FF6C070           MOVW     R0,#+65472
   \   0000001E   10EA0909           ANDS     R9,R0,R9
    167            /* Get pclk1 frequency value */
    168            RCC_GetClocksFreq(&rcc_clocks);
   \   00000022   00A8               ADD      R0,SP,#+0
   \   00000024   ........           BL       RCC_GetClocksFreq
    169            pclk1 = rcc_clocks.PCLK1_Frequency;
   \   00000028   0298               LDR      R0,[SP, #+8]
   \   0000002A   8046               MOV      R8,R0
    170            /* Set frequency bits depending on pclk1 value */
    171            freqrange = (u16)(pclk1 / 1000000);
   \   0000002C   3048               LDR.N    R0,??I2C_Init_0+0x4  ;; 0xf4240
   \   0000002E   B8FBF0F0           UDIV     R0,R8,R0
   \   00000032   0600               MOVS     R6,R0
    172            tmpreg |= freqrange;
   \   00000034   56EA0909           ORRS     R9,R6,R9
    173            /* Write to I2Cx CR2 */
    174            I2Cx->CR2 = tmpreg;
   \   00000038   A5F80490           STRH     R9,[R5, #+4]
    175          
    176          /*---------------------------- I2Cx CCR Configuration ------------------------*/
    177            /* Disable the selected I2C peripheral to configure TRISE */
    178            I2Cx->CR1 &= CR1_PE_Reset;
   \   0000003C   2888               LDRH     R0,[R5, #+0]
   \   0000003E   30F00100           BICS     R0,R0,#0x1
   \   00000042   2880               STRH     R0,[R5, #+0]
    179          
    180            /* Reset tmpreg value */
    181            /* Clear F/S, DUTY and CCR[11:0] bits */
    182            tmpreg = 0;
   \   00000044   5FF00009           MOVS     R9,#+0
    183          
    184            /* Configure speed in standard mode */
    185            if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
   \   00000048   E068               LDR      R0,[R4, #+12]
   \   0000004A   2A49               LDR.N    R1,??I2C_Init_0+0x8  ;; 0x186a1
   \   0000004C   8842               CMP      R0,R1
   \   0000004E   0CD2               BCS.N    ??I2C_Init_1
    186            {
    187              /* Standard mode speed calculate */
    188              result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
   \   00000050   E068               LDR      R0,[R4, #+12]
   \   00000052   4000               LSLS     R0,R0,#+1
   \   00000054   B8FBF0F7           UDIV     R7,R8,R0
    189              /* Test if CCR value is under 0x4*/
    190              if (result < 0x04)
   \   00000058   BFB2               UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000005A   042F               CMP      R7,#+4
   \   0000005C   00D2               BCS.N    ??I2C_Init_2
    191              {
    192                /* Set minimum allowed value */
    193                result = 0x04;  
   \   0000005E   0427               MOVS     R7,#+4
    194              }
    195              /* Set speed value for standard mode */
    196              tmpreg |= result;	  
   \                     ??I2C_Init_2:
   \   00000060   57EA0909           ORRS     R9,R7,R9
    197              /* Set Maximum Rise Time for standard mode */
    198              I2Cx->TRISE = freqrange + 1; 
   \   00000064   701C               ADDS     R0,R6,#+1
   \   00000066   2884               STRH     R0,[R5, #+32]
   \   00000068   25E0               B.N      ??I2C_Init_3
    199            }
    200            /* Configure speed in fast mode */
    201            else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
    202            {
    203              if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
   \                     ??I2C_Init_1:
   \   0000006A   6088               LDRH     R0,[R4, #+2]
   \   0000006C   4BF6FF71           MOVW     R1,#+49151
   \   00000070   8842               CMP      R0,R1
   \   00000072   06D1               BNE.N    ??I2C_Init_4
    204              {
    205                /* Fast mode speed calculate: Tlow/Thigh = 2 */
    206                result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
   \   00000074   E068               LDR      R0,[R4, #+12]
   \   00000076   0321               MOVS     R1,#+3
   \   00000078   00FB01F0           MUL      R0,R0,R1
   \   0000007C   B8FBF0F7           UDIV     R7,R8,R0
   \   00000080   07E0               B.N      ??I2C_Init_5
    207              }
    208              else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
    209              {
    210                /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
    211                result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
   \                     ??I2C_Init_4:
   \   00000082   E068               LDR      R0,[R4, #+12]
   \   00000084   1921               MOVS     R1,#+25
   \   00000086   00FB01F0           MUL      R0,R0,R1
   \   0000008A   B8FBF0F7           UDIV     R7,R8,R0
    212                /* Set DUTY bit */
    213                result |= I2C_DutyCycle_16_9;
   \   0000008E   57F48047           ORRS     R7,R7,#0x4000
    214              }
    215              /* Test if CCR value is under 0x1*/
    216              if ((result & CCR_CCR_Set) == 0)
   \                     ??I2C_Init_5:
   \   00000092   3805               LSLS     R0,R7,#+20
   \   00000094   01D1               BNE.N    ??I2C_Init_6
    217              {
    218                /* Set minimum allowed value */
    219                result |= (u16)0x0001;  
   \   00000096   57F00107           ORRS     R7,R7,#0x1
    220              }
    221              /* Set speed value and set F/S bit for fast mode */
    222              tmpreg |= result | CCR_FS_Set;
   \                     ??I2C_Init_6:
   \   0000009A   57F40040           ORRS     R0,R7,#0x8000
   \   0000009E   50EA0909           ORRS     R9,R0,R9
    223              /* Set Maximum Rise Time for fast mode */
    224              I2Cx->TRISE = (u16)(((freqrange * 300) / 1000) + 1);  
   \   000000A2   B6B2               UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000A4   4FF49670           MOV      R0,#+300
   \   000000A8   7043               MULS     R0,R6,R0
   \   000000AA   4FF47A71           MOV      R1,#+1000
   \   000000AE   90FBF1F0           SDIV     R0,R0,R1
   \   000000B2   401C               ADDS     R0,R0,#+1
   \   000000B4   2884               STRH     R0,[R5, #+32]
    225            }
    226            /* Write to I2Cx CCR */
    227            I2Cx->CCR = tmpreg;
   \                     ??I2C_Init_3:
   \   000000B6   A5F81C90           STRH     R9,[R5, #+28]
    228          
    229            /* Enable the selected I2C peripheral */
    230            I2Cx->CR1 |= CR1_PE_Set;
   \   000000BA   2888               LDRH     R0,[R5, #+0]
   \   000000BC   50F00100           ORRS     R0,R0,#0x1
   \   000000C0   2880               STRH     R0,[R5, #+0]
    231          
    232          /*---------------------------- I2Cx CR1 Configuration ------------------------*/
    233            /* Get the I2Cx CR1 value */
    234            tmpreg = I2Cx->CR1;
   \   000000C2   B5F80090           LDRH     R9,[R5, #+0]
    235            /* Clear ACK, SMBTYPE and  SMBUS bits */
    236            tmpreg &= CR1_CLEAR_Mask;
   \   000000C6   4FF6F530           MOVW     R0,#+64501
   \   000000CA   10EA0909           ANDS     R9,R0,R9
    237            /* Configure I2Cx: mode and acknowledgement */
    238            /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
    239            /* Set ACK bit according to I2C_Ack value */
    240            tmpreg |= (u16)((u32)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
   \   000000CE   2088               LDRH     R0,[R4, #+0]
   \   000000D0   E188               LDRH     R1,[R4, #+6]
   \   000000D2   0843               ORRS     R0,R1,R0
   \   000000D4   50EA0909           ORRS     R9,R0,R9
    241            /* Write to I2Cx CR1 */
    242            I2Cx->CR1 = tmpreg;
   \   000000D8   A5F80090           STRH     R9,[R5, #+0]
    243          
    244          /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
    245            /* Set I2Cx Own Address1 and acknowledged address */
    246            I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
   \   000000DC   2089               LDRH     R0,[R4, #+8]
   \   000000DE   A188               LDRH     R1,[R4, #+4]
   \   000000E0   0843               ORRS     R0,R1,R0
   \   000000E2   2881               STRH     R0,[R5, #+8]
    247          }
   \   000000E4   05B0               ADD      SP,SP,#+20
   \   000000E6   BDE8F083           POP      {R4-R9,PC}       ;; return
   \   000000EA   00BF               Nop      
   \                     ??I2C_Init_0:
   \   000000EC   00127A00           DC32     0x7a1200
   \   000000F0   40420F00           DC32     0xf4240
   \   000000F4   A1860100           DC32     0x186a1
    248          
    249          /*******************************************************************************
    250          * Function Name  : I2C_StructInit
    251          * Description    : Fills each I2C_InitStruct member with its default value.
    252          * Input          : - I2C_InitStruct: pointer to an I2C_InitTypeDef structure
    253          *                    which will be initialized.
    254          * Output         : None
    255          * Return         : None
    256          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    257          void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
    258          {
    259          /*---------------- Reset I2C init structure parameters values ----------------*/
    260            /* Initialize the I2C_Mode member */
    261            I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
   \                     I2C_StructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   0180               STRH     R1,[R0, #+0]
    262          
    263            /* Initialize the I2C_DutyCycle member */
    264            I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
   \   00000004   4BF6FF71           MOVW     R1,#+49151
   \   00000008   4180               STRH     R1,[R0, #+2]
    265          
    266            /* Initialize the I2C_OwnAddress1 member */
    267            I2C_InitStruct->I2C_OwnAddress1 = 0;
   \   0000000A   0021               MOVS     R1,#+0
   \   0000000C   8180               STRH     R1,[R0, #+4]
    268          
    269            /* Initialize the I2C_Ack member */
    270            I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
   \   0000000E   0021               MOVS     R1,#+0
   \   00000010   C180               STRH     R1,[R0, #+6]
    271          
    272            /* Initialize the I2C_AcknowledgedAddress member */
    273            I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
   \   00000012   4FF48041           MOV      R1,#+16384
   \   00000016   0181               STRH     R1,[R0, #+8]
    274          
    275            /* initialize the I2C_ClockSpeed member */
    276            I2C_InitStruct->I2C_ClockSpeed = 5000;
   \   00000018   41F28831           MOVW     R1,#+5000
   \   0000001C   C160               STR      R1,[R0, #+12]
    277          }
   \   0000001E   7047               BX       LR               ;; return
    278          
    279          /*******************************************************************************
    280          * Function Name  : I2C_Cmd
    281          * Description    : Enables or disables the specified I2C peripheral.
    282          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    283          *                  - NewState: new state of the I2Cx peripheral. This parameter
    284          *                    can be: ENABLE or DISABLE.
    285          * Output         : None
    286          * Return         : None
    287          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    288          void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    289          {
    290            /* Check the parameters */
    291            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    292            assert_param(IS_FUNCTIONAL_STATE(NewState));
    293          
    294            if (NewState != DISABLE)
   \                     I2C_Cmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??I2C_Cmd_0
    295            {
    296              /* Enable the selected I2C peripheral */
    297              I2Cx->CR1 |= CR1_PE_Set;
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   51F00101           ORRS     R1,R1,#0x1
   \   0000000C   0180               STRH     R1,[R0, #+0]
   \   0000000E   03E0               B.N      ??I2C_Cmd_1
    298            }
    299            else
    300            {
    301              /* Disable the selected I2C peripheral */
    302              I2Cx->CR1 &= CR1_PE_Reset;
   \                     ??I2C_Cmd_0:
   \   00000010   0188               LDRH     R1,[R0, #+0]
   \   00000012   31F00101           BICS     R1,R1,#0x1
   \   00000016   0180               STRH     R1,[R0, #+0]
    303            }
    304          }
   \                     ??I2C_Cmd_1:
   \   00000018   7047               BX       LR               ;; return
    305          
    306          /*******************************************************************************
    307          * Function Name  : I2C_DMACmd
    308          * Description    : Enables or disables the specified I2C DMA requests.
    309          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    310          *                  - NewState: new state of the I2C DMA transfer.
    311          *                    This parameter can be: ENABLE or DISABLE.
    312          * Output         : None
    313          * Return         : None
    314          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    315          void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    316          {
    317            /* Check the parameters */
    318            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    319            assert_param(IS_FUNCTIONAL_STATE(NewState));
    320          
    321            if (NewState != DISABLE)
   \                     I2C_DMACmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??I2C_DMACmd_0
    322            {
    323              /* Enable the selected I2C DMA requests */
    324              I2Cx->CR2 |= CR2_DMAEN_Set;
   \   00000006   8188               LDRH     R1,[R0, #+4]
   \   00000008   51F40061           ORRS     R1,R1,#0x800
   \   0000000C   8180               STRH     R1,[R0, #+4]
   \   0000000E   03E0               B.N      ??I2C_DMACmd_1
    325            }
    326            else
    327            {
    328              /* Disable the selected I2C DMA requests */
    329              I2Cx->CR2 &= CR2_DMAEN_Reset;
   \                     ??I2C_DMACmd_0:
   \   00000010   8188               LDRH     R1,[R0, #+4]
   \   00000012   31F40061           BICS     R1,R1,#0x800
   \   00000016   8180               STRH     R1,[R0, #+4]
    330            }
    331          }
   \                     ??I2C_DMACmd_1:
   \   00000018   7047               BX       LR               ;; return
    332          
    333          /*******************************************************************************
    334          * Function Name  : I2C_DMALastTransferCmd
    335          * Description    : Specifies that the next DMA transfer is the last one.
    336          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    337          *                  - NewState: new state of the I2C DMA last transfer.
    338          *                    This parameter can be: ENABLE or DISABLE.
    339          * Output         : None
    340          * Return         : None
    341          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    342          void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    343          {
    344            /* Check the parameters */
    345            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    346            assert_param(IS_FUNCTIONAL_STATE(NewState));
    347          
    348            if (NewState != DISABLE)
   \                     I2C_DMALastTransferCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??I2C_DMALastTransferCmd_0
    349            {
    350              /* Next DMA transfer is the last transfer */
    351              I2Cx->CR2 |= CR2_LAST_Set;
   \   00000006   8188               LDRH     R1,[R0, #+4]
   \   00000008   51F48051           ORRS     R1,R1,#0x1000
   \   0000000C   8180               STRH     R1,[R0, #+4]
   \   0000000E   03E0               B.N      ??I2C_DMALastTransferCmd_1
    352            }
    353            else
    354            {
    355              /* Next DMA transfer is not the last transfer */
    356              I2Cx->CR2 &= CR2_LAST_Reset;
   \                     ??I2C_DMALastTransferCmd_0:
   \   00000010   8188               LDRH     R1,[R0, #+4]
   \   00000012   31F48051           BICS     R1,R1,#0x1000
   \   00000016   8180               STRH     R1,[R0, #+4]
    357            }
    358          }
   \                     ??I2C_DMALastTransferCmd_1:
   \   00000018   7047               BX       LR               ;; return
    359          
    360          /*******************************************************************************
    361          * Function Name  : I2C_GenerateSTART
    362          * Description    : Generates I2Cx communication START condition.
    363          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    364          *                  - NewState: new state of the I2C START condition generation.
    365          *                    This parameter can be: ENABLE or DISABLE.
    366          * Output         : None
    367          * Return         : None.
    368          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    369          void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
    370          {
    371            /* Check the parameters */
    372            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    373            assert_param(IS_FUNCTIONAL_STATE(NewState));
    374          
    375            if (NewState != DISABLE)
   \                     I2C_GenerateSTART:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??I2C_GenerateSTART_0
    376            {
    377              /* Generate a START condition */
    378              I2Cx->CR1 |= CR1_START_Set;
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   51F48071           ORRS     R1,R1,#0x100
   \   0000000C   0180               STRH     R1,[R0, #+0]
   \   0000000E   03E0               B.N      ??I2C_GenerateSTART_1
    379            }
    380            else
    381            {
    382              /* Disable the START condition generation */
    383              I2Cx->CR1 &= CR1_START_Reset;
   \                     ??I2C_GenerateSTART_0:
   \   00000010   0188               LDRH     R1,[R0, #+0]
   \   00000012   31F48071           BICS     R1,R1,#0x100
   \   00000016   0180               STRH     R1,[R0, #+0]
    384            }
    385          }
   \                     ??I2C_GenerateSTART_1:
   \   00000018   7047               BX       LR               ;; return
    386          
    387          /*******************************************************************************
    388          * Function Name  : I2C_GenerateSTOP
    389          * Description    : Generates I2Cx communication STOP condition.
    390          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    391          *                  - NewState: new state of the I2C STOP condition generation.
    392          *                    This parameter can be: ENABLE or DISABLE.
    393          * Output         : None
    394          * Return         : None.
    395          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    396          void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
    397          {
    398            /* Check the parameters */
    399            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    400            assert_param(IS_FUNCTIONAL_STATE(NewState));
    401          
    402            if (NewState != DISABLE)
   \                     I2C_GenerateSTOP:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??I2C_GenerateSTOP_0
    403            {
    404              /* Generate a STOP condition */
    405              I2Cx->CR1 |= CR1_STOP_Set;
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   51F40071           ORRS     R1,R1,#0x200
   \   0000000C   0180               STRH     R1,[R0, #+0]
   \   0000000E   03E0               B.N      ??I2C_GenerateSTOP_1
    406            }
    407            else
    408            {
    409              /* Disable the STOP condition generation */
    410              I2Cx->CR1 &= CR1_STOP_Reset;
   \                     ??I2C_GenerateSTOP_0:
   \   00000010   0188               LDRH     R1,[R0, #+0]
   \   00000012   31F40071           BICS     R1,R1,#0x200
   \   00000016   0180               STRH     R1,[R0, #+0]
    411            }
    412          }
   \                     ??I2C_GenerateSTOP_1:
   \   00000018   7047               BX       LR               ;; return
    413          
    414          /*******************************************************************************
    415          * Function Name  : I2C_AcknowledgeConfig
    416          * Description    : Enables or disables the specified I2C acknowledge feature.
    417          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    418          *                  - NewState: new state of the I2C Acknowledgement.
    419          *                    This parameter can be: ENABLE or DISABLE.
    420          * Output         : None
    421          * Return         : None.
    422          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    423          void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
    424          {
    425            /* Check the parameters */
    426            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    427            assert_param(IS_FUNCTIONAL_STATE(NewState));
    428          
    429            if (NewState != DISABLE)
   \                     I2C_AcknowledgeConfig:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??I2C_AcknowledgeConfig_0
    430            {
    431              /* Enable the acknowledgement */
    432              I2Cx->CR1 |= CR1_ACK_Set;
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   51F48061           ORRS     R1,R1,#0x400
   \   0000000C   0180               STRH     R1,[R0, #+0]
   \   0000000E   03E0               B.N      ??I2C_AcknowledgeConfig_1
    433            }
    434            else
    435            {
    436              /* Disable the acknowledgement */
    437              I2Cx->CR1 &= CR1_ACK_Reset;
   \                     ??I2C_AcknowledgeConfig_0:
   \   00000010   0188               LDRH     R1,[R0, #+0]
   \   00000012   31F48061           BICS     R1,R1,#0x400
   \   00000016   0180               STRH     R1,[R0, #+0]
    438            }
    439          }
   \                     ??I2C_AcknowledgeConfig_1:
   \   00000018   7047               BX       LR               ;; return
    440          
    441          /*******************************************************************************
    442          * Function Name  : I2C_OwnAddress2Config
    443          * Description    : Configures the specified I2C own address2.
    444          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    445          *                  - Address: specifies the 7bit I2C own address2.
    446          * Output         : None
    447          * Return         : None.
    448          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    449          void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, u8 Address)
    450          {
    451            u16 tmpreg = 0;
   \                     I2C_OwnAddress2Config:
   \   00000000   0022               MOVS     R2,#+0
    452          
    453            /* Check the parameters */
    454            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    455          
    456            /* Get the old register value */
    457            tmpreg = I2Cx->OAR2;
   \   00000002   8389               LDRH     R3,[R0, #+12]
   \   00000004   1A00               MOVS     R2,R3
    458            /* Reset I2Cx Own address2 bit [7:1] */
    459            tmpreg &= OAR2_ADD2_Reset;
   \   00000006   4FF60173           MOVW     R3,#+65281
   \   0000000A   1A40               ANDS     R2,R3,R2
    460            /* Set I2Cx Own address2 */
    461            tmpreg |= (u16)(Address & (u16)0x00FE);
   \   0000000C   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   11F0FE01           ANDS     R1,R1,#0xFE
   \   00000012   0A43               ORRS     R2,R1,R2
    462            /* Store the new register value */
    463            I2Cx->OAR2 = tmpreg;
   \   00000014   8281               STRH     R2,[R0, #+12]
    464          }
   \   00000016   7047               BX       LR               ;; return
    465          
    466          /*******************************************************************************
    467          * Function Name  : I2C_DualAddressCmd
    468          * Description    : Enables or disables the specified I2C dual addressing mode.
    469          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    470          *                  - NewState: new state of the I2C dual addressing mode.
    471          *                    This parameter can be: ENABLE or DISABLE.
    472          * Output         : None
    473          * Return         : None
    474          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    475          void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    476          {
    477            /* Check the parameters */
    478            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    479            assert_param(IS_FUNCTIONAL_STATE(NewState));
    480          
    481            if (NewState != DISABLE)
   \                     I2C_DualAddressCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??I2C_DualAddressCmd_0
    482            {
    483              /* Enable dual addressing mode */
    484              I2Cx->OAR2 |= OAR2_ENDUAL_Set;
   \   00000006   8189               LDRH     R1,[R0, #+12]
   \   00000008   51F00101           ORRS     R1,R1,#0x1
   \   0000000C   8181               STRH     R1,[R0, #+12]
   \   0000000E   03E0               B.N      ??I2C_DualAddressCmd_1
    485            }
    486            else
    487            {
    488              /* Disable dual addressing mode */
    489              I2Cx->OAR2 &= OAR2_ENDUAL_Reset;
   \                     ??I2C_DualAddressCmd_0:
   \   00000010   8189               LDRH     R1,[R0, #+12]
   \   00000012   31F00101           BICS     R1,R1,#0x1
   \   00000016   8181               STRH     R1,[R0, #+12]
    490            }
    491          }
   \                     ??I2C_DualAddressCmd_1:
   \   00000018   7047               BX       LR               ;; return
    492          
    493          /*******************************************************************************
    494          * Function Name  : I2C_GeneralCallCmd
    495          * Description    : Enables or disables the specified I2C general call feature.
    496          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    497          *                  - NewState: new state of the I2C General call.
    498          *                    This parameter can be: ENABLE or DISABLE.
    499          * Output         : None
    500          * Return         : None
    501          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    502          void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    503          {
    504            /* Check the parameters */
    505            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    506            assert_param(IS_FUNCTIONAL_STATE(NewState));
    507          
    508            if (NewState != DISABLE)
   \                     I2C_GeneralCallCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??I2C_GeneralCallCmd_0
    509            {
    510              /* Enable generall call */
    511              I2Cx->CR1 |= CR1_ENGC_Set;
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   51F04001           ORRS     R1,R1,#0x40
   \   0000000C   0180               STRH     R1,[R0, #+0]
   \   0000000E   03E0               B.N      ??I2C_GeneralCallCmd_1
    512            }
    513            else
    514            {
    515              /* Disable generall call */
    516              I2Cx->CR1 &= CR1_ENGC_Reset;
   \                     ??I2C_GeneralCallCmd_0:
   \   00000010   0188               LDRH     R1,[R0, #+0]
   \   00000012   31F04001           BICS     R1,R1,#0x40
   \   00000016   0180               STRH     R1,[R0, #+0]
    517            }
    518          }
   \                     ??I2C_GeneralCallCmd_1:
   \   00000018   7047               BX       LR               ;; return
    519          
    520          /*******************************************************************************
    521          * Function Name  : I2C_ITConfig
    522          * Description    : Enables or disables the specified I2C interrupts.
    523          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    524          *                  - I2C_IT: specifies the I2C interrupts sources to be enabled
    525          *                    or disabled. 
    526          *                    This parameter can be any combination of the following values:
    527          *                       - I2C_IT_BUF: Buffer interrupt mask
    528          *                       - I2C_IT_EVT: Event interrupt mask
    529          *                       - I2C_IT_ERR: Error interrupt mask
    530          *                  - NewState: new state of the specified I2C interrupts.
    531          *                    This parameter can be: ENABLE or DISABLE.
    532          * Output         : None
    533          * Return         : None
    534          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    535          void I2C_ITConfig(I2C_TypeDef* I2Cx, u16 I2C_IT, FunctionalState NewState)
    536          {
    537            /* Check the parameters */
    538            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    539            assert_param(IS_FUNCTIONAL_STATE(NewState));
    540            assert_param(IS_I2C_CONFIG_IT(I2C_IT));
    541            
    542            if (NewState != DISABLE)
   \                     I2C_ITConfig:
   \   00000000   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   002A               CMP      R2,#+0
   \   00000004   03D0               BEQ.N    ??I2C_ITConfig_0
    543            {
    544              /* Enable the selected I2C interrupts */
    545              I2Cx->CR2 |= I2C_IT;
   \   00000006   8288               LDRH     R2,[R0, #+4]
   \   00000008   1143               ORRS     R1,R1,R2
   \   0000000A   8180               STRH     R1,[R0, #+4]
   \   0000000C   03E0               B.N      ??I2C_ITConfig_1
    546            }
    547            else
    548            {
    549              /* Disable the selected I2C interrupts */
    550              I2Cx->CR2 &= (u16)~I2C_IT;
   \                     ??I2C_ITConfig_0:
   \   0000000E   8288               LDRH     R2,[R0, #+4]
   \   00000010   C943               MVNS     R1,R1
   \   00000012   1140               ANDS     R1,R1,R2
   \   00000014   8180               STRH     R1,[R0, #+4]
    551            }
    552          }
   \                     ??I2C_ITConfig_1:
   \   00000016   7047               BX       LR               ;; return
    553          
    554          /*******************************************************************************
    555          * Function Name  : I2C_SendData
    556          * Description    : Sends a data byte through the I2Cx peripheral.
    557          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    558          *                  - Data: Byte to be transmitted..
    559          * Output         : None
    560          * Return         : None
    561          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    562          void I2C_SendData(I2C_TypeDef* I2Cx, u8 Data)
    563          {
    564            /* Check the parameters */
    565            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    566          
    567            /* Write in the DR register the data to be sent */
    568            I2Cx->DR = Data;
   \                     I2C_SendData:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0182               STRH     R1,[R0, #+16]
    569          }
   \   00000004   7047               BX       LR               ;; return
    570          
    571          /*******************************************************************************
    572          * Function Name  : I2C_ReceiveData
    573          * Description    : Returns the most recent received data by the I2Cx peripheral.
    574          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    575          * Output         : None
    576          * Return         : The value of the received data.
    577          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    578          u8 I2C_ReceiveData(I2C_TypeDef* I2Cx)
    579          {
    580            /* Check the parameters */
    581            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    582          
    583            /* Return the data in the DR register */
    584            return (u8)I2Cx->DR;
   \                     I2C_ReceiveData:
   \   00000000   008A               LDRH     R0,[R0, #+16]
   \   00000002   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   7047               BX       LR               ;; return
    585          }
    586          
    587          /*******************************************************************************
    588          * Function Name  : I2C_Send7bitAddress
    589          * Description    : Transmits the address byte to select the slave device.
    590          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    591          *                  - Address: specifies the slave address which will be transmitted
    592          *                  - I2C_Direction: specifies whether the I2C device will be a
    593          *                    Transmitter or a Receiver. 
    594          *                    This parameter can be one of the following values
    595          *                       - I2C_Direction_Transmitter: Transmitter mode
    596          *                       - I2C_Direction_Receiver: Receiver mode
    597          * Output         : None
    598          * Return         : None.
    599          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    600          void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, u8 Address, u8 I2C_Direction)
    601          {
    602            /* Check the parameters */
    603            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    604            assert_param(IS_I2C_DIRECTION(I2C_Direction));
    605          
    606            /* Test on the direction to set/reset the read/write bit */
    607            if (I2C_Direction != I2C_Direction_Transmitter)
   \                     I2C_Send7bitAddress:
   \   00000000   D2B2               UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   002A               CMP      R2,#+0
   \   00000004   02D0               BEQ.N    ??I2C_Send7bitAddress_0
    608            {
    609              /* Set the address bit0 for read */
    610              Address |= OAR1_ADD0_Set;
   \   00000006   51F00101           ORRS     R1,R1,#0x1
   \   0000000A   01E0               B.N      ??I2C_Send7bitAddress_1
    611            }
    612            else
    613            {
    614              /* Reset the address bit0 for write */
    615              Address &= OAR1_ADD0_Reset;
   \                     ??I2C_Send7bitAddress_0:
   \   0000000C   11F0FE01           ANDS     R1,R1,#0xFE
    616            }
    617            /* Send the address */
    618            I2Cx->DR = Address;
   \                     ??I2C_Send7bitAddress_1:
   \   00000010   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0182               STRH     R1,[R0, #+16]
    619          }
   \   00000014   7047               BX       LR               ;; return
    620          
    621          /*******************************************************************************
    622          * Function Name  : I2C_ReadRegister
    623          * Description    : Reads the specified I2C register and returns its value.
    624          * Input1         : - I2C_Register: specifies the register to read.
    625          *                    This parameter can be one of the following values:
    626          *                       - I2C_Register_CR1:  CR1 register.
    627          *                       - I2C_Register_CR2:   CR2 register.
    628          *                       - I2C_Register_OAR1:  OAR1 register.
    629          *                       - I2C_Register_OAR2:  OAR2 register.
    630          *                       - I2C_Register_DR:    DR register.
    631          *                       - I2C_Register_SR1:   SR1 register.
    632          *                       - I2C_Register_SR2:   SR2 register.
    633          *                       - I2C_Register_CCR:   CCR register.
    634          *                       - I2C_Register_TRISE: TRISE register.
    635          * Output         : None
    636          * Return         : The value of the read register.
    637          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    638          u16 I2C_ReadRegister(I2C_TypeDef* I2Cx, u8 I2C_Register)
    639          {
    640            /* Check the parameters */
    641            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    642            assert_param(IS_I2C_REGISTER(I2C_Register));
    643          
    644            /* Return the selected register value */
    645            return (*(vu16 *)(*((vu32 *)&I2Cx) + I2C_Register));
   \                     I2C_ReadRegister:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   085A               LDRH     R0,[R1, R0]
   \   00000004   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000006   7047               BX       LR               ;; return
    646          }
    647          
    648          /*******************************************************************************
    649          * Function Name  : I2C_SoftwareResetCmd
    650          * Description    : Enables or disables the specified I2C software reset.
    651          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    652          *                  - NewState: new state of the I2C software reset.
    653          *                    This parameter can be: ENABLE or DISABLE.
    654          * Output         : None
    655          * Return         : None
    656          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    657          void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    658          {
    659            /* Check the parameters */
    660            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    661            assert_param(IS_FUNCTIONAL_STATE(NewState));
    662          
    663            if (NewState != DISABLE)
   \                     I2C_SoftwareResetCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??I2C_SoftwareResetCmd_0
    664            {
    665              /* Peripheral under reset */
    666              I2Cx->CR1 |= CR1_SWRST_Set;
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   51F40041           ORRS     R1,R1,#0x8000
   \   0000000C   0180               STRH     R1,[R0, #+0]
   \   0000000E   03E0               B.N      ??I2C_SoftwareResetCmd_1
    667            }
    668            else
    669            {
    670              /* Peripheral not under reset */
    671              I2Cx->CR1 &= CR1_SWRST_Reset;
   \                     ??I2C_SoftwareResetCmd_0:
   \   00000010   0188               LDRH     R1,[R0, #+0]
   \   00000012   4904               LSLS     R1,R1,#+17
   \   00000014   490C               LSRS     R1,R1,#+17
   \   00000016   0180               STRH     R1,[R0, #+0]
    672            }
    673          }
   \                     ??I2C_SoftwareResetCmd_1:
   \   00000018   7047               BX       LR               ;; return
    674          
    675          /*******************************************************************************
    676          * Function Name  : I2C_SMBusAlertConfig
    677          * Description    : Drives the SMBusAlert pin high or low for the specified I2C.
    678          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    679          *                  - I2C_SMBusAlert: specifies SMBAlert pin level. 
    680          *                    This parameter can be one of the following values:
    681          *                       - I2C_SMBusAlert_Low: SMBAlert pin driven low
    682          *                       - I2C_SMBusAlert_High: SMBAlert pin driven high
    683          * Output         : None
    684          * Return         : None
    685          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    686          void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, u16 I2C_SMBusAlert)
    687          {
    688            /* Check the parameters */
    689            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    690            assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
    691          
    692            if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
   \                     I2C_SMBusAlertConfig:
   \   00000000   4FF40052           MOV      R2,#+8192
   \   00000004   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   9142               CMP      R1,R2
   \   00000008   04D1               BNE.N    ??I2C_SMBusAlertConfig_0
    693            {
    694              /* Drive the SMBusAlert pin Low */
    695              I2Cx->CR1 |= I2C_SMBusAlert_Low;
   \   0000000A   0188               LDRH     R1,[R0, #+0]
   \   0000000C   51F40051           ORRS     R1,R1,#0x2000
   \   00000010   0180               STRH     R1,[R0, #+0]
   \   00000012   03E0               B.N      ??I2C_SMBusAlertConfig_1
    696            }
    697            else
    698            {
    699              /* Drive the SMBusAlert pin High  */
    700              I2Cx->CR1 &= I2C_SMBusAlert_High;
   \                     ??I2C_SMBusAlertConfig_0:
   \   00000014   0188               LDRH     R1,[R0, #+0]
   \   00000016   31F40051           BICS     R1,R1,#0x2000
   \   0000001A   0180               STRH     R1,[R0, #+0]
    701            }
    702          }
   \                     ??I2C_SMBusAlertConfig_1:
   \   0000001C   7047               BX       LR               ;; return
    703          
    704          /*******************************************************************************
    705          * Function Name  : I2C_TransmitPEC
    706          * Description    : Enables or disables the specified I2C PEC transfer.
    707          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    708          *                  - NewState: new state of the I2C PEC transmission.
    709          *                    This parameter can be: ENABLE or DISABLE.
    710          * Output         : None
    711          * Return         : None
    712          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    713          void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
    714          {
    715            /* Check the parameters */
    716            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    717            assert_param(IS_FUNCTIONAL_STATE(NewState));
    718          
    719            if (NewState != DISABLE)
   \                     I2C_TransmitPEC:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??I2C_TransmitPEC_0
    720            {
    721              /* Enable the selected I2C PEC transmission */
    722              I2Cx->CR1 |= CR1_PEC_Set;
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   51F48051           ORRS     R1,R1,#0x1000
   \   0000000C   0180               STRH     R1,[R0, #+0]
   \   0000000E   03E0               B.N      ??I2C_TransmitPEC_1
    723            }
    724            else
    725            {
    726              /* Disable the selected I2C PEC transmission */
    727              I2Cx->CR1 &= CR1_PEC_Reset;
   \                     ??I2C_TransmitPEC_0:
   \   00000010   0188               LDRH     R1,[R0, #+0]
   \   00000012   31F48051           BICS     R1,R1,#0x1000
   \   00000016   0180               STRH     R1,[R0, #+0]
    728            }
    729          }
   \                     ??I2C_TransmitPEC_1:
   \   00000018   7047               BX       LR               ;; return
    730          
    731          /*******************************************************************************
    732          * Function Name  : I2C_PECPositionConfig
    733          * Description    : Selects the specified I2C PEC position.
    734          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    735          *                  - I2C_PECPosition: specifies the PEC position. 
    736          *                    This parameter can be one of the following values:
    737          *                       - I2C_PECPosition_Next: indicates that the next
    738          *                         byte is PEC
    739          *                       - I2C_PECPosition_Current: indicates that current
    740          *                         byte is PEC
    741          * Output         : None
    742          * Return         : None
    743          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    744          void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, u16 I2C_PECPosition)
    745          {
    746            /* Check the parameters */
    747            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    748            assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
    749          
    750            if (I2C_PECPosition == I2C_PECPosition_Next)
   \                     I2C_PECPositionConfig:
   \   00000000   4FF40062           MOV      R2,#+2048
   \   00000004   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   9142               CMP      R1,R2
   \   00000008   04D1               BNE.N    ??I2C_PECPositionConfig_0
    751            {
    752              /* Next byte in shift register is PEC */
    753              I2Cx->CR1 |= I2C_PECPosition_Next;
   \   0000000A   0188               LDRH     R1,[R0, #+0]
   \   0000000C   51F40061           ORRS     R1,R1,#0x800
   \   00000010   0180               STRH     R1,[R0, #+0]
   \   00000012   03E0               B.N      ??I2C_PECPositionConfig_1
    754            }
    755            else
    756            {
    757              /* Current byte in shift register is PEC */
    758              I2Cx->CR1 &= I2C_PECPosition_Current;
   \                     ??I2C_PECPositionConfig_0:
   \   00000014   0188               LDRH     R1,[R0, #+0]
   \   00000016   31F40061           BICS     R1,R1,#0x800
   \   0000001A   0180               STRH     R1,[R0, #+0]
    759            }
    760          }
   \                     ??I2C_PECPositionConfig_1:
   \   0000001C   7047               BX       LR               ;; return
    761          
    762          /*******************************************************************************
    763          * Function Name  : I2C_CalculatePEC
    764          * Description    : Enables or disables the PEC value calculation of the
    765          *                  transfered bytes.
    766          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    767          *                  - NewState: new state of the I2Cx PEC value calculation.
    768          *                    This parameter can be: ENABLE or DISABLE.
    769          * Output         : None
    770          * Return         : None
    771          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    772          void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
    773          {
    774            /* Check the parameters */
    775            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    776            assert_param(IS_FUNCTIONAL_STATE(NewState));
    777          
    778            if (NewState != DISABLE)
   \                     I2C_CalculatePEC:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??I2C_CalculatePEC_0
    779            {
    780              /* Enable the selected I2C PEC calculation */
    781              I2Cx->CR1 |= CR1_ENPEC_Set;
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   51F02001           ORRS     R1,R1,#0x20
   \   0000000C   0180               STRH     R1,[R0, #+0]
   \   0000000E   03E0               B.N      ??I2C_CalculatePEC_1
    782            }
    783            else
    784            {
    785              /* Disable the selected I2C PEC calculation */
    786              I2Cx->CR1 &= CR1_ENPEC_Reset;
   \                     ??I2C_CalculatePEC_0:
   \   00000010   0188               LDRH     R1,[R0, #+0]
   \   00000012   31F02001           BICS     R1,R1,#0x20
   \   00000016   0180               STRH     R1,[R0, #+0]
    787            }
    788          }
   \                     ??I2C_CalculatePEC_1:
   \   00000018   7047               BX       LR               ;; return
    789          
    790          /*******************************************************************************
    791          * Function Name  : I2C_GetPEC
    792          * Description    : Returns the PEC value for the specified I2C.
    793          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    794          * Output         : None
    795          * Return         : The PEC value.
    796          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    797          u8 I2C_GetPEC(I2C_TypeDef* I2Cx)
    798          {
    799            /* Check the parameters */
    800            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    801          
    802            /* Return the selected I2C PEC value */
    803            return ((I2Cx->SR2) >> 8);
   \                     I2C_GetPEC:
   \   00000000   008B               LDRH     R0,[R0, #+24]
   \   00000002   80B2               UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   000A               LSRS     R0,R0,#+8
   \   00000006   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   7047               BX       LR               ;; return
    804          }
    805          
    806          /*******************************************************************************
    807          * Function Name  : I2C_ARPCmd
    808          * Description    : Enables or disables the specified I2C ARP.
    809          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    810          *                  - NewState: new state of the I2Cx ARP. 
    811          *                    This parameter can be: ENABLE or DISABLE.
    812          * Output         : None
    813          * Return         : None
    814          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    815          void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    816          {
    817            /* Check the parameters */
    818            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    819            assert_param(IS_FUNCTIONAL_STATE(NewState));
    820          
    821            if (NewState != DISABLE)
   \                     I2C_ARPCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D0               BEQ.N    ??I2C_ARPCmd_0
    822            {
    823              /* Enable the selected I2C ARP */
    824              I2Cx->CR1 |= CR1_ENARP_Set;
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   51F01001           ORRS     R1,R1,#0x10
   \   0000000C   0180               STRH     R1,[R0, #+0]
   \   0000000E   03E0               B.N      ??I2C_ARPCmd_1
    825            }
    826            else
    827            {
    828              /* Disable the selected I2C ARP */
    829              I2Cx->CR1 &= CR1_ENARP_Reset;
   \                     ??I2C_ARPCmd_0:
   \   00000010   0188               LDRH     R1,[R0, #+0]
   \   00000012   31F01001           BICS     R1,R1,#0x10
   \   00000016   0180               STRH     R1,[R0, #+0]
    830            }
    831          }
   \                     ??I2C_ARPCmd_1:
   \   00000018   7047               BX       LR               ;; return
    832          
    833          /*******************************************************************************
    834          * Function Name  : I2C_StretchClockCmd
    835          * Description    : Enables or disables the specified I2C Clock stretching.
    836          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    837          *                  - NewState: new state of the I2Cx Clock stretching.
    838          *                    This parameter can be: ENABLE or DISABLE.
    839          * Output         : None
    840          * Return         : None
    841          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    842          void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    843          {
    844            /* Check the parameters */
    845            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    846            assert_param(IS_FUNCTIONAL_STATE(NewState));
    847          
    848            if (NewState == DISABLE)
   \                     I2C_StretchClockCmd:
   \   00000000   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0029               CMP      R1,#+0
   \   00000004   04D1               BNE.N    ??I2C_StretchClockCmd_0
    849            {
    850              /* Enable the selected I2C Clock stretching */
    851              I2Cx->CR1 |= CR1_NOSTRETCH_Set;
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   51F08001           ORRS     R1,R1,#0x80
   \   0000000C   0180               STRH     R1,[R0, #+0]
   \   0000000E   03E0               B.N      ??I2C_StretchClockCmd_1
    852            }
    853            else
    854            {
    855              /* Disable the selected I2C Clock stretching */
    856              I2Cx->CR1 &= CR1_NOSTRETCH_Reset;
   \                     ??I2C_StretchClockCmd_0:
   \   00000010   0188               LDRH     R1,[R0, #+0]
   \   00000012   31F08001           BICS     R1,R1,#0x80
   \   00000016   0180               STRH     R1,[R0, #+0]
    857            }
    858          }
   \                     ??I2C_StretchClockCmd_1:
   \   00000018   7047               BX       LR               ;; return
    859          
    860          /*******************************************************************************
    861          * Function Name  : I2C_FastModeDutyCycleConfig
    862          * Description    : Selects the specified I2C fast mode duty cycle.
    863          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    864          *                  - I2C_DutyCycle: specifies the fast mode duty cycle.
    865          *                    This parameter can be one of the following values:
    866          *                       - I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2
    867          *                       - I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9
    868          * Output         : None
    869          * Return         : None
    870          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    871          void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, u16 I2C_DutyCycle)
    872          {
    873            /* Check the parameters */
    874            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    875            assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
    876          
    877            if (I2C_DutyCycle != I2C_DutyCycle_16_9)
   \                     I2C_FastModeDutyCycleConfig:
   \   00000000   4FF48042           MOV      R2,#+16384
   \   00000004   89B2               UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   9142               CMP      R1,R2
   \   00000008   04D0               BEQ.N    ??I2C_FastModeDutyCycleConfig_0
    878            {
    879              /* I2C fast mode Tlow/Thigh=2 */
    880              I2Cx->CCR &= I2C_DutyCycle_2;
   \   0000000A   818B               LDRH     R1,[R0, #+28]
   \   0000000C   31F48041           BICS     R1,R1,#0x4000
   \   00000010   8183               STRH     R1,[R0, #+28]
   \   00000012   03E0               B.N      ??I2C_FastModeDutyCycleConfig_1
    881            }
    882            else
    883            {
    884              /* I2C fast mode Tlow/Thigh=16/9 */
    885              I2Cx->CCR |= I2C_DutyCycle_16_9;
   \                     ??I2C_FastModeDutyCycleConfig_0:
   \   00000014   818B               LDRH     R1,[R0, #+28]
   \   00000016   51F48041           ORRS     R1,R1,#0x4000
   \   0000001A   8183               STRH     R1,[R0, #+28]
    886            }
    887          }
   \                     ??I2C_FastModeDutyCycleConfig_1:
   \   0000001C   7047               BX       LR               ;; return
    888          
    889          /*******************************************************************************
    890          * Function Name  : I2C_GetLastEvent
    891          * Description    : Returns the last I2Cx Event.
    892          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    893          * Output         : None
    894          * Return         : The last event
    895          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    896          u32 I2C_GetLastEvent(I2C_TypeDef* I2Cx)
    897          {
   \                     I2C_GetLastEvent:
   \   00000000   18B4               PUSH     {R3,R4}
   \   00000002   0100               MOVS     R1,R0
    898            u32 lastevent = 0;
   \   00000004   0020               MOVS     R0,#+0
    899            u32 flag1 = 0, flag2 = 0;
   \   00000006   0022               MOVS     R2,#+0
   \   00000008   0023               MOVS     R3,#+0
    900          
    901            /* Check the parameters */
    902            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    903          
    904            /* Read the I2Cx status register */
    905            flag1 = I2Cx->SR1;
   \   0000000A   8C8A               LDRH     R4,[R1, #+20]
   \   0000000C   2200               MOVS     R2,R4
    906            flag2 = I2Cx->SR2;
   \   0000000E   098B               LDRH     R1,[R1, #+24]
   \   00000010   0B00               MOVS     R3,R1
    907            flag2 = flag2 << 16;
   \   00000012   1B04               LSLS     R3,R3,#+16
    908          
    909            /* Get the last event value from I2C status register */
    910            lastevent = (flag1 | flag2) & FLAG_Mask;
   \   00000014   53EA0201           ORRS     R1,R3,R2
   \   00000018   0902               LSLS     R1,R1,#+8
   \   0000001A   090A               LSRS     R1,R1,#+8
   \   0000001C   0800               MOVS     R0,R1
    911          
    912            /* Return status */
    913            return lastevent;
   \   0000001E   12BC               POP      {R1,R4}
   \   00000020   7047               BX       LR               ;; return
    914          }
    915          
    916          /*******************************************************************************
    917          * Function Name  : I2C_CheckEvent
    918          * Description    : Checks whether the last I2Cx Event is equal to the one passed
    919          *                  as parameter.
    920          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    921          *                  - I2C_EVENT: specifies the event to be checked. 
    922          *                    This parameter can be one of the following values:
    923          *                       - I2C_EVENT_SLAVE_ADDRESS_MATCHED   : EV1
    924          *                       - I2C_EVENT_SLAVE_BYTE_RECEIVED     : EV2
    925          *                       - I2C_EVENT_SLAVE_BYTE_TRANSMITTED  : EV3
    926          *                       - I2C_EVENT_SLAVE_ACK_FAILURE       : EV3-2
    927          *                       - I2C_EVENT_MASTER_MODE_SELECT      : EV5
    928          *                       - I2C_EVENT_MASTER_MODE_SELECTED    : EV6
    929          *                       - I2C_EVENT_MASTER_BYTE_RECEIVED    : EV7
    930          *                       - I2C_EVENT_MASTER_BYTE_TRANSMITTED : EV8
    931          *                       - I2C_EVENT_MASTER_MODE_ADDRESS10   : EV9
    932          *                       - I2C_EVENT_SLAVE_STOP_DETECTED     : EV4
    933          * Output         : None
    934          * Return         : An ErrorStatus enumuration value:
    935          *                       - SUCCESS: Last event is equal to the I2C_EVENT
    936          *                       - ERROR: Last event is different from the I2C_EVENT
    937          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    938          ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, u32 I2C_EVENT)
    939          {
   \                     I2C_CheckEvent:
   \   00000000   78B4               PUSH     {R3-R6}
   \   00000002   0200               MOVS     R2,R0
    940            u32 lastevent = 0;
   \   00000004   0023               MOVS     R3,#+0
    941            u32 flag1 = 0, flag2 = 0;
   \   00000006   0024               MOVS     R4,#+0
   \   00000008   0025               MOVS     R5,#+0
    942            ErrorStatus status = ERROR;
   \   0000000A   0020               MOVS     R0,#+0
    943          
    944            /* Check the parameters */
    945            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    946            assert_param(IS_I2C_EVENT(I2C_EVENT));
    947          
    948            /* Read the I2Cx status register */
    949            flag1 = I2Cx->SR1;
   \   0000000C   968A               LDRH     R6,[R2, #+20]
   \   0000000E   3400               MOVS     R4,R6
    950            flag2 = I2Cx->SR2;
   \   00000010   128B               LDRH     R2,[R2, #+24]
   \   00000012   1500               MOVS     R5,R2
    951            flag2 = flag2 << 16;
   \   00000014   2D04               LSLS     R5,R5,#+16
    952          
    953            /* Get the last event value from I2C status register */
    954            lastevent = (flag1 | flag2) & FLAG_Mask;
   \   00000016   55EA0402           ORRS     R2,R5,R4
   \   0000001A   1202               LSLS     R2,R2,#+8
   \   0000001C   120A               LSRS     R2,R2,#+8
   \   0000001E   1300               MOVS     R3,R2
    955          
    956            /* Check whether the last event is equal to I2C_EVENT */
    957            if (lastevent == I2C_EVENT )
   \   00000020   8B42               CMP      R3,R1
   \   00000022   01D1               BNE.N    ??I2C_CheckEvent_0
    958            {
    959              /* SUCCESS: last event is equal to I2C_EVENT */
    960              status = SUCCESS;
   \   00000024   0120               MOVS     R0,#+1
   \   00000026   00E0               B.N      ??I2C_CheckEvent_1
    961            }
    962            else
    963            {
    964              /* ERROR: last event is different from I2C_EVENT */
    965              status = ERROR;
   \                     ??I2C_CheckEvent_0:
   \   00000028   0020               MOVS     R0,#+0
    966            }
    967          
    968            /* Return status */
    969            return status;
   \                     ??I2C_CheckEvent_1:
   \   0000002A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   72BC               POP      {R1,R4-R6}
   \   0000002E   7047               BX       LR               ;; return
    970          }
    971          
    972          /*******************************************************************************
    973          * Function Name  : I2C_GetFlagStatus
    974          * Description    : Checks whether the specified I2C flag is set or not.
    975          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    976          *                  - I2C_FLAG: specifies the flag to check. 
    977          *                    This parameter can be one of the following values:
    978          *                       - I2C_FLAG_DUALF: Dual flag (Slave mode)
    979          *                       - I2C_FLAG_SMBHOST: SMBus host header (Slave mode)
    980          *                       - I2C_FLAG_SMBDEFAULT: SMBus default header (Slave mode)
    981          *                       - I2C_FLAG_GENCALL: General call header flag (Slave mode)
    982          *                       - I2C_FLAG_TRA: Transmitter/Receiver flag
    983          *                       - I2C_FLAG_BUSY: Bus busy flag
    984          *                       - I2C_FLAG_MSL: Master/Slave flag
    985          *                       - I2C_FLAG_SMBALERT: SMBus Alert flag
    986          *                       - I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
    987          *                       - I2C_FLAG_PECERR: PEC error in reception flag
    988          *                       - I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
    989          *                       - I2C_FLAG_AF: Acknowledge failure flag
    990          *                       - I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
    991          *                       - I2C_FLAG_BERR: Bus error flag
    992          *                       - I2C_FLAG_TXE: Data register empty flag (Transmitter)
    993          *                       - I2C_FLAG_RXNE: Data register not empty (Receiver) flag
    994          *                       - I2C_FLAG_STOPF: Stop detection flag (Slave mode)
    995          *                       - I2C_FLAG_ADD10: 10-bit header sent flag (Master mode)
    996          *                       - I2C_FLAG_BTF: Byte transfer finished flag
    997          *                       - I2C_FLAG_ADDR: Address sent flag (Master mode) ADSL
    998          *                                        Address matched flag (Slave mode)ENDAD
    999          *                       - I2C_FLAG_SB: Start bit flag (Master mode)
   1000          * Output         : None
   1001          * Return         : The new state of I2C_FLAG (SET or RESET).
   1002          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1003          FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, u32 I2C_FLAG)
   1004          {
   \                     I2C_GetFlagStatus:
   \   00000000   78B4               PUSH     {R3-R6}
   \   00000002   0200               MOVS     R2,R0
   1005            FlagStatus bitstatus = RESET;
   \   00000004   0020               MOVS     R0,#+0
   1006            u32 i2cstatus = 0;
   \   00000006   0023               MOVS     R3,#+0
   1007            u32 flag1 = 0, flag2 = 0;
   \   00000008   0024               MOVS     R4,#+0
   \   0000000A   0025               MOVS     R5,#+0
   1008          
   1009            /* Check the parameters */
   1010            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1011            assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
   1012          
   1013            /* Read the I2Cx status register */
   1014            flag1 = I2Cx->SR1;
   \   0000000C   968A               LDRH     R6,[R2, #+20]
   \   0000000E   3400               MOVS     R4,R6
   1015            flag2 = I2Cx->SR2;
   \   00000010   128B               LDRH     R2,[R2, #+24]
   \   00000012   1500               MOVS     R5,R2
   1016            flag2 = (flag2 & FLAG_Mask) << 16;
   \   00000014   2D04               LSLS     R5,R5,#+16
   1017          
   1018            /* Get the I2C status value */
   1019            i2cstatus = flag1 | flag2;
   \   00000016   55EA0402           ORRS     R2,R5,R4
   \   0000001A   1300               MOVS     R3,R2
   1020          
   1021            /* Get bit[23:0] of the flag */
   1022            I2C_FLAG &= FLAG_Mask;
   \   0000001C   0902               LSLS     R1,R1,#+8
   \   0000001E   090A               LSRS     R1,R1,#+8
   1023          
   1024            /* Check the status of the specified I2C flag */
   1025            if ((i2cstatus & I2C_FLAG) != (u32)RESET)
   \   00000020   1940               ANDS     R1,R1,R3
   \   00000022   491E               SUBS     R1,R1,#+1
   \   00000024   8941               SBCS     R1,R1,R1
   \   00000026   C943               MVNS     R1,R1
   \   00000028   C90F               LSRS     R1,R1,#+31
   \   0000002A   0800               MOVS     R0,R1
   1026            {
   1027              /* I2C_FLAG is set */
   1028              bitstatus = SET;
   1029            }
   1030            else
   1031            {
   1032              /* I2C_FLAG is reset */
   1033              bitstatus = RESET;
   1034            }
   1035            /* Return the I2C_FLAG status */
   1036            return  bitstatus;
   \   0000002C   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   72BC               POP      {R1,R4-R6}
   \   00000030   7047               BX       LR               ;; return
   1037          }
   1038          
   1039          /*******************************************************************************
   1040          * Function Name  : I2C_ClearFlag
   1041          * Description    : Clears the I2Cx's pending flags.
   1042          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
   1043          *                  - I2C_FLAG: specifies the flag to clear. 
   1044          *                    This parameter can be one of the following values:
   1045          *                       - I2C_FLAG_SMBALERT: SMBus Alert flag
   1046          *                       - I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
   1047          *                       - I2C_FLAG_PECERR: PEC error in reception flag
   1048          *                       - I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
   1049          *                       - I2C_FLAG_AF: Acknowledge failure flag
   1050          *                       - I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
   1051          *                       - I2C_FLAG_BERR: Bus error flag
   1052          *                       - I2C_FLAG_STOPF: Stop detection flag (Slave mode)
   1053          *                       - I2C_FLAG_ADD10: 10-bit header sent flag (Master mode)
   1054          *                       - I2C_FLAG_BTF: Byte transfer finished flag
   1055          *                       - I2C_FLAG_ADDR: Address sent flag (Master mode) ADSL
   1056          *                                        Address matched flag (Slave mode)ENDAD
   1057          *                       - I2C_FLAG_SB: Start bit flag (Master mode)
   1058          * Output         : None
   1059          * Return         : None
   1060          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1061          void I2C_ClearFlag(I2C_TypeDef* I2Cx, u32 I2C_FLAG)
   1062          {
   \                     I2C_ClearFlag:
   \   00000000   18B4               PUSH     {R3,R4}
   1063            u32 flagpos = 0;
   \   00000002   0022               MOVS     R2,#+0
   1064            u32 flagindex = 0;
   \   00000004   0023               MOVS     R3,#+0
   1065          
   1066            /* Check the parameters */
   1067            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1068            assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
   1069          
   1070            /* Get the I2C flag position */
   1071            flagpos = I2C_FLAG & FLAG_Mask;
   \   00000006   0C02               LSLS     R4,R1,#+8
   \   00000008   240A               LSRS     R4,R4,#+8
   \   0000000A   2200               MOVS     R2,R4
   1072          
   1073            /* Get the I2C flag index */
   1074            flagindex = I2C_FLAG >> 28;
   \   0000000C   090F               LSRS     R1,R1,#+28
   \   0000000E   0B00               MOVS     R3,R1
   1075          
   1076            /* Clear the flag by writing 0 */
   1077            if (flagindex == 1)
   \   00000010   012B               CMP      R3,#+1
   \   00000012   02D1               BNE.N    ??I2C_ClearFlag_0
   1078            {
   1079              /* Clear the selected I2C flag */
   1080              I2Cx->SR1 = (u16)~flagpos;
   \   00000014   D143               MVNS     R1,R2
   \   00000016   8182               STRH     R1,[R0, #+20]
   \   00000018   0DE0               B.N      ??I2C_ClearFlag_1
   1081            }
   1082            /* Flags that need a read of the SR1 register to be cleared */
   1083            else if (flagindex == 2)
   \                     ??I2C_ClearFlag_0:
   \   0000001A   022B               CMP      R3,#+2
   \   0000001C   01D1               BNE.N    ??I2C_ClearFlag_2
   1084            {
   1085              /* Read the SR1 register */
   1086              (void)I2Cx->SR1;
   \   0000001E   808A               LDRH     R0,[R0, #+20]
   \   00000020   09E0               B.N      ??I2C_ClearFlag_3
   1087            }
   1088            /* Flags that need a read of SR1 and a write on CR1 registers to be cleared */
   1089            else if (flagindex == 6)
   \                     ??I2C_ClearFlag_2:
   \   00000022   062B               CMP      R3,#+6
   \   00000024   05D1               BNE.N    ??I2C_ClearFlag_4
   1090            {
   1091              /* Read the SR1 register */
   1092              (void)I2Cx->SR1;
   \   00000026   818A               LDRH     R1,[R0, #+20]
   1093          
   1094              /* Write on the CR1 register */
   1095              I2Cx->CR1 |= CR1_PE_Set;
   \   00000028   0288               LDRH     R2,[R0, #+0]
   \   0000002A   52F00102           ORRS     R2,R2,#0x1
   \   0000002E   0280               STRH     R2,[R0, #+0]
   \   00000030   01E0               B.N      ??I2C_ClearFlag_5
   1096            }
   1097            /* Flags that need a read of SR1 and SR2 registers to be cleared */
   1098            else /*flagindex == 0xA*/
   1099            {
   1100              /* Read the SR1 register */
   1101              (void)I2Cx->SR1;
   \                     ??I2C_ClearFlag_4:
   \   00000032   818A               LDRH     R1,[R0, #+20]
   1102          
   1103              /* Read the SR2 register */
   1104              (void)I2Cx->SR2;
   \   00000034   008B               LDRH     R0,[R0, #+24]
   1105            }
   1106          }
   \                     ??I2C_ClearFlag_5:
   \                     ??I2C_ClearFlag_3:
   \                     ??I2C_ClearFlag_1:
   \   00000036   11BC               POP      {R0,R4}
   \   00000038   7047               BX       LR               ;; return
   1107          
   1108          /*******************************************************************************
   1109          * Function Name  : I2C_GetITStatus
   1110          * Description    : Checks whether the specified I2C interrupt has occurred or not.
   1111          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
   1112          *                  - I2C_IT: specifies the interrupt source to check. 
   1113          *                    This parameter can be one of the following values:
   1114          *                       - I2C_IT_SMBALERT: SMBus Alert flag
   1115          *                       - I2C_IT_TIMEOUT: Timeout or Tlow error flag
   1116          *                       - I2C_IT_PECERR: PEC error in reception flag
   1117          *                       - I2C_IT_OVR: Overrun/Underrun flag (Slave mode)
   1118          *                       - I2C_IT_AF: Acknowledge failure flag
   1119          *                       - I2C_IT_ARLO: Arbitration lost flag (Master mode)
   1120          *                       - I2C_IT_BERR: Bus error flag
   1121          *                       - I2C_IT_TXE: Data register empty flag (Transmitter)
   1122          *                       - I2C_IT_RXNE: Data register not empty (Receiver) flag
   1123          *                       - I2C_IT_STOPF: Stop detection flag (Slave mode)
   1124          *                       - I2C_IT_ADD10: 10-bit header sent flag (Master mode)
   1125          *                       - I2C_IT_BTF: Byte transfer finished flag
   1126          *                       - I2C_IT_ADDR: Address sent flag (Master mode) ADSL
   1127          *                                        Address matched flag (Slave mode)ENDAD
   1128          *                       - I2C_IT_SB: Start bit flag (Master mode)
   1129          * Output         : None
   1130          * Return         : The new state of I2C_IT (SET or RESET).
   1131          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1132          ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, u32 I2C_IT)
   1133          {
   \                     I2C_GetITStatus:
   \   00000000   78B4               PUSH     {R3-R6}
   \   00000002   0200               MOVS     R2,R0
   1134            ITStatus bitstatus = RESET;
   \   00000004   0020               MOVS     R0,#+0
   1135            u32 i2cstatus = 0;
   \   00000006   0023               MOVS     R3,#+0
   1136            u32 flag1 = 0, flag2 = 0;
   \   00000008   0024               MOVS     R4,#+0
   \   0000000A   0025               MOVS     R5,#+0
   1137          
   1138            /* Check the parameters */
   1139            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1140            assert_param(IS_I2C_GET_IT(I2C_IT));
   1141          
   1142            /* Read the I2Cx status register */
   1143            flag1 = I2Cx->SR1;
   \   0000000C   968A               LDRH     R6,[R2, #+20]
   \   0000000E   3400               MOVS     R4,R6
   1144            flag2 = I2Cx->SR2;
   \   00000010   128B               LDRH     R2,[R2, #+24]
   \   00000012   1500               MOVS     R5,R2
   1145            flag2 = (flag2 & FLAG_Mask) << 16;
   \   00000014   2D04               LSLS     R5,R5,#+16
   1146          
   1147            /* Get the I2C status value */
   1148            i2cstatus = flag1 | flag2;
   \   00000016   55EA0402           ORRS     R2,R5,R4
   \   0000001A   1300               MOVS     R3,R2
   1149          
   1150            /* Get bit[23:0] of the flag */
   1151            I2C_IT &= FLAG_Mask;
   \   0000001C   0902               LSLS     R1,R1,#+8
   \   0000001E   090A               LSRS     R1,R1,#+8
   1152          
   1153            /* Check the status of the specified I2C flag */
   1154            if ((i2cstatus & I2C_IT) != (u32)RESET)
   \   00000020   1940               ANDS     R1,R1,R3
   \   00000022   491E               SUBS     R1,R1,#+1
   \   00000024   8941               SBCS     R1,R1,R1
   \   00000026   C943               MVNS     R1,R1
   \   00000028   C90F               LSRS     R1,R1,#+31
   \   0000002A   0800               MOVS     R0,R1
   1155            {
   1156              /* I2C_IT is set */
   1157              bitstatus = SET;
   1158            }
   1159            else
   1160            {
   1161              /* I2C_IT is reset */
   1162              bitstatus = RESET;
   1163            }
   1164            /* Return the I2C_IT status */
   1165            return  bitstatus;
   \   0000002C   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   72BC               POP      {R1,R4-R6}
   \   00000030   7047               BX       LR               ;; return
   1166          }
   1167          
   1168          /*******************************************************************************
   1169          * Function Name  : I2C_ClearITPendingBit
   1170          * Description    : Clears the I2Cxs interrupt pending bits.
   1171          * Input          : - I2Cx: where x can be 1 or 2 to select the I2C peripheral.
   1172          *                  - I2C_IT: specifies the interrupt pending bit to clear. 
   1173          *                    This parameter can be one of the following values:
   1174          *                       - I2C_IT_SMBALERT: SMBus Alert flag
   1175          *                       - I2C_IT_TIMEOUT: Timeout or Tlow error flag
   1176          *                       - I2C_IT_PECERR: PEC error in reception flag
   1177          *                       - I2C_IT_OVR: Overrun/Underrun flag (Slave mode)
   1178          *                       - I2C_IT_AF: Acknowledge failure flag
   1179          *                       - I2C_IT_ARLO: Arbitration lost flag (Master mode)
   1180          *                       - I2C_IT_BERR: Bus error flag
   1181          *                       - I2C_IT_STOPF: Stop detection flag (Slave mode)
   1182          *                       - I2C_IT_ADD10: 10-bit header sent flag (Master mode)
   1183          *                       - I2C_IT_BTF: Byte transfer finished flag
   1184          *                       - I2C_IT_ADDR: Address sent flag (Master mode) ADSL
   1185          *                                        Address matched flag (Slave mode)ENDAD
   1186          *                       - I2C_IT_SB: Start bit flag (Master mode)
   1187          * Output         : None
   1188          * Return         : None
   1189          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1190          void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, u32 I2C_IT)
   1191          {
   \                     I2C_ClearITPendingBit:
   \   00000000   18B4               PUSH     {R3,R4}
   1192            u32 flagpos = 0;
   \   00000002   0022               MOVS     R2,#+0
   1193            u32 flagindex = 0;
   \   00000004   0023               MOVS     R3,#+0
   1194          
   1195            /* Check the parameters */
   1196            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   1197            assert_param(IS_I2C_CLEAR_IT(I2C_IT));
   1198          
   1199            /* Get the I2C flag position */
   1200            flagpos = I2C_IT & FLAG_Mask;
   \   00000006   0C02               LSLS     R4,R1,#+8
   \   00000008   240A               LSRS     R4,R4,#+8
   \   0000000A   2200               MOVS     R2,R4
   1201          
   1202            /* Get the I2C flag index */
   1203            flagindex = I2C_IT >> 28;
   \   0000000C   090F               LSRS     R1,R1,#+28
   \   0000000E   0B00               MOVS     R3,R1
   1204          
   1205            /* Clear the flag by writing 0 */
   1206            if (flagindex == 1)
   \   00000010   012B               CMP      R3,#+1
   \   00000012   02D1               BNE.N    ??I2C_ClearITPendingBit_0
   1207            {
   1208              /* Clear the selected I2C flag */
   1209              I2Cx->SR1 = (u16)~flagpos;
   \   00000014   D143               MVNS     R1,R2
   \   00000016   8182               STRH     R1,[R0, #+20]
   \   00000018   0DE0               B.N      ??I2C_ClearITPendingBit_1
   1210            }
   1211            /* Flags that need a read of the SR1 register to be cleared */
   1212            else if (flagindex == 2)
   \                     ??I2C_ClearITPendingBit_0:
   \   0000001A   022B               CMP      R3,#+2
   \   0000001C   01D1               BNE.N    ??I2C_ClearITPendingBit_2
   1213            {
   1214              /* Read the SR1 register */
   1215              (void)I2Cx->SR1;
   \   0000001E   808A               LDRH     R0,[R0, #+20]
   \   00000020   09E0               B.N      ??I2C_ClearITPendingBit_3
   1216            }
   1217            /* Flags that need a read of SR1 and a write on CR1 registers to be cleared */
   1218            else if (flagindex == 6)
   \                     ??I2C_ClearITPendingBit_2:
   \   00000022   062B               CMP      R3,#+6
   \   00000024   05D1               BNE.N    ??I2C_ClearITPendingBit_4
   1219            {
   1220              /* Read the SR1 register */
   1221              (void)I2Cx->SR1;
   \   00000026   818A               LDRH     R1,[R0, #+20]
   1222          
   1223              /* Write on the CR1 register */
   1224              I2Cx->CR1 |= CR1_PE_Set;
   \   00000028   0288               LDRH     R2,[R0, #+0]
   \   0000002A   52F00102           ORRS     R2,R2,#0x1
   \   0000002E   0280               STRH     R2,[R0, #+0]
   \   00000030   01E0               B.N      ??I2C_ClearITPendingBit_5
   1225            }
   1226            /* Flags that need a read of SR1 and SR2 registers to be cleared */
   1227            else /*flagindex == 0xA*/
   1228            {
   1229              /* Read the SR1 register */
   1230              (void)I2Cx->SR1;
   \                     ??I2C_ClearITPendingBit_4:
   \   00000032   818A               LDRH     R1,[R0, #+20]
   1231          
   1232              /* Read the SR2 register */
   1233              (void)I2Cx->SR2;
   \   00000034   008B               LDRH     R0,[R0, #+24]
   1234            }
   1235          }
   \                     ??I2C_ClearITPendingBit_5:
   \                     ??I2C_ClearITPendingBit_3:
   \                     ??I2C_ClearITPendingBit_1:
   \   00000036   11BC               POP      {R0,R4}
   \   00000038   7047               BX       LR               ;; return
   1236          
   1237          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                    .cstack
     --------                    -------
     I2C_ARPCmd                       0
     I2C_AcknowledgeConfig            0
     I2C_CalculatePEC                 0
     I2C_CheckEvent                  16
     I2C_ClearFlag                    8
     I2C_ClearITPendingBit            8
     I2C_Cmd                          0
     I2C_DMACmd                       0
     I2C_DMALastTransferCmd           0
     I2C_DeInit                       8
     I2C_DualAddressCmd               0
     I2C_FastModeDutyCycleConfig      0
     I2C_GeneralCallCmd               0
     I2C_GenerateSTART                0
     I2C_GenerateSTOP                 0
     I2C_GetFlagStatus               16
     I2C_GetITStatus                 16
     I2C_GetLastEvent                 8
     I2C_GetPEC                       0
     I2C_ITConfig                     0
     I2C_Init                        48
     I2C_OwnAddress2Config            0
     I2C_PECPositionConfig            0
     I2C_ReadRegister                 0
     I2C_ReceiveData                  0
     I2C_SMBusAlertConfig             0
     I2C_Send7bitAddress              0
     I2C_SendData                     0
     I2C_SoftwareResetCmd             0
     I2C_StretchClockCmd              0
     I2C_StructInit                   0
     I2C_TransmitPEC                  0


   Section sizes:

     Function/Label              Bytes
     --------------              -----
     I2C_DeInit                    68
     I2C_Init                     248
     I2C_StructInit                32
     I2C_Cmd                       26
     I2C_DMACmd                    26
     I2C_DMALastTransferCmd        26
     I2C_GenerateSTART             26
     I2C_GenerateSTOP              26
     I2C_AcknowledgeConfig         26
     I2C_OwnAddress2Config         24
     I2C_DualAddressCmd            26
     I2C_GeneralCallCmd            26
     I2C_ITConfig                  24
     I2C_SendData                   6
     I2C_ReceiveData                6
     I2C_Send7bitAddress           22
     I2C_ReadRegister               8
     I2C_SoftwareResetCmd          26
     I2C_SMBusAlertConfig          30
     I2C_TransmitPEC               26
     I2C_PECPositionConfig         30
     I2C_CalculatePEC              26
     I2C_GetPEC                    10
     I2C_ARPCmd                    26
     I2C_StretchClockCmd           26
     I2C_FastModeDutyCycleConfig   30
     I2C_GetLastEvent              34
     I2C_CheckEvent                48
     I2C_GetFlagStatus             50
     I2C_ClearFlag                 58
     I2C_GetITStatus               50
     I2C_ClearITPendingBit         58

 
 1 174 bytes in section .text
 
 1 174 bytes of CODE memory

Errors: none
Warnings: none
